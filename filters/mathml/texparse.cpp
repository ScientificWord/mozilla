
//  Written May, 1996 by JBM.

#include "texparse.h"
#include "grammar.h"
#include "tokizer.h"
#include "tmpliter.h"
#include "logfiler.h"
#include "nthmstor.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#ifdef TESTING
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ctor The caller has created a "grammar" which is passed in.
// Note that Parser is not a persistent object - a new Parser
// is constructed for each parsing task.

TeXParser::TeXParser( Grammar* TeX_grammar,Tokizer* s_tokizer,
						FILE* srcfile,LogFiler* the_logger ) {

  is_clipboard  =  FALSE;

  TCI_ASSERT( TeX_grammar );
  s_grammar =  TeX_grammar;
  TCI_ASSERT( s_tokizer );
  tokizer   =  s_tokizer;
  logfiler  =  the_logger;

  context_sp  =  0;               // zero the context stack
}


TNODE* TeXParser::ParsePreamble( U32& preamble_len,U16& error_code ) {

  TNODE* preamble =  (TNODE*)NULL;
  preamble_len  =  0L;
  error_code  =  0;

  if ( tokizer->HasPreamble() ) {

    U8* enders_list =  (U8*)TCI_NEW( char[18] );
    strcpy( (char*)enders_list,"\\begin{document}" );
    enders_list[16] =  0;		// a list - catenation - of zstrings
    enders_list[17] =  0;

    PushContext( (U8*)"PREAMBLE",NULL,enders_list,NULL,IM_PREAMBLE );
      U32 end_off;
      U32 bytesdone;
      TCI_BOOL exclude_ender =  FALSE;
      preamble  =  RunToList( 0L,end_off,0,bytesdone,exclude_ender,
      							            error_code,TRUE );
    PopContext();

    if ( error_code ) {
      DisposeTList( preamble );
    } else {
      preamble_len  =  bytesdone;

  // A comment TNODE carrying a list of comment lines may have been
  //  generated by tokizer.  We append it to the end of tlist.

      TNODE* comment  =  tokizer->GetComments();
      if ( comment ) {
        if ( preamble ) {
          TNODE* trover =  preamble;
          while ( trover->next )  trover  =  trover->next;
          trover->next  =  comment;
        } else
          preamble =  comment;
  	  }
    }

  }     // if ( tokizer->HasPreamble() )

  return preamble;
}


TeXParser::~TeXParser() {

//  TCI_ASSERT( context_sp == 0 );
}


// "Parse" a stream into it's grammatical elements.
//   Push a context, call RunToList, then pop the context
//   Returns a list of "TNODE"s - recursive list of objects found.

TNODE* TeXParser::Parse( U8* context,U8* src_LaTeX_bytes,
								TCI_BOOL is_clipbrd ) {

  TNODE* rv =  NULL;
  is_clipboard  =  is_clipbrd;

  tokizer->SaveInputBuffer();
  tokizer->SetInputMode( IM_STANDARD );
  tokizer->SetSrcBuffer( src_LaTeX_bytes );

/*
U8* src_ptr =  tokizer->GetSrcPtr( 0 );
char zzz[96];
char src_str[60];
U16 i =  0;
while ( src_ptr[i] && i<59 ) {
  src_str[i]  =  src_ptr[i];
  i++;
}
src_str[i]  =  0;
sprintf( zzz,"TeXParser::Parse src=!%s!\n",src_str );
JBMLine( zzz );
*/

  U16 save_sp =  context_sp;

  U8 curr_context[ CONTEXT_NOM_LIM ];
  if ( context )
    strcpy( (char*)curr_context,(char*)context );
  else
    s_grammar->GetDefaultContext( curr_context );

  if ( curr_context[0] ) {
//char zzz[80];
//sprintf( zzz,"TeXParser::Parse, context=%s\n",context );
//JBMLine( zzz );
    PushContext( curr_context,(U8*)NULL,(U8*)NULL,NULL,0 );
  }

  TCI_BOOL exclude_ender =  FALSE;
  U32 end_off;
  U32 bytesdone;            // not used after value is passed back
  U16 error_flag;
  rv  =  RunToList( 0,end_off,0,bytesdone,exclude_ender,
  	  										error_flag,TRUE );


  if ( curr_context[0] ) {
    PopContext();
  }

  if ( context_sp != save_sp ) {
/*
char zzz[80];
sprintf( zzz,"CONTEXT STACK ERROR DURING PARSE! start_sp=%d, end_sp=%d\n",
                save_sp,context_sp );
JBMLine( zzz );
*/
	TCI_ASSERT(0);
    while ( context_sp > save_sp ) PopContext();
  }

  is_clipboard  =  FALSE;
  tokizer->RestoreInputBuffer();

  return rv;
}


// Make a "translation list" from a run of bytes (which we tokenize).
//   Caller may push a "context" on "context_stack" before calling this.
//   The context may specify a "start token" and an "end token".
//
// This function contains the loop that processes src "tokens".
// When this function returns NULL, the current file is done.

TNODE* TeXParser::RunToList( U32 beg_off,U32& end_off,
                          	U16 max_tokens,       // 0 means no limit
                          		U32& bytesdone,TCI_BOOL exclude_ender,
                          			U16& error_flag,
                          				TCI_BOOL is_primary ) {

  TNODE* head =  (TNODE*)NULL;
  TNODE* tail;

  U32 src_off =  beg_off;

  U16 save_sp =  context_sp;
  U8* context =  ( context_sp > 0 ) ?
   					context_stack[ context_sp-1 ].c_name : (U8*)NULL;

  TNODE* token_node;            // GetToken out variables
  U8*    ztoken_template;

  TOKEN_INFO* enders_list     =  NULL;
  TOKEN_INFO* error_stop_list =  NULL;

// error_stop_list is new - for error recovery. It's a list
//  of tokens that can't occur in the run we're processing.
//  If we hit an error_stop, we're beyond the end of the
//  current run.  Stop processing tokens and return an error.

  U16 token_count =  0;
  U8* start_toks  =  (U8*)NULL;
  if ( context_sp > 0 ) {
    start_toks    =  context_stack[context_sp-1].c_start_token;
    U8* end_toks  =  context_stack[context_sp-1].c_end_token;
    if ( end_toks ) 
      enders_list     =  MakeTokenList( end_toks,context );
    U8* stop_toks =  context_stack[context_sp-1].c_error_stops;
    if ( stop_toks ) 
      error_stop_list =  MakeTokenList( stop_toks,context );
  }

  TCI_BOOL grouping_error    =  FALSE;
  TCI_BOOL questionable_exit =  FALSE;
  TCI_BOOL token_done;
  while ( TRUE ) {      // loop thru tokens - advances src_off

    error_flag  =  0;

    ztoken_template =  NULL;
    token_node  =  tokizer->GetTNODE( context,src_off,&ztoken_template );
    if ( !token_node ) {
      questionable_exit =  TRUE;
      break;
    }

    TNODE* comment  =  tokizer->GetComments();
    if ( comment ) {
      if ( !head )
        head  =  comment;
      else {
        tail->next  =  comment;
        comment->prev  =  tail;
      }
      tail  =  comment;
    }

    token_count++;
    token_done  =  FALSE;

  // update the src offsets in the returned node - relative to absolute

    U32 prev_off  =  src_off;

    token_node->src_offset1 +=  src_off;
    token_node->src_offset2 +=  src_off;
    src_off =  token_node->src_offset1;

    U16 token_len =  token_node->src_offset2 - token_node->src_offset1;

// Check for "\end{document}" - \end{document}<uID20.3.0>

    if ( !strcmp("20.3.0",(char*)token_node->zuID) ) {
      DisposeTNode( token_node );
      src_off =  token_node->src_offset1;
      break;
    }

// Certain tokens are only valid as enders of the current run.
// Examples: $ in MATH (2.2.0) can only end MATH
// Examples: } in MATH or TEXT(6.1.1) can only end a group
// If we encounter these tokens, and they aren't in "enders_list",
//  we're in an error condition.

    TCI_BOOL bad_group_end  =  FALSE;
    if ( !strcmp("2.2.0",(char*)token_node->zuID) )
      if ( !IsTokenInList(token_node->zuID,enders_list) )
        bad_group_end  =  TRUE;
    if ( !strcmp("6.1.1",(char*)token_node->zuID) )
      if ( !IsTokenInList(token_node->zuID,enders_list) )
        bad_group_end  =  TRUE;
    if ( bad_group_end ) {
      grouping_error  =  TRUE;
      break;
    }

// The next problem is "$$" - if we're in a run ended by "$"
//  we have to switch token_node to "$".  $$<uID2.2.2>

    if ( !strcmp("2.2.2",(char*)token_node->zuID) ) {
      if ( IsTokenInList((U8*)"2.2.0",enders_list) ) {
        strcpy( (char*)token_node->zuID,"2.2.0" );
        token_node->src_tok[1]  =  0;
        token_node->src_offset2--;
        token_len--;
      }
    }

// At present "RunToList" breaks at the end of a level 0 paragraph

    if ( is_primary && !enders_list && !is_clipboard ) {

      if ( !strcmp("9.2.0",(char*)token_node->zuID) ) {
    // LaTeX \par or token generated by empty line
        if ( !head ) {
          // do nothing
        } else {

	// We don't break at an empty line after a section header.
	// There may be a \label that must be moved to the attribute
	//  list of the header.

          U16 uobjtype,usubtype,uID;
          GetUids( tail->zuID,uobjtype,usubtype,uID );

          // jcs -- compiler (gcc) warning says this is always true
          if ( uobjtype==5 && usubtype==200 && uID>=0 && uID<=6 ) {
		// don't break
		    //TCI_ASSERT(0);
          } else {
        // add par token_node to current batch
            tail->next  =  token_node;
            token_node->prev  =  tail;
            tail    =  token_node;
            src_off =  token_node->src_offset2;
            break;
          }
        }		// clause to check tail for section cmd

      }		// clause for par sep node

    }	// if ( is_primary && !enders_list && !is_clipboard )

    if ( token_count==1 && start_toks ) {
//JBMLine( "RunToList::checking start token\n" );
    // does this token start the run we're parsing?
    // Need to use token_node->zuID and compare to start_toks, zuID  

      char* curr_tok  =  (char*)tokizer->GetSrcPtr( src_off );

      if ( !strncmp((char*)start_toks,curr_tok,token_len) ) {   // starter
//JBMLine( "RunToList::stepping over start token\n" );
        src_off +=  token_len;
        DisposeTNode( token_node );
        token_node  =  (TNODE*)NULL;

      } else {          // run start token not found - an error?

        // The object "{}" is special - it can start and end an empty run

        if ( !strcmp("9.1.10",(char*)token_node->zuID) ) {
          bytesdone =  ( src_off + token_len ) - beg_off;
          DisposeTNode( token_node );
/*
JBMLine( "FOUND run end token\n" );
char zzz[80];
sprintf( zzz,"RunToList returns, bytesdone=%ld\n",bytesdone );
JBMLine( zzz );
*/
          if ( enders_list )
            ClearTokenList( enders_list );
          if ( error_stop_list )
            ClearTokenList( error_stop_list );
          end_off =  src_off;
TCI_ASSERT( save_sp == context_sp );
          return head;
        } else {						// error
          U32 line_start_off,linenum;
          U8* zline =  tokizer->GetBufferedLine( prev_off,
          									line_start_off,linenum );
          logfiler->LogSrcError( MISSING_RUN_STARTER,start_toks,zline,
                                    prev_off-line_start_off,linenum );
          if ( zline ) delete zline;
          error_flag  =  MISSING_RUN_STARTER;
        }

      }			// start token not found clause

      token_done  =  TRUE;

    } else if ( enders_list && token_len ) {
    // does this token end the run we're parsing?

      TOKEN_INFO* rover =  enders_list;
      while ( rover ) {  
/*
char zzz[128];
sprintf( zzz,"Checking for end of run, %s, %s, %s, %s\n",
rover->ztoken,rover->ztuID,token_node->src_tok,token_node->zuID );
JBMLine( zzz );
*/
        if ( !strcmp((char*)token_node->zuID,(char*)rover->ztuID) ) {
          bytesdone =  src_off - beg_off;
          if ( !exclude_ender )
            bytesdone +=  token_len;
          DisposeTNode( token_node );
/*
JBMLine( "FOUND run end token\n" );
sprintf( zzz,"RunToList returns, bytesdone=%ld\n",bytesdone );
JBMLine( zzz );
*/
          end_off =  src_off;
          ClearTokenList( enders_list );
          if ( error_stop_list )
            ClearTokenList( error_stop_list );
          TCI_ASSERT( save_sp == context_sp );
          return head;
        }
        rover =  rover->next;
      }         // while loop thru list of run enders

      if ( error_stop_list ) {
      // Is this token an error stop for the run we're parsing?
/*
char zzz[80];
sprintf( zzz,"Checking for run error stop, %s\n",error_stop_list->ztoken );
JBMLine( zzz );
*/
        TOKEN_INFO* rover =  error_stop_list;
        while ( rover ) {  
          if ( !strcmp((char*)token_node->zuID,(char*)rover->ztuID) ) {
/*
char zzz[80];
JBMLine( "FOUND run error stop token\n" );
sprintf( zzz,"RunToList, source line=%ld\n",token_node->src_linenum );
JBMLine( zzz );
*/
            bytesdone =  src_off - beg_off;
            DisposeTNode( token_node );
            end_off   =  src_off;
            ClearTokenList( enders_list );
            ClearTokenList( error_stop_list );
TCI_ASSERT( save_sp == context_sp );
            error_flag  =  MISSING_RUN_ENDER;
            return head;
          }
          rover =  rover->next;
        }         // while loop thru error stops

      }   // check for run error stop

	}	// clause to handle run enders

    if ( !token_done ) {
//JBMLine( "Token NOT DONE\n" );

      U16 objclass  =  atoi( (char*)token_node->zuID );
      switch ( objclass ) {   // TeXParser action switch on TokenType
        case UNKNOWN_CLASS  :  {        // 999
          U8 zhint[128];
          zhint[ 0 ]  =  0;
          if ( context && *context ) {
            strcat( (char*)zhint,"  context=" );
            strcat( (char*)zhint,(char*)context );
          }

          U16 msgID =  UNDEFINED_TOKEN;
          U16 grammar_error =  tokizer->GetTokenError();
          if      ( grammar_error == 1 )
            msgID =  PARAM_EXPECTED;
          else if ( grammar_error == 2 )
            msgID =  BAD_PARAM_LIST;
          else
            msgID =  UNDEFINED_TOKEN;

          U32 line_start_off,linenum;
          U8* zline =  tokizer->GetBufferedLine( src_off,line_start_off,linenum );
          logfiler->LogSrcError( msgID,zhint,zline,src_off-line_start_off,linenum );
          if ( zline ) delete zline;
          error_flag  =  UNDEFINED_TOKEN;
//JBMLine( "TeXParser::RunToList - UNDEFINED_TOKEN\n" );
        }

        case 0  : {       // unrecognized bytes
          char* tmp =  TCI_NEW( char[ token_len+1 ] );
          U8* src   =  tokizer->GetSrcPtr( token_node->src_offset1 );
          strncpy( tmp,(char*)src,token_len );
          tmp[ token_len ]    =  0;
          token_node->var_value  =  (U8*)tmp;
          token_node->v_len   =  token_len;
          token_node->v_type  =  0;
        }
        break;

        case 3  :         // symbol
        case 10 :         // Fence attribute
        {
          //  No action required here - just add token_node to the list
        }
        break;

        case 1  : {       // Context Start
          U8* tc  =  s_grammar->GetContextName( token_node->zuID );
          if ( tc ) {
            PushContext( tc,(U8*)NULL,(U8*)NULL,NULL,0 );
            context =  context_stack[ context_sp-1 ].c_name;
          }
        }
        break;
                          
        case 2  : {       // Context End
          PopContext();
          context =  ( context_sp > 0 ) ? 
          			context_stack[ context_sp-1 ].c_name : (U8*)NULL;
        }
        break;

		case 18 :
		case 16 :
		case 14 :
		case 6  :
        case 9  :         // spaces - this is temporary
        case 8  :         // function
        case 7  :         // big operator
        case 4  :         // Accent
        case 5  : {       // structured - has a template
          if ( ztoken_template ) {
/*
JBMLine( (char*)token_node->zuID );
JBMLine( ".\n" );
JBMLine( (char*)ztoken_template );
JBMLine( ".\n" );
*/
            U16 tmpl_len  =  strlen( (char*)ztoken_template );
            if ( tmpl_len ) {
              U32 nbytes;
              TNODE* tplist =  TemplateToList( ztoken_template,tmpl_len,
                                                src_off,nbytes,error_flag );
              if ( !error_flag ) {
                token_node->parts =  tplist;
                if ( tplist )
                  tplist->sublist_owner =  token_node;
                token_node->src_offset2 =  token_node->src_offset1 + nbytes;
              }
            }
          } else {		// object has no template
/*
char zzz[80];
sprintf( zzz,"Object has no template - %s\n",token_node->zuID );
JBMLine( zzz );
*/
		  }
        }
        break;

        default :  
        break;

      }         // switch ( objclass )

    }           // if ( !token_done )

// A translation node was generated by "GetToken" and may have been
//  configured/modified/embellished in the switch above.

    if ( error_flag ) {

      if ( token_node )
        DisposeTList( token_node );
      if ( head ) {
        DisposeTList( head );
        head  =  (TNODE*)NULL;
      }
      break;            // exit while loop thru tokens
  
    } else if ( token_node ) {

      if ( !head )
        head  =  token_node;
      else {
        tail->next  =  token_node;
        token_node->prev  =  tail;
      }
      tail  =  token_node;
/*
char vvv[80];
sprintf( vvv,"Update src_off, old=%lu, new=%lu\n",
src_off,token_node->src_offset2 );
JBMLine( vvv );
*/
      src_off =  token_node->src_offset2;

    } else {    // we still need to advance "ptr"

      //TCI_ASSERT( 0 );

    }

    if ( max_tokens && token_count >= max_tokens ) break;

    //if ( src_ptr >= end_ptr ) {
    //  questionable_exit =  TRUE;
    //  break;
    //}

  }     // while loop thru src tokens

  if ( (questionable_exit && enders_list) || grouping_error ) {
    U32 line_start_off,linenum;
    U8* zline =  tokizer->GetBufferedLine( src_off,line_start_off,linenum );
	  if ( grouping_error ) {
      logfiler->LogSrcError( UNEXPECTED_ENDOFGROUP,token_node->src_tok,
                                    zline,src_off-line_start_off,linenum );
      DisposeTNode( token_node );
      token_node  =  (TNODE*)NULL;
	  } else {
      logfiler->LogSrcError( UNEXPECTED_ENDOFRUN,enders_list->ztoken,
                                    zline,src_off-line_start_off,linenum );
TCI_ASSERT(0);
	  }
TCI_ASSERT(0);
    if ( zline ) delete zline;
    error_flag    =   UNEXPECTED_ENDOFRUN;
    if ( head ) {
      DisposeTList( head );
      head  =  (TNODE*)NULL;
    }
  }			// grouping error clause

  end_off   =  src_off;
  bytesdone =  src_off - beg_off;

/*
//char zzz[80];
sprintf( zzz,"RunToList returns, bytesdone=%ld\n",bytesdone );
JBMLine( zzz );
*/

  if ( enders_list )
    ClearTokenList( enders_list );
  if ( error_stop_list )
    ClearTokenList( error_stop_list );

  if ( error_flag )
    while ( save_sp < context_sp ) PopContext();

  return head;
}       // RunToList



// src+beg_off should point to an instance of ztemplate.
//  This function is called by "RunToList" and can make recursive calls
//    back to "RunToList".

TNODE* TeXParser::TemplateToList( U8* ztemplate,U16 tmpl_len,
                                  U32 beg_off,
                                    U32& bytesdone,U16& error_flag ) {
/*
char zzz[256];
sprintf( zzz,"TemplateToList::%s\n",ztemplate );
JBMLine( zzz );
*/
  U8* context =  ( context_sp > 0 ) ?
                      context_stack[ context_sp-1 ].c_name : (U8*)NULL;

  TmplIterater* tmpl  =  
    	TCI_NEW( TmplIterater(s_grammar,ztemplate,tmpl_len,logfiler) );

  TNODE* head =  (TNODE*)NULL;        // the list that we return
  TNODE* tail;
  TNODE* newnode;

  TCI_BOOL in_limbo =  FALSE;
  U32 src_off =  beg_off;

  U16 tmpl_elm_type;
  while ( tmpl_elm_type = tmpl->GetNextElement() ) {  // loop thru template
//JBMLine( "Top of loop thru TEMPLATE\n" );

    newnode     =  (TNODE*)NULL;
    error_flag  =  0;

    switch ( tmpl_elm_type ) {

      case TMPL_SYNTAX_ERROR      : {
        error_flag  =  BAD_TMPL_SYNTAX;
      }
      break;

      case TMPL_ELEMENT_UNKNOWN   : {   // Error already logged by GetNextElement
        error_flag  =  UNKNOWN_TMPL_ELEMENT;
      }
      break;

      case TMPL_ELEMENT_LITERAL   : {   // !blah|whatever|!

        U16 lit_len;
        U8* lit_ptr =  tmpl->GetField( TFIELD_lit,lit_len );

        TCI_BOOL found_error  =  FALSE;
        U8*     ztmpl;        // a dummy

        TNODE*  token_node;
        do {
          token_node  =  tokizer->GetTNODE( context,src_off,&ztmpl );
          if ( token_node ) {
            if ( strcmp((char*)token_node->zuID,"9.1.1") )
              break;
            else {
              src_off +=  token_node->src_offset2;
              DisposeTNode( token_node );
              token_node  =  (TNODE*)NULL;
            }
          } else
            break;
        } while (TRUE);

        TNODE* comment  =  tokizer->GetComments();
        if ( comment )
          newnode =  comment;
        if ( token_node ) {
          U16 src_tok_len =  token_node->src_offset2 - token_node->src_offset1;
          src_off +=  token_node->src_offset1;
          if ( ProcessTemplateLiteral(lit_ptr,lit_len,token_node,context) ) {
//JBMLine( "ProcessLit OK\n" );
            src_off +=  src_tok_len;
            if ( in_limbo ) in_limbo  =  FALSE;
          } else {
//JBMLine( "ProcessLit FAILED\n" );
            found_error =  TRUE;
            if ( !strcmp((char*)token_node->zuID,"9.1.10") ) {    // "{}"
              if ( lit_len==3 && *(lit_ptr+1)=='{' ) {
                src_off +=  1;
                found_error =  FALSE;
    			if ( in_limbo ) in_limbo  =  FALSE;
              } else
				TCI_ASSERT(0);
            } else
			  TCI_ASSERT(0);
		  }

          DisposeTNode( token_node );
        } else
          found_error =  TRUE;

        if ( found_error ) {
          U8 zhint[128];
          strncpy( (char*)zhint,(char*)lit_ptr,lit_len );
          zhint[ lit_len ]  =  0;
          U32 line_start_off,linenum;
          U8* zline =  tokizer->GetBufferedLine( src_off,line_start_off,linenum );
          logfiler->LogSrcError( MISSING_TMPL_LITERAL,zhint,
                                      zline,src_off-line_start_off,linenum );
          if ( zline ) delete zline;
		  if ( in_limbo )
            error_flag  =  0;
		  else
            error_flag  =  MISSING_TMPL_LITERAL;
        }
      }
      break;

      case TMPL_ELEMENT_IF        : {

// "IF(env,object1)elseIF(object2)ELSE()ifEND

    // We loop thru the alternative objects.
    //  If one of the "objects" is found, the node generated
    //  by parsing the object is added to the list.

    // Get the next token in the src stream.  At present,
    //  the alternation chosen is based on this token.

        TCI_BOOL found_error =  FALSE;
        U8* ztmpl;
        U8* tENV  =  tmpl->GetField( TFIELD_env );

        if ( tENV && !strcmp((char*)tENV,"INHERIT") )
          tENV  =  context;

        PushContext( tENV,NULL,NULL,NULL,0 );

    // get the first token that is not a space

        TNODE*  token_node;
        do {
          token_node  =  tokizer->GetTNODE( tENV,src_off,&ztmpl );
          if ( token_node ) {
            if ( strcmp((char*)token_node->zuID,"9.1.1") )
              break;		// break at first non-space
            else {
              src_off +=  token_node->src_offset2;
              DisposeTNode( token_node );
              token_node  =  (TNODE*)NULL;
            }
          } else
            break;
        } while (TRUE);

        if ( token_node ) {

      // update the src offsets in the returned node

          U16 src_tok_len =  token_node->src_offset2
                                        - token_node->src_offset1;
          U32 prev_off  =  src_off;
          token_node->src_offset1 +=  src_off;
          token_node->src_offset2 +=  src_off;
          src_off =  token_node->src_offset1;     // points to token

          U16 condition_len;
          U8* condition_ptr;

          TCI_BOOL node_used  =  FALSE;
          TCI_BOOL done       =  FALSE;
          U16 alter_elm_type  =  TMPL_ELEMENT_IF;
          while ( !done && alter_elm_type != TMPL_ELEMENT_ifEND ) {

            if ( alter_elm_type == TMPL_ELEMENT_ELSE ) {
              U16 tmpl_len;
              U8* ztmpl =  tmpl->GetField( TFIELD_else,tmpl_len );
              if ( ztmpl && *ztmpl ) {
                U32 nbytes;
                newnode =  TemplateToList( ztmpl,tmpl_len,
                                          src_off,nbytes,error_flag );
                if ( !error_flag ) {
                  newnode->src_offset1  =  src_off;
                  newnode->src_offset2  =  src_off + nbytes;
                  src_off +=  nbytes;
                }
              }

              done  =  TRUE;
              
            } else {			// get the condition - "?\format?"

              condition_ptr =  tmpl->GetField( TFIELD_condition,condition_len );
              condition_len -=  2;
              condition_ptr +=  1;

          // See if token_node matches the condition
          // should get uID of condition token and check against token_node
                
              char* curr_tok  =  (char*)tokizer->GetSrcPtr( src_off );
              if ( condition_len == src_tok_len    // template matches src_ptr
              && !strncmp((char*)condition_ptr,curr_tok,condition_len) ) {

// MathML
                U8* zjbm  =  tmpl->GetField( TFIELD_ID );
                TCI_BOOL use_macro  =  FALSE;
                if ( zjbm && *zjbm == '_' ) {
                  U16 zln =  strlen( (char*)zjbm );
                  if ( zln > 2 && zjbm[zln-1] == '_' )
                    use_macro  =  TRUE;
                }
                if ( use_macro ) {
                  tmpl_len  =  strlen( (char*)zjbm );
                  U32 nbytes;
                  newnode =  TemplateToList( zjbm,tmpl_len,
                                          src_off,nbytes,error_flag );
                  if ( !error_flag ) {
                    newnode->src_offset1  =  src_off;
                    newnode->src_offset2  =  src_off + nbytes;
                    src_off +=  nbytes;
                  }

                } else {
// end MathML

                  TNODE* comment  =  tokizer->GetComments();
                  if ( comment ) {
                    newnode =  comment;
                    newnode->next =  token_node;
                    token_node->prev =  newnode;
                  } else
                    newnode =  token_node;

                  node_used =  TRUE;

                  if ( ztmpl && *ztmpl ) {
                    U16 tmpl_len  =  strlen( (char*)ztmpl );
                    U32 nbytes;
                    TNODE* c_tree =  TemplateToList( ztmpl,tmpl_len,
                                                  src_off,
                                                nbytes,error_flag );
                    if ( !error_flag ) {
                      token_node->parts  =  c_tree;
                      if ( c_tree )
                        c_tree->sublist_owner =  token_node;
                      token_node->src_offset1  =  src_off;
                      token_node->src_offset2  =  src_off + nbytes;
                      src_off +=  nbytes;
                    }

                  } else {
                    src_off +=  src_tok_len;
                  }

                  done  =  TRUE;

                }

              }           // condition met clause

            }         // condition set clause

            alter_elm_type  =  tmpl->GetNextElement();

          }     // while ( !done );
//JBMLine( "End of loop\n" );

          if ( alter_elm_type != TMPL_ELEMENT_ifEND ) {
//JBMLine( "Calling EndAlternation\n" );
            if ( !tmpl->EndAlternation() )
              found_error =  TRUE;
          }
          if ( !node_used )
            DisposeTNode( token_node );

        } else {
                 // unexpected end of input
          //found_error =  TRUE;
        }

        PopContext();
      }
      break;

      case TMPL_ELEMENT_OPTPARAM  : {
        newnode =  DoOptParam( tmpl,context,src_off,error_flag );
      }
      break;

      case TMPL_ELEMENT_REQPARAM  :
        newnode =  DoReqParam( tmpl,context,src_off,error_flag );
      break;

      case TMPL_ELEMENT_BUCKET  : {

        TNODE* comment  =  tokizer->GetComments();
        newnode =  MakeTNode( 0,0,0,tmpl->GetField(TFIELD_ID) );

        U8* start_ptr =  tmpl->MakeTokenList( TFIELD_start );

        TCI_BOOL exclude_ender =  FALSE;
        U8* end_ptr   =  tmpl->MakeTokenList( TFIELD_end );
        if ( !end_ptr ) {
          end_ptr       =  tmpl->MakeTokenList( TFIELD_stopper );
          exclude_ender =  TRUE;
        }

        U8* error_stops =  tmpl->MakeTokenList( TFIELD_list_end );

        U8* the_ENV =  tmpl->GetField( TFIELD_env );
        if ( the_ENV && !strcmp((char*)the_ENV,"INHERIT") )
          the_ENV =  context;

        PushContext( the_ENV,start_ptr,end_ptr,error_stops,0 );

          U32 nbytes;
          U32 end_off;
          TNODE* rlist  =  RunToList( src_off,end_off,0,
                            nbytes,exclude_ender,error_flag,FALSE );
        PopContext();

        if ( error_flag == MISSING_RUN_ENDER ) {
	// This is a special error condition from which we try to recover.
	// We're at a token known to be beyond our current position
	//  in the template.  We proceed thru the template, ignoring
	//  expected literals (an error is logged) and generating
	//  empty buckets, etc.
          in_limbo    =  TRUE;
          error_flag  =  0;
        }

        if ( !error_flag ) {

          if ( the_ENV && !strcmp((char*)the_ENV,"TEXT") )
            if ( rlist && exclude_ender )
              rlist =  TrimWhite( rlist );

          if ( comment && !start_ptr ) {
            rlist =  JoinTLists( comment,rlist );
			comment =  NULL;
		  }

          LinkContentsToParent( newnode,rlist,the_ENV );
          //newnode->contents   =  rlist;
          //if ( rlist )
          //  rlist->sublist_owner  =  newnode;

          newnode->src_offset1  =  src_off;
          newnode->src_offset2  =  src_off + nbytes;
          src_off +=  nbytes;
        }

	// If comment exists, it goes in front of our REQPARAM
        if ( comment )
          newnode =  JoinTLists( comment,newnode );
      }
      break;

      case TMPL_ELEMENT_reqELEMENT  : {

// The next MathML element is the required element.  It may be a token
//  element (mi,mn,mo), or a structured element.  We need to look ahead.

        U16 max_tokens  =  1;// next token is the param

        U8* pENV  =  tmpl->GetField( TFIELD_env );
        PushContext( pENV,NULL,NULL,NULL,0 );

        U32 nbytes;
        U32 end_off;
        TCI_BOOL exclude_ender =  FALSE;
        TNODE* rlist  =  RunToList( src_off,end_off,max_tokens,
                                      	nbytes,exclude_ender,
                                      		error_flag,FALSE );

        PopContext();

        if ( !error_flag ) {
          newnode =  MakeTNode( 0,0,0,tmpl->GetField(TFIELD_ID) );

          LinkContentsToParent( newnode,rlist,pENV );
          //newnode->contents     =  rlist;
          //if ( rlist )
          //  rlist->sublist_owner  =  newnode;

          newnode->src_offset1  =  src_off;
          newnode->src_offset2  =  src_off + nbytes;
          src_off +=  nbytes;
        }

      }
      break;

      case TMPL_ELEMENT_TVERBATIM : {
//JBMLine( "TMPL_ELEMENT_TVERBATIM\n" );

//\begin{verbatim}<uID5.340.1>!\begin{verbatim}!TVERBATIM(5.340.2,TEXT,F)!\end{verbatim}!
//\verb<uID5.341.1>!\verb!TVERBATIM(5.340.2,TEXT,T)

        newnode =  MakeTNode( 0,0,0,tmpl->GetField(TFIELD_ID) );
        newnode->src_offset1  =  src_off;

        U8* the_ENV =  tmpl->GetField( TFIELD_env );
        if ( the_ENV && !strcmp((char*)the_ENV,"INHERIT") )
          the_ENV   =  context;

	// We distinguish between the 2 type of LaTeX verbatims

		U16 dummy;
        U8* LaTeX_verb_flag =  tmpl->GetField( TFIELD_condition,dummy );

        U16 old_input_mode  =  tokizer->SetInputMode( IM_VERBATIM );

        if ( *LaTeX_verb_flag=='T' ) {			// \verb|\def|
          U8* ztmpl;              // a dummy
          TNODE* verb_data =  tokizer->GetTNODE( the_ENV,src_off,&ztmpl );
          if ( verb_data ) {
 	        U16 uobjtype,usubtype,uID;
 	        GetUids( verb_data->zuID,uobjtype,usubtype,uID );
            if ( uobjtype==555 ) {
			  char* p =  (char*)verb_data->cv_list->cvline;
              char end_byte  =  *p;
			  p++;
			  char* p1  =  strchr( p,end_byte );
			  if ( p1 ) {		// we've found the end of \verb|hgfhgf|
				U16 vln =  p1 - p;
                newnode->src_offset1  =  verb_data->src_offset1;
                newnode->src_offset2  =  newnode->src_offset1 + vln + 2;
				src_off +=  newnode->src_offset2;
                char* tmp =  TCI_NEW( char[ vln+1 ] );
                strncpy( tmp,p,vln );
                tmp[vln]  =  0;
                newnode->var_value  =  (U8*)tmp;
                newnode->v_len  =  vln;
			  } else
			    TCI_ASSERT(0);
              DisposeTNode( verb_data );
		    } else
		      TCI_ASSERT(0);
		  }	else
		    TCI_ASSERT(0);

		} else {		// \begin{verbatim}

          TCI_BOOL done   =  FALSE;
          while ( !done ) {			// loop thru lines in this verbatim
            U32 save_off  =  src_off;

            U8* ztmpl;              // a dummy
            TNODE* verb_data =  tokizer->GetTNODE( the_ENV,src_off,&ztmpl );
            if ( verb_data ) {
/*
char zzz[512];
sprintf( zzz,"Verb data, zuID=%s, cv line=%s\n",
verb_data->zuID,verb_data->cv_list->cvline );
JBMLine( zzz );
U16 uobjtype,usubtype,uID;
GetUids( verb_data->zuID,uobjtype,usubtype,uID );
TCI_ASSERT( uobjtype==555 );
*/
              TCI_BOOL got_data =  FALSE;
              U8* zline =  verb_data->cv_list->cvline;
			  if ( zline ) {
			    char* endp  =  strstr( (char*)zline,"\\end" );
				TCI_BOOL verbatim_done  =  FALSE;
				if ( endp ) {
                  tokizer->SetInputMode( old_input_mode );
				  U32 end_off   =  src_off + ( endp - (char*)zline );
                  U8* ztmpl;              // a dummy
                  TNODE* ender  =  tokizer->GetTNODE( the_ENV,end_off,&ztmpl );
				  if ( !strcmp((char*)ender->src_tok,"\\end{verbatim}") ) {
				    verbatim_done  =  TRUE;
				    U16 fln =  endp - (char*)zline;
				    if ( fln > 0 ) {			// data infront of \end{verbatim}?
				      *endp =  0;
                      got_data  =  TRUE;
				    }
				    done  =  TRUE;
			        src_off +=  ender->src_offset1 + fln;
                  } else {
                    old_input_mode  =  tokizer->SetInputMode( IM_VERBATIM );
                    got_data =  TRUE;
				  }
                  DisposeTNode( ender );
                }			// if ( endp )

				if ( !verbatim_done ) {
			      U16 zln =  strlen( (char*)zline );
				  if ( zln && zline[zln-1] == '\n' )
				    zline[zln-1]  =  0;
			      src_off +=  verb_data->src_offset2;
                  got_data  =  TRUE;
				}

			  } else				// no cvline on our 555 TNODE
			    TCI_ASSERT(0);

              if ( got_data ) {
                newnode->cv_list  =  JoinCVLists( newnode->cv_list,
              										verb_data->cv_list );
                verb_data->cv_list  =  NULL;
			  }
              DisposeTNode( verb_data );

            } else {			// no more tokens!
              error_flag  =  9999;
              break;
            }

          }       // while loop thru lines in verbatim

        }	// if verbatim

        tokizer->SetInputMode( old_input_mode );
      }
      break;

      case TMPL_ELEMENT_NONTEXBUCKET : {

        TNODE* comment  =  tokizer->GetComments();

        U8* nest_toks =  tmpl->MakeTokenList( TFIELD_list_cont );
        U8* end_toks  =  tmpl->MakeTokenList( TFIELD_stopper );
		TCI_BOOL include_endtok =  FALSE;
        newnode =  DoNonTeXBucket( tmpl,context,nest_toks,end_toks,
								include_endtok,src_off,error_flag );

	// If comment exists, it goes in front of our NONLATEX BUCKET
        if ( comment )
          newnode =  JoinTLists( comment,newnode );

        comment  =  tokizer->GetComments();
		if ( comment )
		  newnode =  JoinTLists( newnode,comment );
      }
      break;

      case TMPL_ELEMENT_LIST      : {

      // make a node for the LIST object

        newnode =  MakeTNode( 0,0,0,tmpl->GetField(TFIELD_ID) );

  // we generate a list of items

        U32 nbytes;
        TNODE* tl =  ProcessTemplateList( tmpl,src_off,nbytes,error_flag );
        newnode->parts =  tl;
        if ( tl )
          tl->sublist_owner =  newnode;

        newnode->src_offset1  =  src_off;
        newnode->src_offset2  =  src_off + nbytes;

        src_off +=  nbytes;
      }
      break;

      case TMPL_ELEMENT_VARIABLE  : {

//  A VAR is a container for a value from some space
//    VAR(0.0.0,MATH,a,\alpha,}|,)

    // make a node for the variable object - we put the value
	//  of the variable in the var_value field

        newnode =  MakeTNode( 0,0,0,tmpl->GetField(TFIELD_ID) );

    // set context in which to tokenize the VAR's value

        U8* pENV  =  tmpl->GetField( TFIELD_env );
        if ( *pENV == 0 ) pENV  =  context;

        if ( pENV && !strcmp((char*)pENV,"INHERIT") )
          pENV  =  context;
        TOKEN_INFO* enders_list =  NULL;
        U8* end_toks  =  tmpl->MakeTokenList( TFIELD_stopper );
        if ( end_toks ) {
          enders_list =  MakeTokenList( end_toks,pENV );
          delete end_toks;
        }

      // get the type of this VAR - "a" or "n" so far
  
        U16 v_type_len;
        U8* v_type_ptr  =  tmpl->GetField( TFIELD_var_type,v_type_len );

      // read the token(s) that specify its value

        if ( pENV )
          PushContext( pENV,NULL,NULL,NULL,0 );

        I16 t_count =  0;
        while ( t_count != -1 ) {
          U32 save_off  =  src_off;
          U8* ztmpl;              // a dummy
          TNODE* nt =  tokizer->GetTNODE( pENV,src_off,&ztmpl );
          if ( nt ) {
            U16 t_len =  nt->src_offset2 - nt->src_offset1;
            src_off   +=  nt->src_offset1;
            if ( t_count == 0 )
              newnode->src_offset1  =  src_off;

            if ( IsTokenInList(nt->zuID,enders_list) ) {
              newnode->src_offset2  =  save_off;
              if ( newnode->src_offset1 > newnode->src_offset2 )
                newnode->src_offset2  =  newnode->src_offset1;
              t_count =  -1;

            } else if ( *v_type_ptr == 'a' ) {    // atomic object
              newnode->src_offset2    =  save_off;
              if ( newnode->src_offset1 > newnode->src_offset2 )
                newnode->src_offset2  =  newnode->src_offset1;
              t_count   =  -1;

              U16 zln   =  strlen( (char*)nt->zuID );
              char* tmp =  TCI_NEW( char[ zln+1 ] );
              strcpy( tmp,(char*)nt->zuID );
              newnode->var_value  =  (U8*)tmp;
              newnode->v_len  =  zln;
              src_off +=  t_len;
              if ( ztmpl && *ztmpl ) {
                U16 tmpl_len  =  strlen( (char*)ztmpl );
                U32 nbytes;
                TNODE* c_tree =  TemplateToList( ztmpl,tmpl_len,
                                                    src_off,
                                                      nbytes,error_flag );
                if ( !error_flag ) {
                  newnode->parts  =  c_tree;
                  if ( c_tree )
                    c_tree->sublist_owner =  newnode;
                  newnode->src_offset1  =  src_off;
                  newnode->src_offset2  =  src_off + nbytes;
                  src_off +=  nbytes;
                }
			  }			// if ( ztmpl && *ztmpl )

            } else {      // add this token to the value of this VAR
/*
char zzz[80];
sprintf( zzz,"n VAR, ID=%s, token=%s, tln=%d\n",nt->zuID,nt->src_tok,t_len );
JBMLine( zzz );
*/
              t_count++;
              src_off +=  t_len;
            }
            DisposeTNode( nt );

          } else {				// GetTNode() failed
            error_flag  =  9999;
            break;
          }

        }       // while loop thru tokens that specify VAR value

//JBMLine( "Out of VAR loop\n" );

        if ( pENV )
          PopContext();

        if ( enders_list ) {
          ClearTokenList( enders_list );
          enders_list =  NULL;
		}

      // It remains to record the value of this variable in "newnode"

        if ( !error_flag ) {
          if        ( *v_type_ptr == 'a' ) {
            newnode->v_type =  'a';
            // newnode was filled out above
          } else if ( *v_type_ptr == 'n' ) {
            U8* src   =  tokizer->GetSrcPtr( newnode->src_offset1 );
            U16 zln   =  newnode->src_offset2 - newnode->src_offset1;
            char* tmp =  TCI_NEW( char[ zln+1 ] );
            strncpy( tmp,(char*)src,zln );
            tmp[ zln ]  =  0;
            newnode->var_value  =  (U8*)tmp;
            newnode->v_len  =  zln;
            newnode->v_type =  'n';
          } else {
            TCI_ASSERT(0);
          }

        }		// if ( !error_flag )

      }		// case TMPL_ELEMENT_VARIABLE  :
      break;

      default :
        TCI_ASSERT( 0 );
      break;

    }           // switch on template atom type



    if ( error_flag ) {
      if ( newnode )
        DisposeTList( newnode );
      if ( head ) {
        DisposeTList( head );
        head  =  (TNODE*)NULL;
      }
      break;  

    } else if ( newnode ) {     // if last atom generated node, add to list
      if ( !head )
        head  =  newnode;
      else {
        tail->next  =  newnode;
        newnode->prev =  tail;
      }  
      tail  =  newnode;
      while ( tail->next ) tail =  tail->next;
    }

  }     // while loop thru template elements

  bytesdone  =  src_off - beg_off;

  delete tmpl;

  return head;
}



LIST_INFO* TeXParser::MakeListInfo( U8* ztemplate,
                                        U16 tmpl_off,U16 TMPL_ELEMENT_len ) {

  LIST_INFO* rv =  (LIST_INFO*)TCI_NEW( char[ sizeof(LIST_INFO) ] );
    rv->count     =  0;
    rv->s_off     =  tmpl_off;
    rv->e_off     =  tmpl_off + TMPL_ELEMENT_len;
/*
    rv->c_lit     =  ;          //char* 
    rv->c_lit_ln  =  ;          //U16   
    rv->e_lit     =  ;          //char* 
    rv->e_lit_ln  =  ;          //U16   
*/

  return rv;
}


/*
  opt_list = ?!blah!TEMPLATE|!second!TEMPLATE|?
             ^               ^                 ^
                           rover
  returns -1 if there are no more options in the list

  Each option starts with a literal or is empty
*/

I16 TeXParser::LocateOption( U8* opt_list,U16 opt_list_len,
                                        U8* rover,I16& option_len ) {

  I16 rv;
  option_len  =  0;

  U8* end_ptr =  opt_list + opt_list_len;

  if ( rover >= end_ptr ) {
    rv  =  -1;                          // end of list

  } else if ( *rover == '|' || *rover == '?' ) {
    rv  =  0;                           // empty option

  } else {

    TCI_ASSERT( *rover =='!' );

char end_char =  *opt_list;

    char stop_chars[4];
    stop_chars[0] =  end_char;
    strcpy( stop_chars+1,"|\\" );

    U8* ptr   =  rover;
    do {
      U16 off =  strcspn( (char*)ptr,stop_chars );
      ptr +=  off;


      if      ( *ptr == '\\' )
        ptr   +=  2;
      else if ( *ptr == '|' || *ptr == end_char ) {
        rv =  ptr - rover;
        break;
      } else {
        TCI_ASSERT( 0 );
        break;
      }
  
    } while ( ptr < end_ptr );

  }

  return rv;
}



void TeXParser::SyntaxError() {

}


/* In this implementation, a "context" or "environment" is just a zname
  that is known to the s_grammar.  In general it should be a struct
  or an object.  "Contexts" can have many attributes, including stores
  of definitions that apply only in that instance of the context.

  if start_toks or end_toks are non-NULL, they are catenations of zstrings,
    ie. "&0\\0\endmatrix00".  The caller allocates heap space for these
    items, and gives them to the stack, which deletes them at PopContext.
*/

void TeXParser::PushContext( U8* new_env,U8* start_toks,
							U8* end_toks,U8* error_stops,
							  U16 inputmode ) {

  if ( context_sp < CONTEXT_STACK_LIM ) {
    strcpy( (char*)context_stack[context_sp].c_name,(char*)new_env );
    context_stack[context_sp].c_start_token =  start_toks;
    context_stack[context_sp].c_end_token   =  end_toks;
    context_stack[context_sp].c_error_stops =  error_stops;

    U16 new_input_mode  =  IM_STANDARD;
    if ( new_env  ) {
      if ( inputmode )
        new_input_mode  =  inputmode;
      else if ( !strcmp((char*)new_env,"DIMEN") )
        new_input_mode  =  IM_TEXDIMEN;
      else if ( !strcmp((char*)new_env,"GLUE") )
        new_input_mode  =  IM_TEXGLUE;
      else if ( !strcmp((char*)new_env,"SPECFIELDS") )
        new_input_mode  =  IM_SPECIAL;
      else if ( !strcmp((char*)new_env,"SPECSTR") )
        new_input_mode  =  IM_SPECSTR;
      else if ( !strcmp((char*)new_env,"BOOLEAN") )
        new_input_mode  =  IM_BOOLEAN;
      else if ( !strcmp((char*)new_env,"NUMBER") )
        new_input_mode  =  IM_NUMBER;
      else if ( !strcmp((char*)new_env,"LBRACE") )
        new_input_mode  =  IM_LBRACE;
      else if ( !strcmp((char*)new_env,"DFLOAT") )
        new_input_mode  =  IM_DFLOAT;
      else if ( !strcmp((char*)new_env,"NONLATEX") )
        new_input_mode  =  IM_NONLATEX;
      else if ( !strcmp((char*)new_env,"HYPHENATION") )
        new_input_mode  =  IM_HYPHENATION;
      else if ( !strcmp((char*)new_env,"PASSTHRU") )
        new_input_mode  =  IM_PASSTHRU;
	}
    tokizer->SetInputMode( new_input_mode );
    context_stack[context_sp].inputmode =  new_input_mode;

    context_sp++;
/*
char zzz[128];
sprintf( zzz,"TeXParser::PushContext, %s, %s, %s, %d\n",
				new_env,start_toks,end_toks,new_input_mode );
JBMLine( zzz );
*/
  } else
    TCI_ASSERT( 0 );
}


void TeXParser::PopContext() {

  if ( context_sp > 0 ) {
    context_sp--;

    if ( context_sp > 0 )
      tokizer->SetInputMode( context_stack[context_sp-1].inputmode );
	else
      tokizer->SetInputMode( IM_STANDARD );

    if ( context_stack[context_sp].c_start_token )
      delete context_stack[context_sp].c_start_token;
    if ( context_stack[context_sp].c_end_token )
      delete context_stack[context_sp].c_end_token;
    if ( context_stack[context_sp].c_error_stops )
      delete context_stack[context_sp].c_error_stops;
/*
char zzz[80];
sprintf( zzz,"TeXParser::PopContext, %s\n",context_stack[context_sp].c_name );
JBMLine( zzz );
*/
  } else
    TCI_ASSERT( 0 );
}


// Add newnode to list "head", return the head of the new list.

TNODE* TeXParser::AddToEndOfList( TNODE* head,TNODE* newnode ) {

  if ( !head )
    return newnode;
  else {
    TNODE* rover  =  head;
    while ( rover && rover->next )  rover =  rover->next;
    rover->next   =  newnode;
	if ( newnode )
      newnode->prev =  rover;
    return head;
  }
}


// TemplateToList() has encountered a literal token in the template.
//  This function matches this literal against the src stream.
//  Format of a template literal = "!blah|whatever|!"

TCI_BOOL TeXParser::ProcessTemplateLiteral( U8* lit_ptr,U16 lit_len,
                                            TNODE* tnode,U8* zcurr_env ) {
/*
char vvv[80];
char zzz[128];
strncpy( (char*)vvv,(char*)lit_ptr,lit_len );
vvv[ lit_len ]  =  0;
sprintf( zzz,"PTL, template literal=%s\n",vvv );
JBMLine( zzz );

//U8* src =  tokizer->GetSrcPtr( src_off );
//strncpy( (char*)vvv,(char*)src,src_tok_len );
//vvv[ src_tok_len ]  =  0;
//sprintf( zzz,"  next src token=%s\n",vvv );
//JBMLine( zzz );
*/

  U8* zuID  =  tnode->zuID;

  TCI_BOOL rv  =  FALSE;

  I16 opt_len;
  U8* opt_ptr       =  lit_ptr + 1;     // step over '!'
  TCI_BOOL emptyOK  =  FALSE;

  do {                    // loop thru options in this literal

    opt_len =  s_grammar->GetLitOptionLen( lit_ptr,lit_len,opt_ptr );
/*
char zzz[80];
sprintf( zzz,"  literal option len=%d,%s,%s\n",opt_len,lit_ptr,opt_ptr );
JBMLine( zzz );
*/
    if ( opt_len == -1 ) {        // end of template
      if ( emptyOK )
        rv  =  TRUE;
      break;

    } else if ( TokenMatchesuID(opt_ptr,opt_len,tnode,zcurr_env) ) {
/*
char zzz[80];
sprintf( zzz,"TEMPLATE literal matched, ln=%d\n",lit_len );
JBMLine( zzz );
*/
      rv  =  TRUE;
      break;
    } else {                    // try the next option
      if ( opt_len == 0 )       // there is a EMPTY option
        emptyOK   =  TRUE;
      opt_ptr +=  opt_len+1;        // stay in loop - advance ptr
    }

  } while ( TRUE );       // loop thru literal options

  return rv;
}


// We're parsing src into a template - next template element is LIST.
//  LIST(5.30.1,_ENTRYTEMPLATE_,counter_ID,start,end,continue)

TNODE* TeXParser::ProcessTemplateList( TmplIterater* tmpl,
										U32 start_off,
											U32& bytesdone,
												U16& error_flag ) {
//JBMLine( "ProcessTemplateList\n" );

  TNODE* head =  (TNODE*)NULL;
  TNODE* tail;
  TNODE* newnode;
  U8* pENV  =  ( context_sp > 0 ) ? context_stack[ context_sp-1 ].c_name
  								  : (U8*)NULL;

// Set up variables for the continuation test

  U16 cont_field    =  TFIELD_list_cont;

  TCI_BOOL is_hline =  FALSE;
  TCI_BOOL list_items_have_start =  FALSE;
  U16 cont_len;
  U8* cont_ptr  =  tmpl->GetField( TFIELD_start,cont_len );
  if ( cont_len ) {
    list_items_have_start =  TRUE;
    cont_field  =  TFIELD_start;

    // hline is a special list

    U16 dummy_len;
    U8* dummy_ptr =  tmpl->GetField( TFIELD_list_cont,dummy_len );
    if ( dummy_len )
	  if ( !strncmp((char*)dummy_ptr,"hline",5) )
        is_hline =  TRUE;
  }

  TOKEN_INFO* cont_list =  NULL;
  U8* cont_toks =  tmpl->MakeTokenList( cont_field );
  if ( cont_toks ) {
    cont_list   =  MakeTokenList( cont_toks,pENV );
    delete cont_toks;
  } else {
/*
    TCI_ASSERT( 0 );
This is not an error condition!
A list can have no start token for each entry, and no continuation token.
_SITEMS_LIST(5.204.9,_SITEM_,5.204.10,,\end{StrategyBoxList},)
*/
  }

  TOKEN_INFO* enders_list =  NULL;
  U8* end_toks  =  tmpl->MakeTokenList( TFIELD_list_end );
  if ( end_toks ) {
    enders_list =  MakeTokenList( end_toks,pENV );
    delete end_toks;
  }

  U8  key_zuID[48];
  U16 item_counter  =  0;   // 5.30.1:0

  U32 src_off =   start_off;
  while ( TRUE ) {    		// loop thru items in the list
//JBMLine( "TOP of list item loop\n" );
  // if there is no starting or continuation token, check for ender

    if ( !cont_list ) {
//JBMLine( "  Pre-testing current token against list ender\n" );
      U8* context =  ( context_sp > 0 ) ? context_stack[ context_sp-1 ].c_name
      									: (U8*)NULL;  
      U8* ztemplate;
      TNODE* nt   =  tokizer->GetTNODE( context,src_off,&ztemplate );
      src_off   +=  nt->src_offset1;
//JBMLine( (char*)nt->src_tok );

      if ( IsTokenInList(nt->zuID,enders_list) ) {
//JBMLine( "\n  FOUND LIST ENDING TOKEN\n" );
        DisposeTNode( nt );
        break;
      } else {
//JBMLine( "\n  NOT LIST ENDING TOKEN\n" );
        DisposeTNode( nt );
      }
    }

  // Make a node for the list element

    newnode =  MakeTNode( 0,0,0,tmpl->GetField(TFIELD_ID) );
    U16 zid_ln  =  strlen( (char*)newnode->zuID );
    newnode->zuID[ zid_ln++ ] =  ':';

    // jcs -- itoa is not a standard function:   itoa( item_counter,(char*)newnode->zuID+zid_ln,10 );
    sprintf((char*)newnode->zuID+zid_ln, "%d", item_counter);
    item_counter++;

  // if there is a starting token for the first item, read it off

    if ( item_counter==1 && list_items_have_start && !is_hline ) {

      U8* context =  ( context_sp > 0 ) ? context_stack[ context_sp-1 ].c_name
      									: (U8*)NULL;  
      U8* ztemplate;
      TNODE* nt   =  tokizer->GetTNODE( context,src_off,&ztemplate );
      src_off   +=  nt->src_offset1;

      if ( IsTokenInList(nt->zuID,cont_list) ) {
//JBMLine( "FOUND LIST STARTING TOKEN\n" );
        src_off +=  nt->src_offset2 - nt->src_offset1;
        DisposeTNode( nt );
      } else {
        DisposeTNode( nt );
        break;
      }
    }

  // Process the list item using the template provided by the LIST

    U16 znest_len;
    U8* znest_template  =  tmpl->GetField( TFIELD_nest,znest_len );
    U32 nbytes;
    TNODE* plist  =  TemplateToList( znest_template,znest_len,
                                                src_off,nbytes,error_flag );
/*
char zzz[80];
sprintf( zzz,"LIST calls TemplateToList, bytes done=%d\n",nbytes );
JBMLine( zzz );
*/
    if ( error_flag ) {
      DisposeTList( newnode );
      break;  
    }
    newnode->parts  =  plist;
    if ( plist )
      plist->sublist_owner  =  newnode;
    newnode->src_offset1  =  src_off;
    newnode->src_offset2  =  src_off + nbytes;
    src_off +=  nbytes;

  // add newnode to the list of list entries that we are building

    if ( !head )
      head =  newnode;
    else {
      tail->next  =  newnode;
      newnode->prev =  tail;
    }
    tail  =  newnode;

  // Decide whether or not to stay in the loop thru list items.
  //  Examine the next token - it decides looping

    U8* context =  ( context_sp > 0 ) ? context_stack[ context_sp-1 ].c_name
    								  : (U8*)NULL;  
    U8* ztemplate;

    U16 key_len;
    TCI_BOOL is_bsbs  =  FALSE;
    TCI_BOOL done  =  FALSE;
    while ( !done ) {
      TNODE* nt =  tokizer->GetTNODE( context,src_off,&ztemplate );
      if ( !strcmp((char*)nt->zuID,"9.1.1") ) {
        src_off +=  nt->src_offset2;
      } else {

		if ( !strcmp((char*)nt->zuID,"888.") ) {
		  TCI_ASSERT(0);
		  U8* uID;
          U8* tmpl;
          if ( tokizer->GGDFromNameAndAttrs(nt->var_value,1,
       								NULL,(U8*)"TEXT",&uID,&tmpl) ) {
/*
JBMLine( "LIST control token was a TEXT word, changed to \n" );
JBMLine( (char*)uID );
JBMLine( "\n" );
*/
            nt->src_offset2 =  nt->src_offset1 + 1;
            strcpy( (char*)nt->zuID,(char*)uID );
		  } else
			TCI_ASSERT(0);		  

		}
        key_len =  nt->src_offset2 - nt->src_offset1;
        src_off +=  nt->src_offset1;
        strcpy( (char*)key_zuID,(char*)nt->zuID );
		if ( nt->src_tok[0]=='\\' && nt->src_tok[1]=='\\' )
          is_bsbs  =  TRUE;
        done  =  TRUE;
      }
/*
char zzz[80];
sprintf( zzz,"LIST: key_zuID=%s, key=%s\n",key_zuID,nt->src_tok );
JBMLine( zzz );
*/
      DisposeTNode( nt );
    }

  // Are we at the list ending token?

    if ( IsTokenInList(key_zuID,enders_list) ) {
/*
char zzz[80];
sprintf( zzz,"ENDING LIST, %s\n",key_zuID );
JBMLine( zzz );
*/
      break;
    }

    if ( IsTokenInList(key_zuID,cont_list) ) {
//JBMLine( "FOUND LIST CONTINUATION TOKEN\n" );
      if ( !is_hline ) {

        if ( is_bsbs ) {		// continuation token has a production
          TNODE* c_tok  =  tokizer->GetTNODE( context,src_off,&ztemplate );
/*
char zzz[128];
sprintf( zzz,"Continuation token, %s, has production\n",c_tok->src_tok );
JBMLine( zzz );
*/
          U16 tmpl_len  =  strlen( (char*)ztemplate );
          if ( tmpl_len ) {
            U32 nbytes;
            TNODE* tplist =  TemplateToList( ztemplate,tmpl_len,
                                              src_off,nbytes,error_flag );
            if ( !error_flag && tplist ) {
              c_tok->parts  =  tplist;
              if ( tplist ) {
/*
char zzz[128];
sprintf( zzz,"Continuation token, %s, has non-empty production\n",c_tok->src_tok );
JBMLine( zzz );
*/
                tplist->sublist_owner =  c_tok;
		      }
              c_tok->src_offset2  =  c_tok->src_offset1 + nbytes;

              src_off +=  nbytes;

		  // add c_tok to end of newnode->parts

              if ( newnode->parts ) {
			    TNODE* tr =  newnode->parts;
			    while ( tr->next ) tr =  tr->next;
			    tr->next  =  c_tok;
			    if ( c_tok ) c_tok->prev  =  tr;
			  } else {
                newnode->parts  =  c_tok;
				c_tok->sublist_owner  =  newnode;
			  }

            } else {		// error_flag is up
              DisposeTNode( c_tok );
              src_off +=  key_len;
			}

          } else {				// tmpl_len is 0
		    TCI_ASSERT(0);
            DisposeTNode( c_tok );
            src_off +=  key_len;
		  }

		} else			// continuation token is NOT \\*[]
          src_off +=  key_len;

	  }			// if ( !is_hline )

    } else {	// nt is NOT in continuation list

      if ( !enders_list )
        break;
      else {
        if ( cont_list ) {
/*
char zzz[80];
sprintf( zzz,"MISSING LIST CONTINUATION TOKEN, found %s\n",key_zuID );
JBMLine( zzz );
*/
          TCI_ASSERT( 0 );
        }
      }

    }		// is_hline clause

  }     // loop thru list items


  if ( error_flag ) {
    if ( head ) {
      DisposeTList( head );
      head  =  (TNODE*)NULL;
    }
  }

  bytesdone =  src_off - start_off;

  if ( cont_list )    ClearTokenList( cont_list );
  if ( enders_list )  ClearTokenList( enders_list );
/*
char xxx[80];
sprintf( xxx,"LIST returns, nbytes=%d\n",bytesdone );
JBMLine( xxx );
*/
  return head;
}



// "Parse" a chunk from a file into it's grammatical elements.
//   Push a context, call RunToList, then pop the context
//   Returns a list of "TNODE"s - recursive parser tree of objects found.

TNODE* TeXParser::ParseBatch( U32& start_off,U16& result ) {
//JBMLine( "TeXParser::ParseBatch\n" );

/*
U8* src_ptr =  tokizer->GetSrcPtr( start_off );
if ( src_ptr ) {
  char zzz[96];
  char src_str[60];
  U16 i =  0;
  while ( src_ptr[i] && i<59 ) {
    src_str[i]  =  src_ptr[i];
    i++;
  }
  src_str[i]  =  0;
  sprintf( zzz,"TeXParser::ParseBatch src=!%s!\n",src_str );
  JBMLine( zzz );
}
*/

  TNODE* head =  (TNODE*)NULL;

  //if ( start_off == 0 && context_sp == 0 ) {
  if ( context_sp == 0 ) {
    U8 curr_context[ CONTEXT_NOM_LIM ];
    s_grammar->GetDefaultContext( curr_context );
    if ( curr_context[0] ) {          // this s_grammar has a default context
      PushContext( curr_context,(U8*)NULL,(U8*)NULL,NULL,0 );
      //head  =  s_grammar->GetContextNode( curr_context,TRUE );
    }
  } else {
  //TCI_ASSERT(0);
  }

// The following call to RunToList can quit before the source file
//  is exhausted. It contains logic to pick a reasonable batch
//  for ongoing processing.

  TCI_BOOL exclude_ender =  FALSE;
  U32 bytesdone;
  U32 end_off;
  U16 error_flag;
  TNODE* tlist  =  RunToList( start_off,end_off,0,
                        bytesdone,exclude_ender,error_flag,TRUE );

  if ( error_flag ) {
    result  =  PR_ERROR;
/*
char zzz[80];
sprintf( zzz,"TeXParser::RunToList ERROR=%d\n",error_flag );
JBMLine( zzz );
*/
    if ( head ) {
      DisposeTList( head );
      head  =  (TNODE*)NULL;
    }

  } else {		// no error

//JBMLine( "ParseBatch::RunToList OK\n" );

    if ( tlist ) {
      result  =  PR_INCOMPLETE;
      head    =  AddToEndOfList( head,tlist );
    } else {

  // There may be a comment at the end of the file

      TNODE* comment  =  tokizer->GetComments();
	  if ( comment )
        head  =  AddToEndOfList( head,comment );

      result  =  PR_COMPLETE;
      U8 curr_context[ CONTEXT_NOM_LIM ];
      s_grammar->GetDefaultContext( curr_context );
      if ( curr_context[0] ) {          // exit the starting context
        PopContext();
        //TNODE* enode  =  s_grammar->GetContextNode( curr_context,FALSE );
        //head  =  AddToEndOfList( head,enode );
      }
    }		// clause for NULL return from RunToList
  }		// no error clause

  start_off =  end_off;

//JBMLine( "ParseBatch returns\n" );
  return head;
}


U8* TeXParser::GetSrcPtr( U32 offset ) {

  return tokizer->GetSrcPtr( offset );
}



TCI_BOOL TeXParser::TokenMatchesuID( U8* optr,U16 oln,
									TNODE* tnode,U8* zcurr_env ) {
/*
char zzz[80];
sprintf( zzz,"oln=%d, zuID=%s, zcurr_env=%s\n",oln,tnode->zuID,zcurr_env );
JBMLine( zzz );
*/

  TCI_BOOL rv  =  FALSE;

  if ( !strncmp((char*)tnode->zuID,"888.",4) ) {
    TCI_ASSERT(0);
    if ( !strncmp((char*)tnode->var_value,(char*)optr,oln) )
      rv  =  TRUE;
  } else {
    U8* uID;
    U8* tmpl;
    if ( tokizer->GGDFromNameAndAttrs( optr,oln,NULL,zcurr_env,&uID,&tmpl) ) {
//JBMLine( "  Lookup OK\n" );
//JBMLine( (char*)uID );
//JBMLine( "\n" );
      if ( !strcmp((char*)tnode->zuID,(char*)uID) )
        rv  =  TRUE;
    } else {
//JBMLine( "  Lookup FAILED\n" );
    }

  }

  return rv;
}


// "tokens" is a list of token names
//    "&0\\0\end{array}00"

TOKEN_INFO* TeXParser::MakeTokenList( U8* tokens,U8* zcurr_env ) {

  TOKEN_INFO* head  =  NULL;
  TOKEN_INFO* tail;

  char* ptr =  (char*)tokens;
  while ( *ptr ) {

    TOKEN_INFO* tmp =  (TOKEN_INFO*)TCI_NEW( char[ sizeof(TOKEN_INFO) ] );
    tmp->next =  NULL;

    U16 tln   =  strlen(ptr);
    tmp->ztoken =  (U8*)TCI_NEW( char[ tln+1 ] );
    strcpy( (char*)tmp->ztoken,ptr );

    U8* zuID;
    U8* ztemplate;
    if ( tokizer->GGDFromNameAndAttrs( (U8*)ptr,tln,NULL,zcurr_env,
                                                &zuID,&ztemplate ) ) {
      U16 zln     =  strlen( (char*)zuID );
      tmp->ztuID  =  (U8*)TCI_NEW( char[ zln+1 ] );
      strcpy( (char*)tmp->ztuID,(char*)zuID );
/*
char zzz[128];
sprintf( zzz,"MakeTokenList OK, token=%s, ID=%s, env=%s\n",ptr,zuID,zcurr_env );
JBMLine( zzz );
*/
    } else {
/*
JBMLine( "MakeTokenList FAILS\n" );
JBMLine( (char*)ptr );
JBMLine( (char*)zcurr_env );
JBMLine( "\n" );
*/
TCI_ASSERT( 0 );
      tmp->ztuID =  NULL;
    }

    if ( !head )  head  =  tmp;
    else          tail->next  =  tmp;
    tail  =  tmp;

    ptr +=  strlen(ptr) + 1;
  }

  return head;
}


void TeXParser::ClearTokenList( TOKEN_INFO* list ) {

  while ( list ) {
    TOKEN_INFO* del =  list;
    list  =  list->next;
    if ( del->ztoken) delete del->ztoken;
    if ( del->ztuID)  delete del->ztuID;
    delete del;
  }
}


TCI_BOOL TeXParser::IsTokenInList( U8* ztok_uID,TOKEN_INFO* list ) {

  TCI_BOOL rv  =  FALSE;

  TOKEN_INFO* rover =  list;
  while ( rover ) {
    if (rover->ztuID && !strcmp((char*)ztok_uID,(char*)rover->ztuID) ) {
      rv  =  TRUE;
      break;
    }
    rover =  rover->next;
  }

  return rv;
}


//  A "REQPARAM" is a special construct used to handle certain LaTeX
//   parameters.  The parameter may be delimited by "{" and "}".
//   If not delimited, it is the next token.  We need to examine
//   the next token to determine which form to parse.

TNODE* TeXParser::DoReqParam( TmplIterater* tmpl,U8* context,
								U32& src_off,U16& error_flag ) {

  TNODE* newnode  =  NULL;

/*
char zzz[80];
sprintf( zzz,"DoReqParam::TMPL_ELEMENT_REQPARAM, src_off=%d\n",src_off );
JBMLine( zzz );
*/

// Here we're getting the context within the required param

  U8* pENV  =  tmpl->GetField( TFIELD_env );
  if ( pENV && !strcmp((char*)pENV,"INHERIT") )
    pENV  =  context;

// Get the next token - looking for "{".  We restrict the context to
//  MATH or TEXT for this call to GetToken.

  U8* theENV  =  (U8*)"TEXT";
  if ( pENV && !strcmp((char*)pENV,"MATH") ) theENV =  pENV;

  U16 max_tokens;
  U8* tok_ztmpl;            // a dummy
  TNODE* nt;
  PushContext( theENV,NULL,NULL,NULL,0 );
  do {
    nt =  tokizer->GetTNODE( theENV,src_off,&tok_ztmpl );
    if ( nt ) {
      if ( strcmp((char*)nt->zuID,"9.1.1") )
        break;
      else {
        src_off +=  nt->src_offset2;
        DisposeTNode( nt );
        nt  =  (TNODE*)NULL;
      }
    } else
      break;
  } while (TRUE);
  PopContext();

  TNODE* comment  =  tokizer->GetComments();

  if ( nt ) {
      // Bug fix - step over white space in front of param
    src_off +=  nt->src_offset1;

    if ( !strcmp((char*)nt->zuID,"9.1.10") ) {    // "{}"
/*
char zzz[80];
sprintf( zzz,"TMPL_ELEMENT_REQPARAM, found {}, src_off=%d\n",src_off );
JBMLine( zzz );
*/
      newnode =  MakeTNode( 0,0,0,tmpl->GetField(TFIELD_ID) );
      newnode->src_offset1  =  src_off;
      src_off +=  2;
      newnode->src_offset2  =  src_off;
      DisposeTNode( nt );

      LinkContentsToParent( newnode,NULL,pENV );

    } else {

      if ( strcmp((char*)nt->zuID,"6.1.0") )  // missing "{"
        max_tokens  =  1;
      else
        max_tokens  =  0;					  // invalid - unlimited

      if ( pENV && !strcmp((char*)pENV,"NONLATEX") ) {

        if ( max_tokens==1 && tok_ztmpl )
          TCI_ASSERT( 0 );

        if ( max_tokens == 1 ) {
          newnode =  MakeTNode( 0,0,0,tmpl->GetField(TFIELD_ID) );
          TNODE* cont =  MakeTNode( 0,0,0,(U8*)"888.8.0" );

          LinkContentsToParent( newnode,cont,pENV );
          //newnode->contents   =  cont;
          //cont->sublist_owner =  newnode;

// The token "nt" is a TEXT token - it may span words and spaces.
// We need to truncate at the first space to get the value of "cont".

		  U16 t_len   =  0;
          char* t_ptr =  (char*)nt->var_value;
		  if ( t_ptr ) {
		    while ( *t_ptr ) {
		      if ( *t_ptr == ' ' && t_len ) {
			    *t_ptr  =  0;
		        break;
		      }
			  t_len++;
			  t_ptr++;
		    }
		  } else
		    TCI_ASSERT(0);

          cont->var_value  =  nt->var_value;
          nt->var_value    =  NULL;
          cont->v_len =  t_len;
          newnode->src_offset1  =  src_off;
          src_off     +=  t_len;
          newnode->src_offset2  =  src_off;
/*
char zzz[256];
sprintf( zzz,"NONLATEX token = %s\n",cont->var_value );
JBMLine( zzz );
*/
          DisposeTNode( nt );

		} else {
          src_off +=  1;
          DisposeTNode( nt );

          TNODE* comment  =  tokizer->GetComments();

          U8* nest_toks =  tmpl->MakeTokenList( (U8*)"{",1 );
          U8* end_toks  =  tmpl->MakeTokenList( (U8*)"}",1 );
		  TCI_BOOL include_endtok =  TRUE;
          newnode =  DoNonTeXBucket( tmpl,pENV,nest_toks,end_toks,
        						include_endtok,src_off,error_flag );

	// If comment exists, it goes in front of our NONLATEX BUCKET
          if ( comment )
            newnode =  JoinTLists( comment,newnode );

          comment  =  tokizer->GetComments();
		  if ( comment )
		    newnode =  JoinTLists( newnode,comment );
		 }

    } else if ( pENV && !strcmp((char*)pENV,"PASSTHRU") ) {
          src_off +=  1;
          DisposeTNode( nt );

          TNODE* comment  =  tokizer->GetComments();

          U8* nest_toks =  tmpl->MakeTokenList( (U8*)"{",1 );
          U8* end_toks  =  tmpl->MakeTokenList( (U8*)"}",1 );
		      TCI_BOOL include_endtok =  TRUE;
          newnode =  DoNonTeXBucket( tmpl,pENV,nest_toks,end_toks,
        						include_endtok,src_off,error_flag );

	  } else {			// here we do a full recursive parse

        DisposeTNode( nt );

        if ( max_tokens ) {
          PushContext( pENV,NULL,NULL,NULL,0 );
        } else {
          U8* st  =  tmpl->MakeTokenList( (U8*)"{",1 );
          U8* et  =  tmpl->MakeTokenList( (U8*)"}",1 );
          PushContext( pENV,st,et,NULL,0 );
        }

        U32 nbytes;
        U32 end_off;
        TCI_BOOL exclude_ender =  FALSE;
        TNODE* rlist =  RunToList( src_off,end_off,max_tokens,
                          nbytes,exclude_ender,error_flag,FALSE );
        PopContext();

        if ( !error_flag ) {
          newnode =  MakeTNode( 0,0,0,tmpl->GetField(TFIELD_ID) );

          LinkContentsToParent( newnode,rlist,pENV );
          //newnode->contents =  rlist;
          //if ( rlist )
          //  rlist->sublist_owner  =  newnode;

          newnode->src_offset1  =  src_off;
          newnode->src_offset2  =  src_off + nbytes;
          src_off +=  nbytes;
        }
      }
    }		// end not "{}" clause

  } else {        // GetToken for look ahead failed!
    error_flag  =  9999;
  }

  // If comment exists, it goes in front of out REQPARAM

  if ( comment )
    newnode =  JoinTLists( comment,newnode );

  return newnode;
}


//  A "OPTPARAM" is a special construct for LaTeX-like grammars.

TNODE* TeXParser::DoOptParam( TmplIterater* tmpl,U8* context,
                                U32& src_off,U16& error_flag ) {
/*
char zzz[80];
sprintf( zzz,"DoOptParam, src_off=%lu, context=%s\n",src_off,context );
JBMLine( zzz );
*/
  TNODE* newnode  =  NULL;

  TCI_BOOL has_option;
  U8* tok_ztmpl;            // a dummy
  TNODE* nt =  tokizer->GetTNODE( context,src_off,&tok_ztmpl );
  if ( nt ) {
    U32 n_lead_whites =  nt->src_offset1;
    if ( !strcmp((char*)nt->zuID,"3.17.94") )
      has_option  =  TRUE;
    else
      has_option  =  FALSE;
    DisposeTNode( nt );

    if ( has_option ) {
	// comments in front of [
      TNODE* comment  =  tokizer->GetComments();

      U8* pENV  =  tmpl->GetField( TFIELD_env );
      if ( pENV && !strcmp((char*)pENV,"INHERIT") )
        pENV  =  context;

      if ( pENV && !strcmp((char*)pENV,"NONLATEX") ) {
        U8* nest_toks =  tmpl->MakeTokenList( (U8*)"[",1 );
        U8* end_toks  =  tmpl->MakeTokenList( (U8*)"]",1 );
        TCI_BOOL include_endtok =  TRUE;
        src_off +=  n_lead_whites + 1;
        newnode =  DoNonTeXBucket( tmpl,pENV,nest_toks,end_toks,
        						include_endtok,src_off,error_flag );
      } else {
        U8* st  =  tmpl->MakeTokenList( (U8*)"[",1 );
        U8* et  =  tmpl->MakeTokenList( (U8*)"]",1 );
        PushContext( pENV,st,et,NULL,0 );

        U32 nbytes;
        U32 end_off;
        src_off +=  n_lead_whites;
        TCI_BOOL exclude_ender =  FALSE;
        TNODE* rlist  =  RunToList( src_off,end_off,0,nbytes,
           					exclude_ender,error_flag,FALSE );
        PopContext();

        if ( !error_flag ) {
          newnode =  MakeTNode( 0,0,0,tmpl->GetField(TFIELD_ID) );

          LinkContentsToParent( newnode,rlist,pENV );
          //newnode->contents     =  rlist;
          //if ( rlist )
          //  rlist->sublist_owner  =  newnode;

          newnode->src_offset1  =  src_off;
          newnode->src_offset2  =  src_off + nbytes;
          src_off +=  nbytes;
        }
      }

	// If comment exists, it goes in front of out OPTPARAM

      if ( comment )
        newnode =  JoinTLists( comment,newnode );

      comment  =  tokizer->GetComments();
      if ( comment ) {
//JBMLine( "Moving comments to end of NONLATEX\n" );
        newnode =  JoinTLists( newnode,comment );
      }

    } else {      // [option] not present

      TNODE* comment  =  tokizer->GetComments();
      DisposeTList( comment );

    }

  } else {        // GetToken for look ahead failed!
    error_flag  =  9999;
  }

//char zzz[80];
//sprintf( zzz,"DoOptParam returns, src_off=%lu\n",src_off );
//JBMLine( zzz );

  return newnode;
}


// The following function is called to parse certain parameters
//  to LaTeX \cmds.  Many cmds, particularly those commonly located
//  in the preamble, have arguments that name files, packages,
//  new environments, new commands, objects, etc.  These arguments
//  may have a syntactic sub-structure but we pass them along as
//  CHDATA.  We are scanning tokens here, looking for the end of
//  a context - we are NOT looking for constructs that change
//  context or require a recursive descent.

TNODE* TeXParser::DoNonTeXBucket( TmplIterater* tmpl,U8* context,
								  U8* nest_toks,U8* end_toks,
								  TCI_BOOL include_endtok,
								  U32& src_off,U16& error_flag ) {
//JBMLine( "TeXParser::DoNonTeXBucket\n" );
/*
char zzz[128];
sprintf( zzz,"DoNonTeXBucket, src_off=%lu, nest_token=%s, end_token=%s\n",
src_off,nest_toks,end_toks );
JBMLine( zzz );
*/
  TNODE* newnode  =  MakeTNode( 0,0,0,tmpl->GetField(TFIELD_ID) );
  newnode->src_offset1  =  src_off;

// Note that if the bucket we're parsing started with "[" or "{",
//  we've already advanced beyond this starting delimiter.

  U8* the_ENV =  tmpl->GetField( TFIELD_env );
  if ( strcmp((char*)the_ENV,"NONLATEX") )
	TCI_ASSERT(0);

  TOKEN_INFO* enders_list =  NULL;
  if ( end_toks ) {
    enders_list =  MakeTokenList( end_toks,the_ENV );
    delete end_toks;
  }	else
    TCI_ASSERT(0);

  TOKEN_INFO* nesters_list  =  NULL;
  if ( nest_toks ) {
    nesters_list  =  MakeTokenList( nest_toks,the_ENV );
    delete nest_toks;
  }

// read the token(s) in this NONTEXBUCKET

  PushContext( the_ENV,NULL,NULL,NULL,0 );

  U16 nest_level  =  0;
  TCI_BOOL done   =  FALSE;
  while ( !done ) {
    U32 save_off  =  src_off;

    U8* ztmpl;              // a dummy
    TNODE* nt =  tokizer->GetTNODE( the_ENV,src_off,&ztmpl );
    if ( nt ) {
      U16 t_len =  nt->src_offset2 - nt->src_offset1;
      src_off   +=  nt->src_offset1;
/*
char zzz[128];
sprintf( zzz,"Got nt, src_off=%lu, tlen=%d, ID=%s\n",src_off,t_len,nt->zuID );
JBMLine( zzz );
*/
      if        ( IsTokenInList(nt->zuID,nesters_list) ) {
//JBMLine( "  hit NONTEXBUCKET nester\n" );
        nest_level++;
        src_off +=  t_len;
      } else if ( IsTokenInList(nt->zuID,enders_list) ) {
        if ( nest_level ) {
//JBMLine( "  hit NONTEXBUCKET unnester\n" );
          nest_level--;
          src_off +=  t_len;
        } else {
//JBMLine( "  hit NONTEXBUCKET ender\n" );
          done  =  TRUE;
		  if ( include_endtok ) {
            newnode->src_offset2    =  src_off;
            src_off +=  t_len;
		  } else {
            newnode->src_offset2    =  save_off;
            if ( newnode->src_offset1 > newnode->src_offset2 )
              newnode->src_offset2  =  newnode->src_offset1;
		  }
        }
      } else {
        src_off +=  t_len;
      }

      DisposeTNode( nt );

    } else {			// no more tokens!
      error_flag  =  9999;
      break;
    }

  }       // while loop thru tokens in NONTEXBUCKET

  PopContext();

  if ( enders_list ) {
    ClearTokenList( enders_list );
    enders_list =  NULL;
  }
  if ( nesters_list ) {
    ClearTokenList( nesters_list );
    nesters_list =  NULL;
  }

  if ( !error_flag ) {
    TNODE* cont =  MakeTNode( 0,0,0,(U8*)"888.8.0" );

    LinkContentsToParent( newnode,cont,the_ENV );
    //newnode->contents   =  cont;
    //cont->sublist_owner =  newnode;

    U16 zln   =  newnode->src_offset2 - newnode->src_offset1;
    char* tmp =  TCI_NEW( char[ zln+1 ] );
    char* verb_ptr  =  (char*)tokizer->GetSrcPtr( newnode->src_offset1 );
    strncpy( tmp,verb_ptr,zln );
    tmp[zln]  =  0;
    U8* fixed = 0;
    if (strcmp((char*)the_ENV, "PASSTHRU")) {
	     fixed =  FixNonLaTeX( (U8*)tmp );
    } else {
       fixed = (U8*)tmp;
    }
    cont->var_value  =  fixed;
    cont->v_len  =  strlen( (char*)fixed );
   
  }

//char zzz[80];
//sprintf( zzz,"DoNonTeXBucket returns, src_off=%lu\n",src_off );
//JBMLine( zzz );

  return newnode;
}


void TeXParser::LinkContentsToParent( TNODE* parent,
											TNODE* contents,
													U8* context ) {

  parent->contents  =  contents;
  if ( contents )
    contents->sublist_owner  =  parent;

  if ( context ) {
    U16 ln  =  strlen( (char*)context );
	U8* uID;
    U8* tmpl;
    if ( tokizer->GGDFromNameAndAttrs(context,ln,
   							NULL,(U8*)"CONTEXTS",&uID,&tmpl) ) {
/*
JBMLine( "CONTEXT id is \n" );
JBMLine( (char*)uID );
JBMLine( "\n" );
*/
      strcpy( (char*)parent->cuID,(char*)uID );
	} else
	  TCI_ASSERT(0);

  } else		// if ( context )
    TCI_ASSERT(0);

}


// LaTeX comments and '\n' can occur in raw "NONLATEX".
// Here we remove comments and translate '\n' to space.

U8* TeXParser::FixNonLaTeX( U8* raw ) {

  U8* rv;

  U8* p =  (U8*)strchr( (char*)raw,'%' );
  if ( !p )
    p =  (U8*)strchr( (char*)raw,'\n' );

  if ( p ) {
    U16 zln =  strlen( (char*)raw );
    rv  =  (U8*)TCI_NEW( char[zln+1] );
	U16 di  =  0;
	U8 ch;
	bool in_comment =  false;

	U8* sptr  =  raw;
	while ( ch = *sptr ) {
	  if ( in_comment ) {
	    if ( ch == '\n' )
		  in_comment  =  false;
	  } else {
	    if      ( ch == '\\' ) {
		  rv[di++]  =  ch;
		  sptr++;
	      if ( ch = *sptr ) rv[di++]  =  ch;
		  else				break;
	    } else if ( ch == '%' ) {
		  in_comment  =  true;
	    } else if ( ch == '\n' ) {
//TCI_ASSERT(0);
		  rv[di++]  =  ' ';
		} else
		  rv[di++]  =  ch;
	  }
	  sptr++;
	}			// while loop thru raw bytes

    rv[di]  =  0;
	delete raw;

  } else
    rv  =  raw;

  return rv;
}


// We call the following function to remove whitespace
//  at the right end of a TEXT run that is the body of a BUCKET
//  whose end token is not part of the BUCKET.
//  \begin{tabular}
//    a & b  \\			- 2 buckets need to be trimmed here!

TNODE* TeXParser::TrimWhite( TNODE* rlist ) {
//JBMLine( "TrimWhite\n" );

  TNODE* rv =  rlist;

  TNODE* rover  =  rlist;
  while ( rover->next )
    rover =  rover->next;

  U16 uobjtype,usubtype,uID;
  GetUids( rover->zuID,uobjtype,usubtype,uID );
  if ( uobjtype==888 && usubtype==0 && uID==0 ) {
    char* p =  (char*)rover->var_value;
	U16 ln  =  strlen( p );
	while ( ln ) {
	  if ( p[ln-1] == ' ' ) {
	    p[ln-1] =  0;
		ln--;
	  } else
	    break;
	}
	p[ln] =  0;
    rover->v_len  =  ln;

  }	else if ( uobjtype==9 && usubtype==1 && uID==1 ) {

    while ( rover ) {
      U16 uobjtype,usubtype,uID;
      GetUids( rover->zuID,uobjtype,usubtype,uID );
      if ( uobjtype==9 && usubtype==1 && uID==1 )
	    rover =  rover->prev;
	  else
	    break;
	}

    if ( rover ) {
      if ( rover->next ) {
	    DisposeTList( rover->next );
	    rover->next =  NULL;
	  }
	} else {		// all node in rlist are 9.1.1's
	  DisposeTList( rlist );
 	  rv  =  NULL;
	}

  }		// clause for ordinary space, 9.1.1

  return rv;
}
