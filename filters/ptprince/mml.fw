
@A@<MML Definition@>

@o@<mml.h@>==@{@-
#ifndef MML_H
#define MML_H
#include <string>
bool SetupMathML();
void TakeDownMathML();
void ProcessMathML(const char* inp, std::string& outp, std::string& anom);
#endif
@}

@o@<mml.cpp@>==@{@-
#include "mml.h"
#include "../mathml/mmllib.h"
//#include <windows.h>
#include <iostream>
#include <cstring>

//#include "mmldll.h"
@<MML Implementation@>
@}

@$@<MML Implementation@>+=@{@-
const int NUM_UPREF_STRS = 20;
const int FIX_IE_BUG = 18;

char *upref_zstrs[] = {
  "200",                           // U8* mml_version
  "<mml:math class=\"displayedmathml\" mode=\"display\" display=\"block\">",
  "<mml:math class=\"inlinemathml\" display=\"inline\">",
  "mml:",                         //  U8* namespace_prefix;
  "fontfamily=\"Times New Roman\" fontsize=\"100%\"",   //  U8* mstyle_attrs;
  "mathcolor=\"gray\"",           //  U8* mathname_attrs;
  "mathcolor=\"green\"",          //  U8* unitname_attrs;
  "mathcolor=\"black\"",          //  U8* text_in_math_attrs;
  "mathcolor=\"green\"",          //  U8* link_attrs;
  "true",                         //  U8* renderer_baselines;
  "false",                        //  U8* eqn_tags_to_mlabeledtr;
  "false",                        //  U8* eqn_nums_to_mlabeledtr;
  "0",                            //  U8* entity_mode;
  "1",                            //  U8* lr_spacing_mode;
  "1",                            //  U8* lr_spacing_mode_in_scripts;
  "(%theequation%)",              //  U8* eqn_nums_format;
  "false",                        //  U8* long_arrows_are_stretched;
  "2",                            //  U8* indent_increment;
  "true",                         //  U8* adjust_output_for_IE_spacing_bug;
  "<mml:mtext class=\"fix-IE-bug\">&ZeroWidthSpace;</mml:mtext></mml:math>",
  ""
};



bool fix_IE_space_bug =  true;

//HINSTANCE s_hApp;
//HINSTANCE s_hDLL;

std::string s_mathml;
std::string s_anomaly;
extern char* s_mmldirname;

bool mathmlHandler(U32 type, const char* data)
{
  if ( type < 1000 ) {
    s_mathml += "\n";
    s_mathml += data;
  } else if ( type == 1001 ) {
    s_anomaly = data;
  }
  return true;
}

bool SetupMathML()
{
    for (int j = 0; j < NUM_UPREF_STRS; j++ )
    {
      if (upref_zstrs[j] == NULL)
      {
        char* temp = new char[1];
        temp[0] = 0;
        upref_zstrs[j] = temp;
      }
    }

    fix_IE_space_bug = (strcmp(upref_zstrs[FIX_IE_BUG], "true") == 0);

    bool hr = InitializeMML( (const char*) s_mmldirname,
                                (const char*)"mml:",
                                (const char**)upref_zstrs );
    return hr;
}

void TakeDownMathML()
{
   TerminateMML();
}

void ProcessMathML(const char* str, std::string& outp, std::string& anom){
  //LPCONVERT convertfunc;
  //convertfunc  = (LPCONVERT)GetProcAddress(s_hDLL,"ConvertInline");
  ConvertInline( str, mathmlHandler, 2 );
  outp = s_mathml;
  s_mathml = "";
  anom = s_anomaly;
  s_anomaly = "";
}


void CloseMathML()
{
  int i =  0;
  while ( i < 20 ) {
    char* str = upref_zstrs[i];
    if ( str )
       delete[] str;
    i++;
  }
  //if (s_hDLL != 0){
  //   FreeLibrary(s_hDLL);
  //}
}



@}
