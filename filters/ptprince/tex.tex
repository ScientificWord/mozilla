
%*******************************************************************************
%*                    START OF AUTOMATICALLY GENERATED TEX FILE                *
%*******************************************************************************
%*                                                                             *
%* This TeX file was automatically generated by the FunnelWeb preprocessor.    *
%* You can typeset this file to produce printed documentation by running it    *
%* through the TeX typesetter using a command such as:                         *
%*    tex thisfilename                                                         *
%* The resultant file thisfilename.dvi can be printed using a command such as: *
%*    lpr -Plaser -d thisfilename.dvi                                          *
%*                                                                             *
%* FunnelWeb is a preprocessor that allows programmers to weave programs and   *
%* their documentation together in a single document. The FunnelWeb program    *
%* analyses such documents producing both program files and typeset            *
%* documentation such as this TeX file.                                        *
%* FunnelWeb was created by Ross N. Williams.                                  *
%*                                                                             *
%* For more information on FunnelWeb see http://www.ross.net/funnelweb/        *
%*                                                                             *
%*******************************************************************************


%===================== Start of FunnelWeb TeX Definitions ======================


% Version
% -------
% This is FunnelWeb TeX Macro Library Version 1.0.


% Copyright
% ---------
% This set of FunnelWeb TeX definitions was written by Ross Williams and was
% originally Copyright (C) 1992 Ross N. Williams.  However, I, Ross Williams,
% hereby forego any claim to Copyright in this set of FunnelWeb TeX definitions
% and hereby authorize that the set of TeX definitions pass into the public
% domain. -- Ross N. Williams, 3:41pm 07-May-1992, Adelaide, Australia.


% Modification
% ------------
% Please record all modifications to these TeX definitions here. Unless
% otherwise specified, all modified definitions fall in the public domain too.
%
% Programmers:
%    RNW  Ross N. Williams  ross@ross.net
%
% Changes:
%    07-May-1992  RNW  Prepared this work for public domain release.
%    10-May-1999  RNW  Added \fwlib macro.


% General Comments
% ----------------
% This set of TeX definitions exists for two reasons:
%
%    1. To shorten and neaten the FunnelWeb TeX output.
%    2. To allow users to fiddle with the output format in their input files
%       (by inserting redefining "\def"s) without having to resort to
%       modifying the FunnelWeb code.
%
% The user is warned that these definitions may be changed from time to time
% (but probably not much). The user should not be too sneaky. In particular,
% users wishing to redefine some of these macros should do so in an explicitly
% defined section at the top of their input file. This will mean that in the
% event of problems, that section can simply be deleted or commented out to
% allow the document to at least be typeset in the default format. Users should
% limit themselves to redefining these macros in such a section and should
% refrain from using the macros throughout their documents.


% Environment Parameters
% ----------------------
% \tolerance tells TeX how tolerant it should be about making bad line and
% page breaks. Here we set it to it's maximum, as
%   1) Computer programs are likely to cause lots of bad breaks.
%   2) In most cases the user would probably rather get the TeX file through
%      TeX without any errors than fiddle with spacings for perfection.
\tolerance=10000

% I don't like indentation as it makes the page look more busy. Instead,
% paragraphs are separated by a little space (see next).
\parindent=0pt

% In many cases, users will produce documents with long runs of paragraphs.
% In order to space out these paragraphs, it is convenient to maintain a
% prevailing non-zero \parskip (end-of-paragaph skip). The only trouble is
% that the skip becomes a problem in macro definitions which require no skip
% and so we have to turn the skip on and off. The following two macros
% simplify this process.
\def\fwparskipon{\parskip=\medskipamount}
\def\fwparskipoff{\parskip=0pt}
\fwparskipon

% Setting raggedbottom allows TeX to leave a bit of space at the bottom of the
% page in order to better vertically align the rest of the page (e.g. skips
% won't stretch as much). It also means that headings are less likely to be
% isolated at the bottom of the page without any following text.
\raggedbottom


% Fonts
% -----
% Most of the typeset output is set in 10pt roman and 10pt tt font.
% The major extra font needs spring from titles and headings.
% For portability's sake we use only the following fonts:
%    cmr10
%    cmbx10
%    cmtt10
% and some enlargements of them. These fonts are all "standard" fonts
% in Plain TeX. See The TeXbook p.350.
\font\fwfontnote=cmr7

\font\fwfontnorm=cmr10
\font\fwfontnorma=cmr10 scaled \magstep1
\font\fwfontnormb=cmr10 scaled \magstep2

\font\fwfontbold=cmbx10
\font\fwfontbolda=cmbx10 scaled \magstep1
\font\fwfontboldb=cmbx10 scaled \magstep2
\font\fwfontboldc=cmbx10 scaled \magstep3
\font\fwfontboldd=cmbx10 scaled \magstep4


% Macros for Stylistic Details
% ----------------------------
% This section contains all the fiddly little macros for setting the details
% of each macro definition.

% Macro definitions are sandwiched by calls to these macros which can be used
% to sort out the spacing before and after the macro definition.
\def\fwbeginmacro{\fwparskipoff\bigskip}
\def\fwendmacro{\fwparskipon\par}

% These macros deal with the macro name and definition line.
\def\fwmacroname#1#2{{\sl #1\/}$\lbrack$#2$\rbrack$}
\def\fwfilename#1#2{{\bf #1}$\lbrack$#2$\rbrack$}
\def\fwzero#1{{\bf Z}}
\def\fwmany#1{{\bf M}}
\def\fwlib#1{{\bf L}}
\def\fwequals{ $\equiv$}
\def\fwplusequals{ $+\equiv$}

% Now for the actual body of the definition. It looks nice to have the tt
% code indented a little. Again, we use macros instead of writing direct TeX,
% so as to allow the user to fiddle this stuff to taste without having to
% modify the FunnelWeb C code.
\def\fwodef{\parindent=15pt\vskip0pt$\lbrace$\parindent=20pt}
\def\fwcdef{$\rbrace$\vskip0pt\parindent=0pt}
\def\fwoquote{`}
\def\fwcquote{'}
\def\fwoparen{$($}
\def\fwcomma{$,$}
\def\fwcparen{$)$}
\def\fwparam#1{$\diamond #1$}
\def\fwparams#1{$(\diamond #1)$}

% These macros deal with the notes that are appended at the end of each
% macro definition. Note that even though \fwisafile,\fwusedin, and \fwseealso
% have the same definition, they are given different names so as to allow the
% user to redefine these macros to typeset each kind of information differently
% if desired.
\def\fwbeginmacronotes{\begingroup\baselineskip=9pt\smallskip}
\def\fwnote#1{{\fwfontnote #1}\par}
\def\fwisafile#1{\fwnote{#1}}
\def\fwusedin#1{\fwnote{#1}}
\def\fwseealso#1{\fwnote{#1}}
\def\fwendmacronotes{\endgroup}


% Macros to Typeset Program Code Verbatim
% ---------------------------------------
% This is by far the hairiest and most difficult part of the typesetting task
% because we have to turn off most of TeX's natural instincts in order to
% typeset the program text exactly as it appears in the input file.
% Two macros are defined to pull this off: \fwbtx and \fwverbatimgobble.
% Their code was inspired by the following sections of "The TeXbook":
%    Appendix D: Dirty Tricks, 3.Verbatim listing, p.380-382.
%    Appendix E: Example Formats, p.421.
% The \fwbtx[ (for "FunnelWeb Begin TeXt") macro does most of the hard work.
% The liberal use of "%" is because I don't understand TeX well enough to
% understand when an end of line will cause trouble, and I am playing it safe.

% Before defining the main \fwbtx macro, we have to stash away some definitions
% in the hidden part of TeX's environment. Let's hope that these "hidden"
% definitions don't affect anything except what is desired to be affected.

% The tt font in which we wish to set the text has two Latin lurking ligatures!
% These are ?` and !`. To disable them, we define the left quote when ACTIVE
% to be defined in such a way as to prevent ligatures. The main TeX text will
% normally not be exposed to this definition because normally the leftquote
% character is not active. The \fwbtx macro temporarily makes the left quote
% character active thus activating the deactivation of left quote ligatures.
% See The TeXbook p.381.
{\catcode`\`=\active \gdef`{\relax\lq}}

% TeX is fairly carefree about spaces and so we have to make it more serious.
% To do so we pull the same trick as above, setting up a definition for active
% space, but only making space active during the span of the verbatim text.
% In Plain TeX the active space is defined to be simply a space, but here we
% define it to be a control space. This ensures that the space cannot
% be gobbled up by one of TeX's mysterious mechanisms when activated.
% See The TeXbook, p.381 and p.352.
{\obeyspaces\global\let =\ }

% Here is the main \fwbtx verbatim text macro.
% Note: The order in which all these pieces of business have to be done is
% still a partial mystery to me. Don't fiddle with this stuff unless you
% think you know what you are doing.
\def\fwbtx[{%
%
% The funnies involved in getting verbatim output are safely housed inside
% this \begingroup, and the \endgroup in \fwverbatimgobble. Groups are used
% instead of curly braces because we have to be able to signal the end of
% this macro with a curly brace.
\begingroup%
%
% \pars at the end of empty lines in the verbatim text won't come out normally
% because TeX is in vertical mode and they get gobbled up. To prevent this,
% we force \par to exit vertical mode first. See The TeXbook p.381.
\def\par{\leavevmode\endgraf}%
%
% Activate the leftquote character so as to avoid ligatures (see above).
\catcode`\`=\active%
%
% The \obeylines macro simply defines end of line (^M) to be \par. This ensures
% that TeX will treat each verbatim line as a new paragraph.
\obeylines%
%
% To get verbatim output, we have to desex all the special characters. This
% is explained in detail in The TeXbook p.380.
\def\do##1{\catcode`##1=12 }\dospecials%
%
% Activate the space character so as to make TeX treat blanks seriously.
% This activation invokes an eralier definition (see above).
\obeyspaces
%
% Interparagraph skips do not help the cause.
% Note: We have to preserve the indentation though, as the code is actually
% indented in the final output. See \fwodef in an earlier section.
\parskip=0pt%
%
% We typeset the verbatim text in tt font (courier on the Macintosh) for a
% number of reasons:
%    - tt font has the same horizontal spacing for each character.
%    - tt font covers the ASCII character set.
%    - tt font doesn't have many surprises (e.g. ligatures).
%    - tt font looks much what you might see on a computer terminal screen.
\tt%
%
% Having set up an environment for verbatim, we are ready to use it.
% By invoking \fwverbatimgobble, this \fwbtx macro gobbles up text verbatim (as
% part of the parameter of \fwverbatimgobble) until it sees the termination
% string "]fwetx=" (the "=" was thrown in to add obscurity as this sequence
% must never occur in the verbatim text).
\fwverbatimgobble}

% The \fwverbatimgobble macro exists to allow \fwbtx to bracket verbatim text.
\def\fwverbatimgobble#1]fwetx={#1\endgroup}


% Table of Contents
% -----------------
% The five levels of table of contents that FunnelWeb supports are identified
% by the five letters [A..E]. These are used throughout the following macros.

% The following macros are utilities to the TOC macros to follow.
\def\fwrule{\medskip\hrule\medskip}
\def\fwqh{\hskip1.5em\relax}
\def\fwbeforesec{\penalty-200\bigskip\medskip\par}

% The following macros are used to typeset the table of contents.
\def\fwtocstart#1{\fwrule\leftline{\fwfontbolda Table of Contents}\fwrule}
\def\fwtoca#1#2{\leftline{{\bf #1 #2}}}
\def\fwtocb#1#2{\leftline{\fwqh #1 #2}}
\def\fwtocc#1#2{\leftline{\fwqh\fwqh #1 #2}}
\def\fwtocd#1#2{\leftline{\fwqh\fwqh\fwqh #1 #2}}
\def\fwtoce#1#2{\leftline{\fwqh\fwqh\fwqh\fwqh #1 #2}}
\def\fwtocfinish#1{\fwrule}

% The following "library" macros define five different strengths of headings
% which can be used later in the section macros.
\def\fwliba#1#2{\vfill\eject{\fwfontboldc #1 #2}\penalty200\smallskip}
\def\fwlibb#1#2{\fwbeforesec{\fwfontboldb #1 #2}\penalty200\smallskip}
\def\fwlibc#1#2{\fwbeforesec{\fwfontnormb #1 #2}\penalty200\smallskip}
\def\fwlibd#1#2{\fwbeforesec{\bf          #1 #2}\penalty200}
\def\fwlibe#1#2{\fwbeforesec{\bf          #1 #2}}

% Here are the macros that actually typeset the section headings throughout
% the document. The fwlib system has been employed so as to easily allow the
% user to redefine the strengths of headings to taste. For example, the
% user could insert in the input document a similar set of definitions to these
% but with the b..e headings set to \fwlibc. This would tone down the output.
\def\fwseca#1#2{\fwliba{#1}{#2}}
\def\fwsecb#1#2{\fwlibb{#1}{#2}}
\def\fwsecc#1#2{\fwlibc{#1}{#2}}
\def\fwsecd#1#2{\fwlibd{#1}{#2}}
\def\fwsece#1#2{\fwlibe{#1}{#2}}


% Support for Explicit Typesetting
% --------------------------------
% FunnelWeb supports pragmas and other constructs that allow
% typesetter-independent typesetting commands to be given. The
% following macros support these features.

% The in-text literal @{sloth@} and emphasise @[walrus@] features.
\def\fwlit#1{{\tt #1}}
\def\fwemp#1{{\it #1}}

% The "@p new_page" pragma.
\def\fwnewpage{\vfill\eject}

% The "@p vskip Nmm" pragma.
\def\fwvskip#1{\null\vskip #1mm}

% The "@p title <font> <align> <text>" pragma.
\def\fwfontnormal#1{{\fwfontnorm {#1}}}
\def\fwfonttitle#1{{\fwfontboldd {#1}}}
\def\fwfontsmalltitle#1{{\fwfontboldb {#1}}}
\def\fwleftline#1{\leftline{#1}}
\def\fwcenterline#1{\centerline{#1}}
\def\fwrightline#1{\rightline{#1}}


% Support for Old FunnelWeb
% -------------------------
% The following macros were used extensively in the first version of
% FunnelWeb and are retained so that these older input files will still
% typeset cleanly.
\def\p#1{{\tt #1}}  % P for Program text.
\def\flagpage#1#2{
   \null
   \vfill
   \centerline{\fwfontboldd #1}
   \vskip 1cm
   \centerline{\fwfontboldd #2}
   \vfill
   \null
   \vfill
}

%====================== End of FunnelWeb TeX Definitions =======================



\input docmacros





\fwvskip{40}
\fwcenterline{\fwfonttitle{TeX 2003}}
\fwvskip{10}
\fwcenterline{\fwfontsmalltitle{Jon Stenerson}}
\fwcenterline{\fwfontsmalltitle{27 Aug 2003}}
\fwvskip{20}

\fwtocstart{}
\fwtoca{1}{Introduction}
\fwtocb{1.1}{The Big Picture}
\fwtocb{1.2}{Outline of TeX}
\fwtocb{1.3}{Development Processes and Tools}
\fwtocb{1.4}{Literate programming: Funnelweb}
\fwtocb{1.5}{Development platforms}
\fwtocb{1.6}{Program Structure}
\fwtocb{1.7}{Testing and debugging strategy}
\fwtocb{1.8}{Stepping through in a debugger}
\fwtocb{1.9}{Assertions}
\fwtocb{1.10}{Execution logs}
\fwtocb{1.11}{Unit tests}
\fwtocb{1.12}{Component tests}
\fwtocb{1.13}{Black box tests}
\fwtocb{1.14}{Beta testing}
\fwtoca{2}{The platform subsystem}
\fwtocb{2.1}{Exceptions}
\fwtocb{2.2}{Assertions}
\fwtocb{2.3}{Execution logging}
\fwtocb{2.4}{Bytes and Characters}
\fwtocb{2.5}{Strings}
\fwtocb{2.6}{Paths}
\fwtocb{2.7}{File names}
\fwtocb{2.8}{Input Byte streams}
\fwtocb{2.9}{Output Byte streams}
\fwtocb{2.10}{Input Byte files}
\fwtocb{2.11}{Output Byte files}
\fwtocb{2.12}{Arithmetic}
\fwtocb{2.13}{Physical layout}
\fwtoca{3}{The Text IO Subsystem}
\fwtocb{3.1}{Interface}
\fwtocb{3.2}{Lines of Text}
\fwtocc{3.2.1}{Interface}
\fwtocc{3.2.2}{Implementation}
\fwtocc{3.2.3}{Tests}
\fwtocb{3.3}{Converting Bytes to TeXChars}
\fwtocc{3.3.1}{Tests}
\fwtocb{3.4}{Line Sources}
\fwtocc{3.4.1}{Tests}
\fwtocb{3.5}{Overall subsystem}
\fwtocb{3.6}{Physical layout}
\fwtoca{4}{The symbols subsystem}
\fwtocb{4.1}{Interface}
\fwtocb{4.2}{Hash table implementation}
\fwtocc{4.2.1}{Active character definitions}
\fwtocc{4.2.2}{Tests}
\fwtocb{4.3}{Physical layout}
\fwtoca{5}{Basic TeX data types and parameters}
\fwtocb{5.1}{Integers}
\fwtocb{5.2}{Scaled}
\fwtocb{5.3}{Glue}
\fwtocb{5.4}{Boxes}
\fwtocb{5.5}{TeXTokens}
\fwtocb{5.6}{Token lists}
\fwtocb{5.7}{Rules}
\fwtocb{5.8}{Catcode and other tables}
\fwtocb{5.9}{Converting of basic types to strings}
\fwtocb{5.10}{Input and Output files}
\fwtocb{5.11}{Physical layout}
\fwtoca{6}{Saving and restoring definitions}
\fwtoca{7}{The Token subsystem}
\fwtocb{7.1}{Introduction}
\fwtocb{7.2}{Token Sources}
\fwtocb{7.3}{Tokenizer}
\fwtocb{7.4}{Input Stack}
\fwtocb{7.5}{Tests}
\fwtocb{7.6}{Physical layout}
\fwtoca{8}{Basic scanning functions}
\fwtocb{8.1}{Overview}
\fwtocb{8.2}{Expandable and Primitive symbol data}
\fwtocb{8.3}{GetToken}
\fwtocb{8.4}{Scan an integer: ScanInt}
\fwtocb{8.5}{ScanSomethingInternal}
\fwtocc{8.5.1}{ScanKeyword}
\fwtocb{8.6}{Scan dimension}
\fwtocb{8.7}{ScanGlue}
\fwtocb{8.8}{Rules}
\fwtoca{9}{Basic expandables}
\fwtocb{9.1}{$\backslash$input}
\fwtocb{9.2}{$\backslash$number}
\fwtocb{9.3}{$\backslash$romannumeral}
\fwtocb{9.4}{$\backslash$meaning}
\fwtocb{9.5}{$\backslash$jobname}
\fwtocb{9.6}{$\backslash$fontname}
\fwtocb{9.7}{$\backslash$the}
\fwtocb{9.8}{$\backslash$noexpand}
\fwtocb{9.9}{$\backslash$uppercase and $\backslash$lowercase}
\fwtocb{9.10}{$\backslash$mark}
\fwtocb{9.11}{$\backslash$expandafter}
\fwtocb{9.12}{$\backslash$csname}
\fwtocb{9.13}{$\backslash$string}
\fwtoca{10}{Conditional processing}
\fwtocb{10.1}{Condition stack}
\fwtocb{10.2}{Token related conditionals}
\fwtocb{10.3}{Integer conditionals}
\fwtocb{10.4}{Mode testing conditionals}
\fwtocb{10.5}{ifeof}
\fwtocb{10.6}{Box testing conditionals}
\fwtoca{11}{Fonts metric data}
\fwtoca{12}{The Command Interpretter}
\fwtocb{12.1}{Main Loop}
\fwtocb{12.2}{Some debugging aids}
\fwtocb{12.3}{Commands to insert nodes into the current list}
\fwtocc{12.3.1}{Character node creation}
\fwtocc{12.3.2}{Glue creation commands}
\fwtocc{12.3.3}{Kern node creation}
\fwtocc{12.3.4}{Insert node creation}
\fwtocc{12.3.5}{Create mark node}
\fwtocc{12.3.6}{Create penalty nodes}
\fwtocc{12.3.7}{Create rule nodes}
\fwtocb{12.4}{More commands}
\fwtocc{12.4.1}{Tag creating commands}
\fwtocc{12.4.2}{Paragraph starting and ending}
\fwtocc{12.4.3}{Show}
\fwtocb{12.5}{Message and errmessage}
\fwtocb{12.6}{Logging modes}
\fwtocb{12.7}{Reading files}
\fwtocb{12.8}{Writing files}
\fwtocb{12.9}{$\backslash$char92font}
\fwtocb{12.10}{$\backslash$begingroup and $\backslash$endgroup}
\fwtocb{12.11}{$\backslash$ignorespaces}
\fwtocb{12.12}{$\backslash$aftergroup and $\backslash$afterassignment}
\fwtocb{12.13}{Physical layout}
\fwtoca{13}{Assignment commands}
\fwtocb{13.1}{Prefixes}
\fwtocb{13.2}{Shorthand definitions}
\fwtocb{13.3}{Assign catcodes, uccodes, etc}
\fwtocb{13.4}{Integer parameter assignments}
\fwtocb{13.5}{Integer register assignments}
\fwtocb{13.6}{Counter shorthand commands}
\fwtocb{13.7}{Tests}
\fwtocb{13.8}{Dimension parameter assignment}
\fwtocb{13.9}{Dimension register assignment}
\fwtocb{13.10}{Dimension shorthand}
\fwtocb{13.11}{Font dimensions}
\fwtocb{13.12}{Glue parameter assignment}
\fwtocb{13.13}{Glue register assignment}
\fwtocb{13.14}{Skip shorthand}
\fwtocb{13.15}{Register assignment}
\fwtocb{13.16}{Token list parameter assignment}
\fwtocb{13.17}{Token register assignment}
\fwtocb{13.18}{Token register shorthand commands}
\fwtocb{13.19}{Tests}
\fwtocb{13.20}{$\backslash$advance etc}
\fwtocb{13.21}{$\backslash$let etc.}
\fwtocb{13.22}{Assign box register ($\backslash$setbox)}
\fwtocb{13.23}{Assign box dimensions ($\backslash$wd, $\backslash$ht, $\backslash$dp)}
\fwtoca{14}{Box commands}
\fwtocb{14.1}{Scan boxes}
\fwtoca{15}{Commands to make macro definitions}
\fwtocb{15.1}{Macros}
\fwtoca{16}{The node data structures}
\fwtoca{17}{Mathematics}
\fwtocb{17.1}{Getting into and leaving math mode}
\fwtocb{17.2}{Equation numbers}
\fwtocb{17.3}{ScanMath}
\fwtocb{17.4}{Subscripts and superscripts}
\fwtoca{18}{Alignment}
\fwtoca{19}{The Typesetter}
\fwtocb{19.1}{The Interface}
\fwtoca{20}{The main program}
\fwtoca{21}{Line breaking}
\fwtocb{21.1}{Interface}
\fwtocb{21.2}{Physical layout}
\fwtoca{22}{Tables and alignment}
\fwtoca{23}{User Interface}
\fwtocfinish{}



\fwseca{1}{Introduction}


\fwsecb{1.1}{The Big Picture}

This is a re-implementation of TeX. \TeX82 was written in the years
prior to 1982 and was more or less frozen at that time. It has been
21 years without major revision.

The goal is to create a cleaner, more modular implementation and
package it in a library. The main extension I have in mind is that
this implementation serve as the core of a general \TeX{} input
filter for future Scientific Workplace releases.  Other extensions might
include things like a \TeX{} debugger, unicode and national character
set support, direct support for LaTeX3 if it is ever released. One of
the weak areas of \TeX{} is page layout. There is room to add features
there.

\fwsecb{1.2}{Outline of TeX}

\TeX{} is a general programming language. A \fwlit{.tex} file is a program
written in \TeX. The first to relaize is that \TeX{} is an interpretted
language and not compiled. \TeX{} reads a command and executes it,
reads a command and executes it, and so on. \TeX{} commands may be
conveniently divided into two groups: elementary, and expandable.
We think of \TeX{} as a language of `elementary commands'
embedded in a macro language.
The purpose of most elementary \TeX{} commands is to drive the
\TeX{} typesetting engine. The most common elementary commands are
letters and spaces. It your \fwlit{.tex} file contains the characters
\fwlit{It was the best of times} these characters are interpretted as
commands: letter I, letter t, space, letter w, and so on. There are
many more elementary commands and many of them have complex arguments.
For example, \fwlit{\char`\\hbox to 3pt\char`\{...\char`\}} is an elementary command
that causes the typestter to create an \fwlit{hbox} of a certain size
and content.

The elementary commands do not have the usual programming language
control structures however. There are no conditionals, no loops,
no subroutines. These are implemented rather in the macro language.
The macro language contains conditionals like \fwlit{\char`\\if}, \fwlit{\char`\\ifhmode},
and the like. It contains commmands like \fwlit{\char`\\csname} and \fwlit{\char`\\string}
to compose and decompose control sequences. The commands of the macro
language are called ``expandable''. New expandable commands are
created with the elementary command \fwlit{\char`\\def}. The elementary command parser
does not see expandable commands. Whenever the parser expects a certain
kind of token and an expandable command appears instead, the expandable
command is removed and replaced by its ``expansion' before the parser
sees it.  For example, consider \fwlit{\char`\\hbox t\char`\\ifnum1\char`\<2o 3p\char`\\fi t\char`\{...\char`\}}.
\TeX{} sees \fwlit{\char`\\hbox}, recognizes the start of a command and begins parsing
for parameters. It sees a `t' and knows this could be part of a parameter.
So it looks at the next token. The next token the parser sees is not
\fwlit{\char`\\ifnum} as you might suppose. Instead the \fwlit{\char`\\ifnum} construct
expands to \fwlit{o 3p} because the condition \fwlit{1\char`\<2} is true. So the next
token the parser sees is `o', follwed by `3', `p' and so on.

According to this discussion \TeX{} has two main pieces:
(1) a typesetting engine, (2) an interpretter.

The \fwlit{User Interface} is the top-level subsystem. It provides a
console that is used to observe and control the rest of the system.
Although I have no immediate plans to implement much here it could
eventually allow you to do the usual debugging things: set breakpoints,
single step the code, and look at values of variables. The next level is
the \fwlit{Command Interpretter}. This takes a stream of tokens from the
\fwlit{Macro Processor} and parses them into commands and then executes
the commands. Most of the commands will be addressed to the
\fwlit{Typesetter} subsystem and to the \fwlit{Macro Processor} subsystem. The
\fwlit{Typesetter} produces a \fwlit{.dvi} output file that can be easily
converted to PostScript or some other printer language. In addition
there is a \fwlit{Platform} subsystem that provides basic definitons that
may have to change with the platform.

The first work product we'll make is a source distribution. This is
becuase I want to distribute it to my Windows system for building and
testing. So here is the question: given that we have a bunch of
\fwlit{.fw} files and perhaps some others, how do we get them to another
computer, and build \TeX there? Here's my plan. There will be a file
of build and distribution commands written in Python. This will be
part of the distribution. The Python script can determine which system
we're building on and set things up appropriately.

The binary distributions go to the end user. Ultimately I want to
provide distributions to the end user. There will be a binary
distribution and a source distribution.  should consist of a single
archive file (and perhaps a second file containing download
instructions) for easy downloading. The archive can be unpacked into a
directory and some instructions followed to obtain a running system,
or a compilable system as the case may be.


\fwsecb{1.3}{Development Processes and Tools}

There is more to software develpment than writing code. You need
documentation, tests, a backup strategy, and a distribution scheme
(and this doesn't include the marketing, sales, and management
issues). There are several tools involved. Some things that are
absolutely essential in my opinion are (1) having an automated daily
build, (2) having an automated testing system, and (3) having a source
control system. I also decided that I would regularly build and test
on Windows.

\fwsecb{1.4}{Literate programming: Funnelweb}

I've never done literate programming so I decided I would try it. I
found that \fwlit{WEB} and \fwlit{CWEB} were not to my liking. It seemed
difficult to generate makefiles and data files using them. It seemed a
bit too Pascal/C-oriented. This program is written in FunnelWeb.


Funnelweb is a literate programming tool avaiable freely on the Web
at \fwlit{http://www.ross.net/funnelweb}

Literate programming basically means that a program and its
documentation are written together. The \TeX{} program is written as a
bunch of files. The funnelweb processor reads the source files and
produces (1) C++ source, and (2) \TeX{} documentation.  You are now
reading the \TeX{} documentation that resulted from running funnelweb on
the source files.


How to read documentation produced by funnelweb. This book is
basically explanatory prose with scraps of code and data
interspersed. The scraps are named and numbered.

Here's our first scrap.

\fwbeginmacro
\fwmacroname{Program name}{1}\fwequals \fwodef \fwbtx[TeX]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 3.}
\fwendmacronotes
\fwendmacro


It defines a macro called {\it Program name}. The number of the scrap
is contained in square brackets after the macro name like this`[1]'.
Whenever this macro is used in the rest of this book it will be
replaced by the text \fwlit{TeX}. It says at the bottom that this macro
is invoked in definition 3. If you look ahead to scrap 3 you'll see that
this is so. Here is another similar scrap

\fwbeginmacro
\fwmacroname{Program version}{2}\fwequals \fwodef \fwbtx[0.0]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 3.}
\fwendmacronotes
\fwendmacro


How do we finally make use of these scraps to generate source code?
Here's a simple C++ header file that uses the macros defined above.

\fwbeginmacro
\fwfilename{version.h}{3}\fwequals \fwodef \fwbtx[#ifndef VERSION_H
#define VERSION_H
const char* PROGRAM_NAME = "]fwetx=%
\fwmacroname{Program name}{1}\fwbtx[";
const char* PROGRAM_VERSION = "]fwetx=%
\fwmacroname{Program version}{2}\fwbtx[";
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


A scrap with bold name describes a file to be generated. It also
says at the bottom that it is attached to an output file. This means
that there is a generated file called \fwlit{version.h} and it contains
the text

\beginlines|
#ifndef VERSION_H
#define VERSION_H
const char* PROGRAM_NAME = "Tex";
const char* PROGRAM_VERSION = "0.0";
#endif
|\endlines

where macro definitions [1] and [2] have been substituted.

Need examples of  +=



\fwsecb{1.5}{Development platforms}

I considered the development platform. On the one hand our products are
developed for windows only. So I have to develop a Windows version. On
the other hand I've done most of my previous development on Windows and
I wanted a change. So I've decided to try and develop on Linux but
constantly port to Windows.

Here is a funnelweb macro intended to help with portability issues.
This macro takes two arguments, the first should contain Linux
particulars and the second should be windows particulars. In this
version of the book the macro is defined to always select the second
argument.



\fwbeginmacro
\fwmacroname{Platform}{4}\fwparams{2}\fwmany{}\fwequals \fwodef \fwparam{2}\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 5 and 106.}
\fwendmacronotes
\fwendmacro


For example, line ends are different in the two target systems:

\fwbeginmacro
\fwmacroname{LineEnd}{5}\fwequals \fwodef \fwmacroname{Platform}{4}\fwoparen \fwoquote\fwbtx[10]fwetx=%
\fwcquote\fwcomma \fwoquote\fwbtx[13 10]fwetx=%
\fwcquote\fwcparen \fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 67.}
\fwendmacronotes
\fwendmacro


The {\bf M} at the end of the {\it Platform} macro says that this macro
may be used multiple times. Without the {\bf M} a macro may be used
exactly once.


I needed a scripting language so that I could write build and install
scripts, and testing scripts. I could not use bash (a typical Linux
shell language) because that would not port to Windows. In fact Windows
has no shell language to speak of so I decided to use Perl which we
already use in our development processes.

Make is somewhat portable if you stick to the basic features.

\fwsecb{1.6}{Program Structure}

\TeX{} is a medium sized program. I believe that for this sort of
program the best way to do the overall design and implementation is in
terms of {\it components}.  In this terminology a component is simply
a pair of files: a \fwlit{.h} header file and a \fwlit{.cpp} implementation
file. (See Lakos). A good component provides enough functionality that
it makes sense to implement and test it independently.

So we look for a chunk of functionality that we want to call a
component. The most obvious is the command interpretter. This is an
object that parses a stream of tokens into commands and parameters,
and then executes the command.

Here is a list of components in the final program:
...

This DAG also constrains our order of implementation. You might want to
implement the bottom level of the DAG first, and then the next level
and so on, but I think it's better to work your way toward the top of
the DAG quickly even if it means leaving parts of the top
unimplemented. So we start with \fwlit{platform}, then \fwlit{textio}, then
\fwlit{symbols}, then \fwlit{tokens}, \fwlit{macrop}, and finally \fwlit{main}. Now,
main needs a lot more than the listed predecessors but it feels better
to have a program that does something at all times.

It is also not necesary to completely implement a component before
going on to the next. Just make sure to write code to test whatever
you implement as you go. See the next section.

\fwsecb{1.7}{Testing and debugging strategy}

The quicker you find a bug, the quicker you can fix it and move on to
new features and functionality. You can't just write code and release
it. I've tried that approach and it works poorly.

Debugging vs. Testing. These are basically inseparable processes. The
steps are are roughly: 1) Detect and describe defect, 2) Determine
cause, 3) Fix.  For my purposes debugging means building a special form
of the program that contains information that can be used by a debugger,
and using those to track down the cause of a bug. Testing is the way
you find bugs in the first place. The goal is to do a lot of testing
and not so much debugging.

There are several kinds of tests. No single kind of test is adequate.

\fwsecb{1.8}{Stepping through in a debugger}

\fwsecb{1.9}{Assertions}

\fwsecb{1.10}{Execution logs}

\fwsecb{1.11}{Unit tests}

Associated to each component is a unit test. I decided that for each
component I would generate a test jig with the same name but for a
\fwlit{.t} appended to the end. Thus the component \fwlit{macrop} has a test
program called \fwlit{macrop.t} whose job is to test the functionality of
\fwlit{macrop}.

While building unit tests we'll also create component test
utilities. These are procedures to aid in writing tests for this and
dependent components, but are not used in the program itself. For
instance, we will want a function called, say,
\fwlit{OpenInputFile(}filename\fwlit{)} that causes the next input to come
from that file. So it behaves kind of like the \TeX{} \fwlit{\char`\\input}
command. However, for testing purposes we can't wait until the
\fwlit{\char`\\input} command is implemented to start inputting files. Thus we
place a utility \fwlit{OpenInputFile} in a file where tests can use
it. The utility can make many simplifying assumptions. That the file
exists, is readable, has a known encoding, and so on. The actual
\fwlit{\char`\\input} command has to do a lot more work.

\fwsecb{1.12}{Component tests}

Each component has a test jig program to exercise it. The program consists
of a main program and a collection of test functions prototyped as follows

\fwbeginmacro
\fwmacroname{Test function prototype}{6}\fwequals \fwodef \fwbtx[typedef bool (*TESTFCN)(void);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 8.}
\fwendmacronotes
\fwendmacro


In other words, a test function takes no parameters and returns a
boolean. True if the test passes, and false if it fails.

The functions are associated to external names using a table declared
as follows. Note the {\bf M} used at the end of the macro. This means
it can be used more than once in the document.  I plan to use this
macro in every module.

\fwbeginmacro
\fwmacroname{TestTable declaration}{7}\fwmany{}\fwequals \fwodef \fwbtx[struct NameFcn {
    const char* name;
    TESTFCN fcn;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 8.}
\fwendmacronotes
\fwendmacro


The test jig main program follows. It checks the command line
arguments and runs the appropriate test. You can also use the
parameters \fwlit{all} to run all the test functions and \fwlit{list} to get a
list of all the test names.If the test or tests all check out the
program prints OK and stops. Otherwise it reports which test failed.

\fwbeginmacro
\fwmacroname{Test jig}{8}\fwparams{2}\fwmany{}\fwequals \fwodef \fwbtx[
]fwetx=%
\fwmacroname{Test function prototype}{6}\fwbtx[
]fwetx=%
\fwmacroname{TestTable declaration}{7}\fwbtx[

// Test functions
]fwetx=%
\fwparam{1}\fwbtx[

static NameFcn TestTable[] = {
    ]fwetx=%
\fwparam{2}\fwbtx[
    {0, 0}
};


int main (int argc, char* argv[], char* env[])
{
    bool b = true;
    std::string arg = argv[1];
    int tableIndex = 0;
    if (arg == "list"){
        while ( 0 != TestTable[tableIndex].name ){
            std::cout << TestTable[tableIndex].name << "\n";
            ++tableIndex;
        }
    }else if (arg == "all"){
        while ( 0 != TestTable[tableIndex].name ){
            TESTFCN func = TestTable[tableIndex].fcn;
            b &= func();
            ++tableIndex;
        }
        if (b) {
            std::cout << "\nOK\n\n";
        }
    }else{
       const char* testname = TestTable[tableIndex].name;
       while ( (0 != testname) && (0 != strcmp(testname,argv[1])) ){
          ++tableIndex;
          testname = TestTable[tableIndex].name;
       }

       if (testname != 0){
          TESTFCN func = TestTable[tableIndex].fcn;
          b = func();
       }

       if (b) {
          std::cout << "\nOK\n\n";
       }
    }

    return 0;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 78, 119, 136, 212, 269, 499 and 685.}
\fwendmacronotes
\fwendmacro



\fwsecb{1.13}{Black box tests}

The \fwlit{trip} test.

\fwsecb{1.14}{Beta testing}
...



\fwseca{2}{The platform subsystem}

The first subsystem, \fwlit{platform}, contains two kinds of low-level definitions.
First we gather things that seem likely to depend on the platform.
Hopefully gathering them here will ease porting. Second, we put some things that
don't seem particularly TeX-ish, for example the symbol table.

The platform module consisists of an object file \fwlit{platform.o}
and a test jig \fwlit{platform.t}.


\fwsecb{2.1}{Exceptions}

Here is a base class for all exceptions in our project.  Outsiders
using the library system need only know about this one. Internally we
are free to create derived exceptions.

\fwbeginmacro
\fwmacroname{class TeXException}{9}\fwequals \fwodef \fwbtx[class TeXException {
private:
   const char* m_errorMessage;
public:
   TeXException(const char* msg);
};]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{TeXException implementation}{10}\fwequals \fwodef \fwbtx[TeXException::TeXException(const char* errorMessage)
  : m_errorMessage( errorMessage )
{
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro





\fwsecb{2.2}{Assertions} Assertions have are used to document invariant
conditions in source code, and to enforce these conditions in
debugging code. In release code they are made to vanish. In the program
you write \fwlit{Assert(condition);} and if the condition is true nothing
happens, otherwise an exception is thrown.


\fwbeginmacro
\fwmacroname{Assertions}{11}\fwplusequals \fwodef \fwbtx[#ifdef DEBUG
   #define ASSERT(expr) _Assert(expr,__FILE__,__LINE__, #expr)
   void _Assert(bool assertion, const char* file, int line, const char* expr);
#else
   #define ASSERT(expr)
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 11.}
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assertions imp}{12}\fwequals \fwodef \fwbtx[void _Assert(bool assertion, const char* file, int line, const char* cond)
{
   if (!assertion){
      // log a message that assertion failed and throw an exception
      std::cerr << "\nAssertion fired at line " << line
                  << ", of " << file << ", " << cond << "\n";
      throw TeXException("ASSERTION");
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


Let's add a test to \fwlit{platform.t}. This test will be called
\fwlit{TestAssertions} and externally we'll refer to it as
\fwlit{assert}. Hence, when we type \fwlit{platform.t list} we'll see
\fwlit{assert} on the printed list, and we we type \fwlit{platform.t assert}
this test will run and return either \fwlit{true} or \fwlit{false}.


\fwbeginmacro
\fwmacroname{Platform tests}{13}\fwplusequals \fwodef \fwbtx[bool TestAssertions()
{
    // Test assertions
    try
    {
       ASSERT(1 == 2); // Should fire
       // if we get here it's an error
       return false;
    }
    catch(TeXException e)
    {
       // This should catch the assertion above
    }
    ASSERT(1 != 2); // Should not fire
    return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 13, 18, 23, 35, 49 and 63.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Platform TestTable entries}{14}\fwplusequals \fwodef \fwbtx[
{"assert", TestAssertions},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 14, 19, 24, 36, 50 and 64.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro






\fwsecb{2.3}{Execution logging}

This section defines mechanisms for logging program execution and for
assertions. The static function \fwlit{TheLog} is used to get a reference
to the one and only log file. We can't write \fwlit{LogFile \char`\<\char`\< stuff}. The
alternative would be to write something like
\fwlit{LogFile::operator\char`\<\char`\<(stuff)} and that seems a little ugly.

\fwbeginmacro
\fwmacroname{Execution log}{15}\fwequals \fwodef \fwbtx[#ifdef LOGGING
   struct LogFile {
   public:
       static LogFile& TheLog();
       static void Start();
       static void Close();
       static void Flush();
       friend LogFile& operator<<(LogFile&, const char*);
       friend LogFile& operator<<(LogFile&, char);
       friend LogFile& operator<<(LogFile&, int);
       friend LogFile& operator<<(LogFile&, TeXChar);
   };
   #define LOG(X) LogFile::TheLog() << X; LogFile::Flush()
#else
   #define LOG(X)
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Execution log imp}{16}\fwequals \fwodef \fwbtx[#ifdef LOGGING
   LogFile* s_pLog = 0;
   std::ofstream* s_pStream = 0;

   LogFile& LogFile::TheLog()
   {
      if (s_pLog == 0){
        Start();
      }
      ASSERT(s_pLog != 0);
      return *s_pLog;
   }

   void LogFile::Start()
   {
     ASSERT(s_pLog == 0);
     s_pLog = new LogFile;
     s_pStream = new std::ofstream;
     s_pStream -> open("tex.log");
     ASSERT(s_pLog != 0);
   }

   void LogFile::Close()
   {
      if (s_pStream != 0){
          s_pStream -> close();
          delete s_pStream;
          s_pStream = 0;
      }
      delete s_pLog;
      s_pLog = 0;
   }

   void LogFile::Flush()
   {
      ASSERT(s_pStream != 0);
      s_pStream -> flush();
   }

   LogFile& operator<<(LogFile& f, const char* str)
   {
      (*s_pStream) << str;
      return f;
   }

   LogFile& operator<<(LogFile& f, char ch)
   {
      (*s_pStream) << ch;
      return f;
   }

   LogFile& operator<<(LogFile& f, int n)
   {
      (*s_pStream) << n;
      return f;
   }

   LogFile& operator<<(LogFile& f, TeXChar n)
   {
      if (n <= 255)
         (*s_pStream) << (char) n;
      else
         (*s_pStream) << "mb("
              << (char) (n / 256) << ","
              << (char)(n % 256)  << ")";
      return f;
   }

#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


This utility macro is directly included into each of the
\fwlit{xxx.t.cpp} files as required.


\fwbeginmacro
\fwmacroname{CompareLog utility}{17}\fwmany{}\fwplusequals \fwodef \fwbtx[#include <fstream>
#include <iostream>

bool CompareLog(const char* filename, const char* testname)
{
    // Close the log file and open for writing
    LogFile::Close();
    std::ifstream loginp("tex.log");
    std::ifstream reference(filename);
    int lineNumber = 0;
    bool ok = true;
    while (ok){
       if (reference.eof()){
          if (loginp.eof()){
             return true;
          }else{
             ok = false;
          }
       }else if (loginp.eof()){
          ok = false;
       }else{
          ++lineNumber;
          std::string logline;
          std::string refline;
          std::getline(loginp, logline);
          std::getline(reference, refline);
          if (logline != refline){
             ok = false;
          }
       }
    }
    std::cout << "\nTest failed: " << testname;
    std::cout << "\nInput: " << filename;
    std::cout << "\nLine: " << lineNumber;
    std::cout << "\n\n";
    return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 17.}
\fwusedin{This macro is invoked in definitions 78, 119, 269, 499 and 685.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{Platform tests}{18}\fwplusequals \fwodef \fwbtx[bool TestLoggingFacility()
{
    // Test the logging facility
    LogFile::Start();

    // Log some numbers and constant strings
    int x = 0;
    int y = 1;
    LOG("x=" << x << "\n");
    LOG("y=" << y << "\n");

    // Log some TeXChars
    TeXChar u = 0x0071;  // 'q'
    TeXChar v = 0x3310;  // something not printable (= 13072 decimal)
    LOG("\nu = " << u);
    LOG("\nv = " << v);

    // Log a String

    StringBuilder::Append(L'a');
    StringBuilder::Append(L'b');
    String str = StringBuilder::Create();
    LOG("\nHere's a string: " << str << "\n");

    // Check the results
    bool rv = CompareLog("plat_1.dat", "Platform.TestLoggingFacility");
    return rv;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 13, 18, 23, 35, 49 and 63.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Platform TestTable entries}{19}\fwplusequals \fwodef \fwbtx[{"logging", TestLoggingFacility},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 14, 19, 24, 36, 50 and 64.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro




And the test data file
\fwbeginmacro
\fwfilename{plat\_1.dat}{20}\fwequals \fwodef \fwbtx[x=0
y=1

u = q
v = \u(13072)
Here's a string: ab
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwsecb{2.4}{Bytes and Characters}

There are several character sets running around. First, there is the
character set used to write this C++ program. It is a subset of ASCII
described in, say Stroustrup.

The character set used by the C++ implementation is reflected in type
\fwlit{char}. There are characters used by programs written with the C++
compiler to communicate with external files. We will distinguish this
from the internal character set used by TeX, which we'll call
\fwlit{TeXChar}. This implementation will use Unicode as the internal
set. I.e. \fwlit{TeXChar} = Unicode. These characters are produced by
CharSources. These are the characters tokensized by the
TokenSources. In addition to the system \fwlit{char}s and the internal
\fwlit{TeXChar}s there is also the scheme used to order characters in a
font. This depends on the font.

\fwlit{FontCode} represents a font. It is returned by \fwlit{DVIFilter} when
registering a new font. The \fwlit{FontCode} is then used in subsequent
switches to that font. The \fwlit{CharCode} is a character position in a
font. \fwlit{CharCodes} are used as arguments to the \fwlit{Set} commands.

A \fwlit{Byte} is the smallest addressable piece of memory in the C++
implementation.


\fwbeginmacro
\fwmacroname{Characters}{21}\fwplusequals \fwodef \fwbtx[typedef unsigned char Byte;
typedef unsigned int TeXChar;
typedef int FontCode;
typedef int CharCode;

const unsigned int NUM_TEX_CHARS = 65556;
const unsigned int FIRST_TEX_CHAR = 0;
const unsigned int LAST_TEX_CHAR = 65555;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 21 and 22.}
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro


Here are a couple useful routines:

\fwbeginmacro
\fwmacroname{Characters}{22}\fwplusequals \fwodef \fwbtx[inline Byte HiByte(TeXChar c) { return (Byte)((c & 0xFF00) >> 8); }
inline Byte LoByte(TeXChar c) { return (Byte)(c & 0x00FF);}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 21 and 22.}
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Platform tests}{23}\fwplusequals \fwodef \fwbtx[bool TestLoByteHiByte()
{
    LogFile::Start();
    TeXChar testchar[] = {L'a',0xffff,  L'\n', 0x0000};
    const int NUMCH = 3;
    for (int i = 0; i < NUMCH; ++i){
        TeXChar ch = testchar[i];
        if (i > 0)
          LOG ( "\n" );
        LOG( "(" << ch << " " << HiByte(ch) << " " << LoByte(ch) << ")");
    }
    bool rv = CompareLog("plat_2.dat", "Platform.TestLoByteHiByte");
    return rv;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 13, 18, 23, 35, 49 and 63.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Platform TestTable entries}{24}\fwplusequals \fwodef \fwbtx[{"lohi", TestLoByteHiByte},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 14, 19, 24, 36, 50 and 64.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro



The output of the above should be:
\fwbeginmacro
\fwfilename{plat\_2.dat}{25}\fwequals \fwodef \fwbtx[(a 0 97)
(\u(65535) 255 255)
(\u(10) 0 10)]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro






\fwsecb{2.5}{Strings}

\TeX{} strings have some extra properties that we can use to create
more efficient representations than we might find in
\fwlit{std::string\char`\<TeXChar\char`\>}.  \fwlit{TeXString}'s are never altered or
deleted after they are created. They are used for control sequences
that get entered into a hash table and are never disturbed after that,
and for error messages.  The strings should not be zero-terminated
because it is possible to get a zero into a csname. Therefore a string
will contain a character count. There is only one string under
construction at any given time. Strings are constructed a character at
a time, with characters added one at a time. We have no need for
inserting characters, concatenating, finding substrings, and so on.

When the construction of an object has some twist to it I like to create
a ``factory" class for that object. The factory makes sure that the correct
steps are taken to construct the object. In this case I call the factory
class \fwlit{StringBuilder}.  It has the responsibility of creating strings.

\fwbeginmacro
\fwmacroname{class String}{26}\fwplusequals \fwodef \fwbtx[
class String {
private:
   int m_strNum;

friend class StringBuilder;

public:
   String();
   String(const String&);
   ~String();
   String& operator=(const String&);
   bool operator==(const String&) const;
   bool operator!=(const String&) const;
   TeXChar operator[](int i) const;
   int  Size() const;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 26 and 27.}
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{class String}{27}\fwplusequals \fwodef \fwbtx[   #ifdef LOGGING
   LogFile& operator<<(LogFile& f, const String&);
   #endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 26 and 27.}
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{class StringBuilder}{28}\fwplusequals \fwodef \fwbtx[class StringBuilder {
public:
   static void Append(TeXChar c);
   static String Create();
   static String Create(const char*);
   static void Discard(const String& str);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 28.}
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro


There may be up to 10000 \fwlit{Strings}, and 50000 \fwlit{TeXChar}'s comprising
those strings.

\fwbeginmacro
\fwmacroname{String implementation}{29}\fwplusequals \fwodef \fwbtx[static const int STRING_AREA_SIZE = 50000;
static const int MAX_STRINGS = 10000;
static TeXChar s_stringArea[STRING_AREA_SIZE];
static int s_stringAreaTop = 0;

static int s_stringBegin[MAX_STRINGS];
static int s_currentString = 0;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 29 and 34.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


Now consider constructing a string. We'll let string \fwlit{0} be an
empty string.

\fwbeginmacro
\fwmacroname{StringBuilder implementation}{30}\fwplusequals \fwodef \fwbtx[void StringBuilder::Append(TeXChar c)
{
   if (s_stringAreaTop == STRING_AREA_SIZE){
      LOG("\nERROR - string area exceeded");
      for (int n = 0; n < s_currentString; ++n){
         int len = s_stringBegin[n+1] - s_stringBegin[n];
         int start = s_stringBegin[n];
         int end = s_stringBegin[n+1];
         LOG("\n" << n <<
              "(" << start << " .. " << end-1 << " = " << len<< "):  ");
         for (int m = start; m < end; ++m){
            LOG(s_stringArea[m]);
         }
      }
      throw TeXException("String area overflow");
   }else{
      s_stringArea[s_stringAreaTop++] = c;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 30, 31, 32 and 33.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro







\fwbeginmacro
\fwmacroname{StringBuilder implementation}{31}\fwplusequals \fwodef \fwbtx[String StringBuilder::Create()
{
   String str;
   str.m_strNum = s_currentString;
   ++s_currentString;
   s_stringBegin[s_currentString] = s_stringAreaTop;
   return str;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 30, 31, 32 and 33.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{StringBuilder implementation}{32}\fwplusequals \fwodef \fwbtx[String StringBuilder::Create(const char* cstr)
{
   ASSERT(cstr != 0);
   for (long i = 0; i < (long) strlen(cstr); ++i){
      Append((TeXChar) cstr[i]);
   }
   return Create();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 30, 31, 32 and 33.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


We can remove the string just constructed.
\fwbeginmacro
\fwmacroname{StringBuilder implementation}{33}\fwplusequals \fwodef \fwbtx[void StringBuilder::Discard(const String& str)
{
   ASSERT(str.m_strNum ==  s_currentString-1);
   --s_currentString;
   s_stringAreaTop =  s_stringBegin[s_currentString];
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 30, 31, 32 and 33.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{String implementation}{34}\fwplusequals \fwodef \fwbtx[inline int StartLoc(int str) { return s_stringBegin[str]; }

String::String()
   : m_strNum(-1) // so we don't use this accidentally
{}

String::String(const String& s)
   : m_strNum ( s.m_strNum )
{}

String::~String()
{}

String& String::operator=(const String& right)
{
   m_strNum = right.m_strNum;
   return *this;
}

int String::Size() const
{
   return StartLoc(m_strNum+1) - StartLoc(m_strNum);
}

bool String::operator==(const String& right) const
{
   if (Size() != right.Size())
      return false;

   int leftBegin = s_stringBegin[m_strNum];
   int rightBegin = s_stringBegin[right.m_strNum];

   for (int i = 0; i < Size(); ++i) {
      if (s_stringArea[leftBegin + i] != s_stringArea[rightBegin + i])
         return false;
   }

   return true;
}

bool String::operator!=(const String& right) const
{
   return !(*this == right);
}

TeXChar String::operator[](int i) const
{
   return s_stringArea[StartLoc(m_strNum) + i];
}

#ifdef LOGGING
LogFile& operator<<(LogFile& f, const String& s)
{
   for (int i = 0; i < s.Size(); ++i){
      if (s[i] >= 32 && s[i] <= 126){
         f << s[i];
      } else {
         f << "[chr " << (int) s[i] << "]";
      }
   }
   return f;
}
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 29 and 34.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Platform tests}{35}\fwplusequals \fwodef \fwbtx[bool TestString()
{
    // Test strings

    StringBuilder::Append(L'x');
    StringBuilder::Append(L'y');
    StringBuilder::Append(L'z');
    String foo = StringBuilder::Create();
    ASSERT(foo.Size() == 3 && foo[0] == 'x' && foo[1] == 'y' && foo[2] == 'z');

    // Test an empty string
    String empty1 = StringBuilder::Create();
    String empty2 = StringBuilder::Create("");
    ASSERT(empty1 != foo);
    ASSERT(empty1 == empty2);

    // Test a string with \0 characters
    StringBuilder::Append(L'\0');
    StringBuilder::Append(L'\0');
    StringBuilder::Append(L'x');
    StringBuilder::Append(L'\0');
    String strange = StringBuilder::Create();
    ASSERT(strange.Size() == 4);

    return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 13, 18, 23, 35, 49 and 63.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Platform TestTable entries}{36}\fwplusequals \fwodef \fwbtx[{"string", TestString},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 14, 19, 24, 36, 50 and 64.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro




\fwsecb{2.6}{Paths}

In this section we collect the various paths that the
system needs to know about.

\fwbeginmacro
\fwmacroname{Path declarations}{37}\fwplusequals \fwodef \fwbtx[
void SetCWD();
const char* GetCWD();
bool ChangeDir(const char* dir);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 37.}
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Path implementation}{38}\fwplusequals \fwodef \fwbtx[
static std::string s_CWD;

void SetCWD()
{
   char path[200];
   if (_getcwd(path, 200)){
     LOG("\nCWD = " << path);
     s_CWD = path;
   } else {
     std::cout << "\nCould not set CWD";
     exit(0);
   }
}

const char* GetCWD()
{
   return s_CWD.c_str();
}


bool ChangeDir(const char* dir)
{
   return _chdir(dir);
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 38.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



\fwsecb{2.7}{File names}

One way in which operating systems vary is in the file naming
conventions. We want to encapsulate here any logic involved
in determining the paths and names of files we'll use.

To illustrate the problem consider the \TeX code 

\fwlit{\char`\\input a\char`\\more}

When \TeX starts reading the file name it first sees the character 'a'
which is presumably catcode 11. Now that may or may not be the end of
the name. \TeX has to expand the following macro \fwlit{\char`\\more} to see if
there are any more characters. Thus if \fwlit{\char`\\more} expands to \fwlit{b.tex}
then the file to be input might be \fwlit{ab.tex}. I say might because
there could be a macro following \fwlit{\char`\\more} that needs to be expanded
to see if there are any more characters that belong to the extension.

The member function \fwlit{Accept} takes a character and appends it to the
current filename. It returns true if this succeeds and false
otherwise.  Some characters might not be allowed as part of a
filename. On the other hand the function \fwlit{Finished} returns true if
the filename is complete and no more characters could possibly be
allowed. In that cases there is no need to expand the next macro
looking for characters.

The function \fwlit{GetNameString} is used to fetch a copy of the string
(in terms of \fwlit{char}) that can be used by the file system portion of
the library. You pass in a pointer to a buffer and its length
and it fills it or returns false.

\fwbeginmacro
\fwmacroname{class Filename}{39}\fwequals \fwodef \fwbtx[struct FilenameData;

class Filename {
private:
   FilenameData* m_filenameData;
public:
   Filename();
   Filename(const char*, bool fExternal = false);
   ~Filename();

   bool Accept(TeXChar c, bool fExternal);
   bool Finished() const;
   //bool GetNameString(char*,int) const;
   const char* GetFullName() const;
   const char* GetAreaString() const;
   const char* GetNameString() const;
   const char* GetExtString() const;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro



I'll use a conversion FSA. The conversion will be contained in a data
file with entries of the form
 \ \ \ \ \ \fwlit{pre-state unicode emit
post-state}
 and so on

\fwbeginmacro
\fwmacroname{Filename implementation}{40}\fwplusequals \fwodef \fwbtx[struct FilenameData {
   std::string m_strFullName;
   bool m_bSplit;
   std::string m_strArea;
   std::string m_strName;
   std::string m_strExt;
   int area_delim;
   int ext_delim;

   FilenameData()
   {
      m_bSplit = false;
      area_delim = -1;
      ext_delim = -1;
   }
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 40, 41, 42, 43, 44, 45, 46, 47 and 48.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Filename implementation}{41}\fwplusequals \fwodef \fwbtx[Filename::Filename()
  : m_filenameData(new FilenameData)
{
}

Filename::Filename(const char* name, bool fExternal)
   : m_filenameData(new FilenameData)
{
   ASSERT(name != 0);
   for (int i = 0; i < strlen(name); ++i){
      Accept((TeXChar) name[i], fExternal);
   }
}


Filename::~Filename()
{
   delete m_filenameData;
   m_filenameData = 0;
}

bool Filename::Accept(TeXChar c, bool fExternal)
{
  ASSERT(m_filenameData != 0);

  // Here we have to map unicode character c to the
  // local C++ system charset and append to the file name.
  // For the time being:
  if (HiByte(c) != '\0')
     return false;
// BBM: we have to support spaces in paths when they
// come from outside the TeX file
  if (!fExternal && (c == L' '))
     return false;
  if (c == L'{' || c == '}')
     return false;
  if (c == L'[' || c == ']')
     return false;
  if ((c == L'/')||(fExternal &&(c==L'\\'))) {
     m_filenameData -> area_delim = m_filenameData -> m_strFullName.size();
     c = L'\\';
  }
  if (c == L'.'){
     m_filenameData -> ext_delim = m_filenameData -> m_strFullName.size();
  }

  m_filenameData -> m_strFullName += LoByte(c);
  return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 40, 41, 42, 43, 44, 45, 46, 47 and 48.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Filename implementation}{42}\fwplusequals \fwodef \fwbtx[void SplitFilename(FilenameData* pfd){
   ASSERT(pfd != 0);
   if (!pfd -> m_bSplit) {
      const std::string& str = pfd -> m_strFullName;
      int len = str.length();
      ASSERT(len > 0);
      int name_pos;
      int name_len;

      if (pfd -> area_delim == -1){
          // No area specified
          pfd -> m_strArea = "";
          name_pos = 0;
      } else {
          int area_len = pfd -> area_delim;
          pfd -> m_strArea = str.substr(0, area_len);
          name_pos = 1 + area_len;
      }

      if (pfd -> ext_delim == -1){
          // No extension
          pfd -> m_strExt = "";
          name_len = len - name_pos;
      } else {
          int ext_pos  = 1 + pfd -> ext_delim;
          int ext_len = len - ext_pos;
          pfd -> m_strExt = str.substr(ext_pos, ext_len);
          name_len = pfd -> ext_delim - name_pos;
      }

      if (name_len > 0)
         pfd -> m_strName = str.substr(name_pos, name_len);

      pfd -> m_bSplit = true;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 40, 41, 42, 43, 44, 45, 46, 47 and 48.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Filename implementation}{43}\fwplusequals \fwodef \fwbtx[std::string CatFilename(const char* area,
                        const char* name,
                        const char* ext,
                        bool bSubst)
{
   std::string full;
   if (area != 0 && strlen(area) != 0){
     full += area;
     full += "\\";
   }
   if (bSubst) full += "msi-";
   full += name;
   if (ext != 0 && strlen(ext) != 0){
     full += ".";
     full += ext;
   }
   return full;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 40, 41, 42, 43, 44, 45, 46, 47 and 48.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Filename implementation}{44}\fwplusequals \fwodef \fwbtx[bool Filename::Finished() const
{
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 40, 41, 42, 43, 44, 45, 46, 47 and 48.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Filename implementation}{45}\fwplusequals \fwodef \fwbtx[const char* Filename::GetFullName() const
{
   ASSERT(m_filenameData != 0);
   return m_filenameData -> m_strFullName.c_str();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 40, 41, 42, 43, 44, 45, 46, 47 and 48.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Filename implementation}{46}\fwplusequals \fwodef \fwbtx[const char* Filename::GetAreaString() const
{
   ASSERT(m_filenameData != 0);
   SplitFilename(m_filenameData);
   return m_filenameData -> m_strArea.c_str();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 40, 41, 42, 43, 44, 45, 46, 47 and 48.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



Should each file *have* a filename?

I don't wnat to declare len to be unsigned in the interface (?),
hence the assertion in the second line of this function.x

\fwbeginmacro
\fwmacroname{Filename implementation}{47}\fwplusequals \fwodef \fwbtx[const char* Filename::GetNameString() const
{
   ASSERT(m_filenameData != 0);
   SplitFilename(m_filenameData);
   return m_filenameData -> m_strName.c_str();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 40, 41, 42, 43, 44, 45, 46, 47 and 48.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Filename implementation}{48}\fwplusequals \fwodef \fwbtx[const char* Filename::GetExtString() const
{
   ASSERT(m_filenameData != 0);
   SplitFilename(m_filenameData);
   return m_filenameData -> m_strExt.c_str();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 40, 41, 42, 43, 44, 45, 46, 47 and 48.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Platform tests}{49}\fwplusequals \fwodef \fwbtx[bool TestFilename()
{
    // Test filenames
    Filename fn;

    const char* uni = "testfilename.dat";
    for(unsigned int i = 0; i < strlen(uni); ++i){
      if (!fn.Accept((TeXChar, false)(uni[i]))){
         break;
      }
    }
    char buf[50];
    fn.GetNameString(buf, 50);
    if (strcmp(buf,uni) == 0)
       return true;
    else
       return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 13, 18, 23, 35, 49 and 63.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Platform TestTable entries}{50}\fwplusequals \fwodef \fwbtx[{"filename", TestFilename},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 14, 19, 24, 36, 50 and 64.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro




\fwsecb{2.8}{Input Byte streams}

At the lowest level this implementation reads from files
as though the file was a sequence of bytes. In other words,
a binary file. This is because we want control over how
the data is interpretted once read. We'll pass the bytes
through filters to produce a stream of characters and we
don't trust the library functions like \fwlit{fgets} to do this
correctly. Suppose the file is somehow encoded, say UTF-7
or wahtever, and that a line end character \fwlit{'\char`\\n'} occurs
as the second byte of a multi byte character.

\fwbeginmacro
\fwmacroname{class InputByteStream}{51}\fwequals \fwodef \fwbtx[class InputByteStream {
public:
   virtual ~InputByteStream();
   virtual bool bEOS() const = 0; // End of stream?
   virtual Byte Get() = 0;
protected:
   InputByteStream();
private:
   // Do not implement
   InputByteStream(const InputByteStream&);
   InputByteStream& operator=(const InputByteStream&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{InputByteStream implementation}{52}\fwequals \fwodef \fwbtx[InputByteStream::InputByteStream()
{}

InputByteStream::~InputByteStream()
{}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



\fwsecb{2.9}{Output Byte streams}


\fwbeginmacro
\fwmacroname{class OutputByteStream}{53}\fwequals \fwodef \fwbtx[class OutputByteStream {
public:
   virtual ~OutputByteStream();
   virtual bool bEOS() const = 0; // End of stream?
   virtual void Put(Byte) = 0;
   virtual void Write(String& str) = 0;
protected:
   OutputByteStream();
private:
   // Do not implement
   OutputByteStream(const OutputByteStream&);
   OutputByteStream& operator=(const OutputByteStream&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{OutputByteStream implementation}{54}\fwplusequals \fwodef \fwbtx[OutputByteStream::OutputByteStream()
{}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 54 and 55.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{OutputByteStream implementation}{55}\fwplusequals \fwodef \fwbtx[OutputByteStream::~OutputByteStream()
{}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 54 and 55.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro




\fwsecb{2.10}{Input Byte files}

One source of \fwlit{Byte}s is of course a file.

In this class the type \fwlit{InputByteFileData} is used to hide implementation
detail.

\fwbeginmacro
\fwmacroname{class InputByteFiles}{56}\fwequals \fwodef \fwbtx[struct InputByteFileData;

class InputByteFile : public InputByteStream{
private:
   InputByteFileData* m_byteFileData;
public:
   InputByteFile();
   ~InputByteFile();
   bool Open(const Filename&);
   bool bEOS() const;
   Byte Get();
private:
   InputByteFile(const InputByteFile&);
   InputByteFile& operator=(const InputByteFile&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro


Next consider the implementation of \fwlit{InputByteFile}. We define a class
\fwlit{InputByteFileData} that holds a pointer to a file. It also has a one-
character buffer that holds the next character. I do this because
I have to get the next character before deciding whether I'm at the
end of file.

\fwbeginmacro
\fwmacroname{InputByteFile implementation}{57}\fwplusequals \fwodef \fwbtx[struct InputByteFileData{
   std::ifstream m_file;
   std::string   m_filename;
   int           m_lineno;
   Byte m_buf;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 57, 58, 59, 60, 61 and 62.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


For debugging purposees we keep track of the current
file and line number.



Construction and deletion are simply a matter
of opening and closing the file.

\fwbeginmacro
\fwmacroname{InputByteFile implementation}{58}\fwplusequals \fwodef \fwbtx[InputByteFile::InputByteFile()
{
   // The TeXChar string name has to be converted
   // to a char* type name
   m_byteFileData = new InputByteFileData;
   ASSERT(m_byteFileData != 0);

}

InputByteFile::~InputByteFile()
{
   ASSERT(m_byteFileData != 0);
   m_byteFileData -> m_file.close();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 57, 58, 59, 60, 61 and 62.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{InputByteFile implementation}{59}\fwplusequals \fwodef \fwbtx[const char* SearchFor(const char* searchfile)
{
   // Search for file in MSITEXINPUT environment variable

   static char pathbuffer[_MAX_PATH];
   char envvar[] = "MSITEXINPUT";

   _searchenv( searchfile, envvar, pathbuffer );
   if( *pathbuffer != '\0' ){
      LOG("\nPath for " << searchfile << " == " << pathbuffer);
      return pathbuffer;
   } else {
      LOG("\nDid not find path for " << searchfile);
      return(0);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 57, 58, 59, 60, 61 and 62.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{InputByteFile implementation}{60}\fwplusequals \fwodef \fwbtx[bool InputByteFile::Open(const Filename& fullpath){

   m_byteFileData -> m_filename = fullpath.GetFullName();
   m_byteFileData -> m_lineno = 1;

   const char* area = fullpath.GetAreaString();
   const char* name = fullpath.GetNameString();
   const char* ext  = fullpath.GetExtString();
   if (strcmp(ext,"") == 0){
     ext = "tex";
   }

   std::string filepath = CatFilename(area, name, ext, true);
   const char* path = SearchFor(filepath.c_str());
   if (path == 0){
      filepath = CatFilename(area, name, ext, false);
      path = SearchFor(filepath.c_str());
      if (path == 0){
         LOG("\nFailed to locate " << filepath.c_str());
         std::cout << "\nNo coverage: " << filepath.c_str();
         return false;
      } else {
         LOG("\nFound file"<< filepath.c_str());
      }
   } else {
      LOG("\nFound substitute file" << filepath.c_str());
   }
   m_byteFileData -> m_file.open(path, std::ios::in | std::ios::binary);
   if ( ! m_byteFileData -> m_file.is_open() ){
      LOG("\nFailed to open " << path);
      return false;
   }
   LOG("\nOpened for reading: " << filepath.c_str());
   // Get the first byte into the buffer
   m_byteFileData -> m_buf =  m_byteFileData -> m_file.get();
   return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 57, 58, 59, 60, 61 and 62.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


Next we have \fwlit{bEOS()}.

\fwbeginmacro
\fwmacroname{InputByteFile implementation}{61}\fwplusequals \fwodef \fwbtx[bool InputByteFile::bEOS() const
{
   ASSERT(m_byteFileData != 0);
   return (!m_byteFileData -> m_file.is_open()) ||
          (m_byteFileData -> m_file.eof());
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 57, 58, 59, 60, 61 and 62.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{InputByteFile implementation}{62}\fwplusequals \fwodef \fwbtx[Byte InputByteFile::Get()
{
   ASSERT(m_byteFileData != 0);
   Byte result =  m_byteFileData -> m_buf;
   m_byteFileData -> m_buf =  m_byteFileData -> m_file.get();
   if (result == '\n'){
     LOG("\nFinished " << "file: "  << m_byteFileData -> m_filename.c_str()
                 << ", line " << m_byteFileData -> m_lineno);
     m_byteFileData -> m_lineno++;
   }
   return result;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 57, 58, 59, 60, 61 and 62.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Platform tests}{63}\fwplusequals \fwodef \fwbtx[bool TestInputByteFile()
{
    LogFile::Start();
    try
    {
       // Try opening a non-existent file
       InputByteFile bfile1;
       Filename fn1("zzzzz.dat");
       ASSERT( !bfile1.Open(fn1));

       // Open an empty file and check for eof
       InputByteFile bfile2;
       Filename fn2("empty.dat");
       ASSERT(bfile2.Open(fn2));
       ASSERT(bfile2.bEOS());

       // Normal case
       InputByteFile bfile3;
       Filename fn3("bfiletest1.dat");
       ASSERT(bfile3.Open(fn3));
       while (!bfile3.bEOS()){
          Byte b = bfile3.Get();
          LOG(b << ' ');
       }
       ASSERT(CompareLog("bfiletest1.log", "Platform.TestByteFile"));
    }
    catch(...)
    {
       return false;
    }
    return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 13, 18, 23, 35, 49 and 63.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Platform TestTable entries}{64}\fwplusequals \fwodef \fwbtx[{"inputbytefile", TestInputByteFile},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 14, 19, 24, 36, 50 and 64.}
\fwusedin{This macro is invoked in definition 78.}
\fwendmacronotes
\fwendmacro



Here is the test data

\fwbeginmacro
\fwfilename{empty.dat}{65}\fwequals \fwodef \fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{bfiletest1.dat}{66}\fwequals \fwodef \fwbtx[Line1
Line2]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


Here is the result of the Normal case test above.
\fwbeginmacro
\fwfilename{bfiletest1.log}{67}\fwequals \fwodef \fwbtx[76 105 110 101 49 ]fwetx=%
\fwmacroname{LineEnd}{5}\fwbtx[ 76 105 110 101 50 ]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwsecb{2.11}{Output Byte files}
\fwbeginmacro
\fwmacroname{class OutputByteFiles}{68}\fwequals \fwodef \fwbtx[struct OutputByteFileData;

class OutputByteFile : public OutputByteStream{
private:
   OutputByteFileData* m_byteFileData;
public:
   OutputByteFile();
   ~OutputByteFile();
   bool Open(const Filename&);
   bool bEOS() const;
   void Put(Byte);
   void Write(String& str);
private:
   OutputByteFile(const OutputByteFile&);
   OutputByteFile& operator=(const OutputByteFile&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 76.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{OutputByteFile implementation}{69}\fwplusequals \fwodef \fwbtx[struct OutputByteFileData{
   std::ofstream m_file;
   std::string   m_filename;
   int           m_lineno;
   Byte m_buf;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 69, 70, 71, 72, 73, 74 and 75.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{OutputByteFile implementation}{70}\fwplusequals \fwodef \fwbtx[OutputByteFile::OutputByteFile()
{
   m_byteFileData = new OutputByteFileData;
   ASSERT(m_byteFileData != 0);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 69, 70, 71, 72, 73, 74 and 75.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{OutputByteFile implementation}{71}\fwplusequals \fwodef \fwbtx[OutputByteFile::~OutputByteFile()
{
   delete m_byteFileData;
}


const char* SearchForOutput(const char* searchfile)
{
   // Search for file in MSIOUTPUT environment variable

   static char pathbuffer[_MAX_PATH];
   char envvar[] = "MSIOUTPUT";

   _searchenv( searchfile, envvar, pathbuffer );
   if( *pathbuffer != '\0' ){
      LOG("\nPath for " << searchfile << " == " << pathbuffer);
      return pathbuffer;
   } else {
      LOG("\nDid not find path for " << searchfile);
      return(0);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 69, 70, 71, 72, 73, 74 and 75.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{OutputByteFile implementation}{72}\fwplusequals \fwodef \fwbtx[bool OutputByteFile::Open(const Filename& fullpath)
{
   m_byteFileData -> m_filename = fullpath.GetFullName();
   m_byteFileData -> m_lineno = 1;

   const char* area = fullpath.GetAreaString();
   const char* name = fullpath.GetNameString();
   const char* ext  = fullpath.GetExtString();
   if (strcmp(ext,"") == 0){
     ext = "tex";
   }

   std::string filepath = CatFilename(area, name, ext, false);
   const char* path = SearchForOutput(filepath.c_str());
   if (path == 0){
      LOG("\nFailed to locate " << filepath.c_str());
      path = filepath.c_str();
      // BBM: we want to create the file if it doesn't exist
      // return false;
   }
   m_byteFileData -> m_file.open(path, std::ios::out
     | std::ios::binary | std::ios::app );
   if ( ! m_byteFileData -> m_file.is_open() ){
      LOG("\nFailed to open " << path);
      return false;
   }
   LOG("\nOpened for writing: " << filepath.c_str());

   return true;

}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 69, 70, 71, 72, 73, 74 and 75.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{OutputByteFile implementation}{73}\fwplusequals \fwodef \fwbtx[bool OutputByteFile::bEOS() const
{
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 69, 70, 71, 72, 73, 74 and 75.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{OutputByteFile implementation}{74}\fwplusequals \fwodef \fwbtx[void OutputByteFile::Put(Byte b)
{
    m_byteFileData -> m_file.put(b);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 69, 70, 71, 72, 73, 74 and 75.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{OutputByteFile implementation}{75}\fwplusequals \fwodef \fwbtx[void OutputByteFile::Write(String& str)
{
   for (int i = 0; i < str.Size(); ++i){
     Put(str[i]);
   }
   Put('\n');
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 69, 70, 71, 72, 73, 74 and 75.}
\fwusedin{This macro is invoked in definition 77.}
\fwendmacronotes
\fwendmacro








\fwsecb{2.12}{Arithmetic}

\TeX{} requires platform independent arithmetic for several
computations.  The necessary routines are described here.



\fwsecb{2.13}{Physical layout}

\fwbeginmacro
\fwfilename{platform.h}{76}\fwequals \fwodef \fwbtx[#ifndef PLATFORM_H
#define PLATFORM_H

#pragma warning(disable : 4786)
#include <cwchar>
]fwetx=%
\fwmacroname{class TeXException}{9}\fwbtx[
]fwetx=%
\fwmacroname{Assertions}{11}\fwbtx[
]fwetx=%
\fwmacroname{Characters}{21}\fwbtx[
]fwetx=%
\fwmacroname{Execution log}{15}\fwbtx[
]fwetx=%
\fwmacroname{class String}{26}\fwbtx[
]fwetx=%
\fwmacroname{class StringBuilder}{28}\fwbtx[
]fwetx=%
\fwmacroname{class Filename}{39}\fwbtx[
]fwetx=%
\fwmacroname{class InputByteStream}{51}\fwbtx[
]fwetx=%
\fwmacroname{class OutputByteStream}{53}\fwbtx[
]fwetx=%
\fwmacroname{class InputByteFiles}{56}\fwbtx[
]fwetx=%
\fwmacroname{class OutputByteFiles}{68}\fwbtx[
]fwetx=%
\fwmacroname{Path declarations}{37}\fwbtx[
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{platform.cpp}{77}\fwequals \fwodef \fwbtx[#include "platform.h"
#include <fstream>
#include <iostream>
#include <cstdlib>
#include <string>
#include <limits.h>
#include <direct.h>
]fwetx=%
\fwmacroname{TeXException implementation}{10}\fwbtx[
]fwetx=%
\fwmacroname{Execution log imp}{16}\fwbtx[
]fwetx=%
\fwmacroname{Assertions imp}{12}\fwbtx[
]fwetx=%
\fwmacroname{String implementation}{29}\fwbtx[
]fwetx=%
\fwmacroname{StringBuilder implementation}{30}\fwbtx[
]fwetx=%
\fwmacroname{InputByteStream implementation}{52}\fwbtx[
]fwetx=%
\fwmacroname{OutputByteStream implementation}{54}\fwbtx[
]fwetx=%
\fwmacroname{Filename implementation}{40}\fwbtx[
]fwetx=%
\fwmacroname{InputByteFile implementation}{57}\fwbtx[
]fwetx=%
\fwmacroname{OutputByteFile implementation}{69}\fwbtx[
]fwetx=%
\fwmacroname{Path implementation}{38}\fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro




Finally here's the testjig:
\fwbeginmacro
\fwfilename{platform.t.cpp}{78}\fwequals \fwodef \fwbtx[#include "platform.h"
#include <string>
]fwetx=%
\fwmacroname{CompareLog utility}{17}\fwbtx[

]fwetx=%
\fwmacroname{Test jig}{8}\fwoparen \fwoquote\fwmacroname{Platform tests}{13}\fwcquote\fwcomma \fwoquote\fwmacroname{Platform TestTable entries}{14}\fwcquote\fwcparen \fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro














\fwseca{3}{The Text IO Subsystem}

\fwsecb{3.1}{Interface}

In the last section we implemented binary file IO ans abstracted a
\fwlit{BinaryStream} class. In this section we'll implement text IO.

A \TeX program consists of a sequence of lines of text. The end of
line marks are important in that every token is contained in a line.

Up to 16 files may be open at one time and it may be necessary to read
until matched braces are found. However, this input is atomic.  On
command an entire line is read and tokenized. The tokens are not
expanded It is not suspended. On the other hand, reading and executing
instructions from the main input is not atomic. It may be suspended
and continued later. Thus you will read a few tokens, execute some
commands, and then read some more, in a loop.

The Text IO Subsystem handles file processing. Files are identified by
a filename. A filename is a string of Unicode. We could also use URLs.
It is system dependent how this string is used to identify a file.
\TeX is line-oriented in its IO and so the functions here provide for
reading and writing lines of text only. A line of text is represented
by the class \fwlit{LineOfText}. Files are text. This subsystem has to
scan bytes for characters and line ends (which are system
dependent). So each file/stream has an associated character encoding
scheme. The encoding scheme is represented by the class
\fwlit{CharStream}. A \fwlit{CharStream} takes a \fwlit{InputByteStream} and translates
it into \fwlit{TeXChar}'s (i.e. unicode characters). This is an abstract
class of which the primary concrete derived class is
\fwlit{Latin1}. \fwlit{Latin1} assumes the byte stream is encoded in
ISO-Latin-1 and produces unicode charaters appropriately.

\fwbeginmacro
\fwmacroname{IOSys interface}{79}\fwequals \fwodef \fwbtx[struct IOSys {
   // Used for \input files
   static bool bInput(TeXChar* name);
   static bool bRead(LineOfText*);
   static bool bClose();
   //static void SetInputEncoding(ByteToTeXChar&);

   // Used by \read and \write
   static bool bOpenIn(int n, TeXChar* name);
   static bool bCloseIn(int n);
   //static void SetInputEncoding(int n, ByteToTeXChar&);
   static bool bReadIn(int n, LineOfText* buf);
   static bool bOpenOut(int n, TeXChar* name);
   static bool bCloseOut(int n);
   static bool bWriteOut(int n, const LineOfText* buf);
   //static void SetOutputEncoding(int n, ByteToTeXChar&);

   static int s_endlinechar;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 117.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{static data}{80}\fwplusequals \fwodef \fwbtx[int IOSys::s_endlinechar;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 80.}
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro


Here are the test jig macros. The test jig in this case is called
\fwlit{textio.t}.

\fwbeginmacro
\fwmacroname{Textio tests}{81}\fwplusequals \fwodef \fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 81, 89, 103 and 112.}
\fwusedin{This macro is invoked in definition 119.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Textio TestTable}{82}\fwplusequals \fwodef \fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 82, 90, 104 and 113.}
\fwusedin{This macro is invoked in definition 119.}
\fwendmacronotes
\fwendmacro



\fwsecb{3.2}{Lines of Text}

\fwsecc{3.2.1}{Interface}
Here is a class that represents a line of text.

\fwbeginmacro
\fwmacroname{class LineOfText}{83}\fwplusequals \fwodef \fwbtx[struct LineOfTextData;

class LineOfText {
private:
   LineOfTextData* m_lineData;
public:
   LineOfText();
   ~LineOfText();
   int     nSize() const;
   bool    bEmpty() const;
   void    Clear();
   void    Append(TeXChar c); // Add to end of line
   TeXChar chGet();
   void    Putback(TeXChar c);
   int     nRemaining() const; // How many chars left in line?
   TeXChar chPeek(int n = 0);   // Peek ahead n chars
   void    SkipToEnd();
   TeXChar operator[](int) const;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 83 and 84.}
\fwusedin{This macro is invoked in definition 117.}
\fwendmacronotes
\fwendmacro
;



Finally, let's add a logging aid.
\fwbeginmacro
\fwmacroname{class LineOfText}{84}\fwplusequals \fwodef \fwbtx[#ifdef LOGGING
   LogFile& operator<<(LogFile& f, const LineOfText& t);
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 83 and 84.}
\fwusedin{This macro is invoked in definition 117.}
\fwendmacronotes
\fwendmacro



\fwsecc{3.2.2}{Implementation}
\fwbeginmacro
\fwmacroname{LineOfText implementation}{85}\fwplusequals \fwodef \fwbtx[const unsigned int INITIAL_LINE_SIZE = 0;
const TeXChar FILL_CHAR = 0x0020;

struct LineOfTextData {

   std::basic_string<TeXChar> m_line;
   // std::basic_string<TeXChar>::iterator m_cursor;
   int m_cursor;

   LineOfTextData()
      : m_line(INITIAL_LINE_SIZE, FILL_CHAR),
        m_cursor(0)
        // m_cursor(m_line.begin())
   {}
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 85, 86, 87 and 88.}
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{LineOfText implementation}{86}\fwplusequals \fwodef \fwbtx[
LineOfText::LineOfText()
   : m_lineData(new LineOfTextData)
{
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 85, 86, 87 and 88.}
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{LineOfText implementation}{87}\fwplusequals \fwodef \fwbtx[
LineOfText::~LineOfText()
{
   delete m_lineData;
   m_lineData = 0;
}

void LineOfText::Clear()
{
   m_lineData -> m_cursor = 0;
   m_lineData -> m_line.resize(0);
}

TeXChar LineOfText::operator[](int i) const
{
   return m_lineData -> m_line[i];
}

int  LineOfText::nSize() const
{
   return m_lineData -> m_line.size();
}

void LineOfText::SkipToEnd()
{
   m_lineData -> m_cursor = m_lineData -> m_line.size();
}

bool LineOfText::bEmpty() const
{
   ASSERT(m_lineData != 0);
   return ( (m_lineData -> m_cursor) == (int)(m_lineData -> m_line.length()) );
}

void LineOfText::Append(TeXChar c)
{
   ASSERT(m_lineData != 0);
   m_lineData -> m_line += c;
}

TeXChar LineOfText::chGet()
{
   return m_lineData -> m_line[m_lineData -> m_cursor++];
}

void LineOfText::Putback(TeXChar c)
{
   m_lineData -> m_cursor--;
   m_lineData -> m_line[m_lineData -> m_cursor] = c;
}

int LineOfText::nRemaining() const
{
   ASSERT(m_lineData != 0);
   return ( (m_lineData -> m_line.length()) - (m_lineData -> m_cursor) );
}

TeXChar LineOfText::chPeek(int n /* = 0*/)
{
   return m_lineData -> m_line[m_lineData -> m_cursor + n];
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 85, 86, 87 and 88.}
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{LineOfText implementation}{88}\fwplusequals \fwodef \fwbtx[#ifdef LOGGING
   LogFile& operator<<(LogFile& f, const LineOfText& t)
   {
       for (int i = 0; i < t.nSize(); ++i){
           f << t[i];
       }

       return f;
   }
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 85, 86, 87 and 88.}
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro





\fwsecc{3.2.3}{Tests}

\fwbeginmacro
\fwmacroname{Textio tests}{89}\fwplusequals \fwodef \fwbtx[bool TestLineOfText()
{
   try
   {
      // Test LineOfText
      LineOfText line;
      ASSERT(line.nRemaining() == 0);
      line.Append('a');
      line.Append('b');
      line.Append('c');
      ASSERT(line.nRemaining() == 3);
      TeXChar ch = line.chGet();
      ASSERT(ch == 'a');
      ASSERT(line.nRemaining() == 2);
      ASSERT(line.chPeek(0) == 'b');
      ASSERT(line.chPeek(1) == 'c');
      line.Putback('k');
      ASSERT(line.chPeek(0) == 'k');
      ASSERT(line.nRemaining() == 3);
   }
   catch(...)
   {
      return false;
   }
   return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 81, 89, 103 and 112.}
\fwusedin{This macro is invoked in definition 119.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Textio TestTable}{90}\fwplusequals \fwodef \fwbtx[{"lines", TestLineOfText},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 82, 90, 104 and 113.}
\fwusedin{This macro is invoked in definition 119.}
\fwendmacronotes
\fwendmacro




\fwsecb{3.3}{Converting Bytes to TeXChars}

The byte streams will often be interpretted as text.  There are two
aspects to this. First, how are the bytes converted to characters, and
second, what charcter pattern represents the end of a line? The
details depend on how the binary data is encoded. There is also the
question of how to interpret line ends. Therefore we have the classes:


\fwbeginmacro
\fwmacroname{class CharStream}{91}\fwequals \fwodef \fwbtx[class CharStream{
public:
   virtual ~CharStream();
   virtual TeXChar Get() = 0;
   virtual bool bEOS() = 0;
   virtual void Putback(TeXChar) = 0;
protected:
   CharStream();
private:
   // Do not implement these!
   CharStream(const CharStream&);
   CharStream& operator=(const CharStream&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 117.}
\fwendmacronotes
\fwendmacro


Observe that the constructor is protected. This means that you're not
allowed to construct one directly. This class can only be constructed
by derived classes. Also observe that the copy constructor and
assignment operator are private. I don't think we ever want to copy
or assign these and this decision is formalized in the code.

It is an assumption that a byte stream has just one character
encoding.  If this is not true, for example some types of
multi-language writing might have portions of a document written in
different encodings, then a \fwlit{CharStream} might be written that can
switch between encodings. But I think that it would be better to
write in straight unicode in that case.


\fwbeginmacro
\fwmacroname{CharStream implementation}{92}\fwequals \fwodef \fwbtx[CharStream::CharStream()
{
}

CharStream::~CharStream()
{
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro



Here is a derived class that converts ISO-Latin-1 encoded files to
Unicode. We'll have other derived classes for Latin-2, ..., UTF-8,
UTF-7, and so forth.

Perhaps there whould be a class \fwlit{Filter} that contains both translation
directions. Then we'd write lines like

\ \ \ \ \ \fwlit{Unicode c = Latin\_1.Get()}

\ \ \ \ \ \fwlit{Latin\_1.Put(c)}

\fwbeginmacro
\fwmacroname{class Latin\_1\_in}{93}\fwequals \fwodef \fwbtx[class Latin_1_in : public CharStream{
private:
   InputByteStream& m_InputByteStream;
public:
   Latin_1_in(InputByteStream&);
   TeXChar Get();
   bool bEOS();
   void Putback(TeXChar);
private:
   // Unimplemented
   Latin_1_in(const Latin_1_in&);
   Latin_1_in& operator=(const Latin_1_in&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 117.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Latin\_1\_in implementation}{94}\fwequals \fwodef \fwbtx[Latin_1_in::Latin_1_in(InputByteStream& bs)
   : m_InputByteStream(bs)
{
}


bool Latin_1_in::bEOS()
{
   return m_InputByteStream.bEOS();
}

TeXChar Latin_1_in::Get()
{
   ASSERT(!bEOS());
   Byte b = m_InputByteStream.Get();
   // We'll ignore 0D characters
   if (b == 0x0d){
     b = m_InputByteStream.Get();
   }
   return b;
}


void Latin_1_in::Putback(TeXChar c)
{
   ASSERT(false);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro



Here is a derived class that converts codepage 932 to
Unicode.

\fwbeginmacro
\fwmacroname{class Codepage932\_in}{95}\fwequals \fwodef \fwbtx[class Codepage932_in : public CharStream{
private:
   InputByteStream& m_InputByteStream;
public:
   Codepage932_in(InputByteStream&);
   TeXChar Get();
   bool bEOS();
   void Putback(TeXChar);
private:
   // Unimplemented
   Codepage932_in(const Codepage932_in&);
   Codepage932_in& operator=(const Codepage932_in&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 117.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Codepage932\_in implementation}{96}\fwequals \fwodef \fwbtx[Codepage932_in::Codepage932_in(InputByteStream& bs)
   : m_InputByteStream(bs)
{
}


bool Codepage932_in::bEOS()
{
   return m_InputByteStream.bEOS();
}

TeXChar Codepage932_in::Get()
{
   ASSERT(!bEOS());
   TeXChar ch;
   Byte b = m_InputByteStream.Get();
   // We'll ignore 0D characters
   if (b == 0x0d){
     b = m_InputByteStream.Get();
   }

   if (b < 0x80 || (b >= 0xa0 && b < 0xe0)){
     ch = b;
   } else {
     ch = b*256;
     b = m_InputByteStream.Get();
     ch += b;
   }

   return ch;
}


void Codepage932_in::Putback(TeXChar c)
{
   ASSERT(false);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro





Here is a derived class that scans codepage 936.

\fwbeginmacro
\fwmacroname{class Codepage936\_in}{97}\fwequals \fwodef \fwbtx[class Codepage936_in : public CharStream{
private:
   InputByteStream& m_InputByteStream;
public:
   Codepage936_in(InputByteStream&);
   TeXChar Get();
   bool bEOS();
   void Putback(TeXChar);
private:
   // Unimplemented
   Codepage936_in(const Codepage936_in&);
   Codepage936_in& operator=(const Codepage936_in&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 117.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Codepage936\_in implementation}{98}\fwequals \fwodef \fwbtx[Codepage936_in::Codepage936_in(InputByteStream& bs)
   : m_InputByteStream(bs)
{
}


bool Codepage936_in::bEOS()
{
   return m_InputByteStream.bEOS();
}

TeXChar Codepage936_in::Get()
{
   ASSERT(!bEOS());
   TeXChar ch;
   Byte b = m_InputByteStream.Get();
   // We'll ignore 0D characters
   if (b == 0x0d){
     b = m_InputByteStream.Get();
   }

   if (b < 0xa0){
     ch = b;
   } else {
     ch = b*256;
     b = m_InputByteStream.Get();
     ch += b;
   }

   return ch;
}


void Codepage936_in::Putback(TeXChar c)
{
   ASSERT(false);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro




Here is a derived class that scans codepage 949.

\fwbeginmacro
\fwmacroname{class Codepage949\_in}{99}\fwequals \fwodef \fwbtx[class Codepage949_in : public CharStream{
private:
   InputByteStream& m_InputByteStream;
public:
   Codepage949_in(InputByteStream&);
   TeXChar Get();
   bool bEOS();
   void Putback(TeXChar);
private:
   // Unimplemented
   Codepage949_in(const Codepage949_in&);
   Codepage949_in& operator=(const Codepage949_in&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 117.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Codepage949\_in implementation}{100}\fwequals \fwodef \fwbtx[Codepage949_in::Codepage949_in(InputByteStream& bs)
   : m_InputByteStream(bs)
{
}


bool Codepage949_in::bEOS()
{
   return m_InputByteStream.bEOS();
}

TeXChar Codepage949_in::Get()
{
   ASSERT(!bEOS());
   TeXChar ch;
   Byte b = m_InputByteStream.Get();
   // We'll ignore 0D characters
   if (b == 0x0d){
     b = m_InputByteStream.Get();
   }

   if (b < 0x80){
     ch = b;
   } else {
     ch = b*256;
     b = m_InputByteStream.Get();
     ch += b;
   }

   return ch;
}


void Codepage949_in::Putback(TeXChar c)
{
   ASSERT(false);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro




Here is a derived class that scans codepage 950.

\fwbeginmacro
\fwmacroname{class Codepage950\_in}{101}\fwequals \fwodef \fwbtx[class Codepage950_in : public CharStream{
private:
   InputByteStream& m_InputByteStream;
public:
   Codepage950_in(InputByteStream&);
   TeXChar Get();
   bool bEOS();
   void Putback(TeXChar);
private:
   // Unimplemented
   Codepage950_in(const Codepage950_in&);
   Codepage950_in& operator=(const Codepage950_in&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 117.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Codepage950\_in implementation}{102}\fwequals \fwodef \fwbtx[Codepage950_in::Codepage950_in(InputByteStream& bs)
   : m_InputByteStream(bs)
{
}


bool Codepage950_in::bEOS()
{
   return m_InputByteStream.bEOS();
}

TeXChar Codepage950_in::Get()
{
   ASSERT(!bEOS());
   TeXChar ch;
   Byte b = m_InputByteStream.Get();
   // We'll ignore 0D characters
   if (b == 0x0d){
     b = m_InputByteStream.Get();
   }

   if (b < 0xa0){
     ch = b;
   } else {
     ch = b*256;
     b = m_InputByteStream.Get();
     ch += b;
   }

   return ch;
}


void Codepage950_in::Putback(TeXChar c)
{
   ASSERT(false);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro





\fwsecc{3.3.1}{Tests}

Since ISO-Latin-1 maps so simply into Unicode there is
not much to test here.

\fwbeginmacro
\fwmacroname{Textio tests}{103}\fwplusequals \fwodef \fwbtx[bool TestLatin1()
{
   // With an empty file
   InputByteFile bfile1;
   bfile1.Open("empty.dat");
   Latin_1_in latin1File1 ( bfile1 );
   ASSERT(latin1File1.bEOS());
   // Normal case
   Filename fn("latin1.dat");
   InputByteFile bfile;
   bfile.Open(fn);
   Latin_1_in latin1File(bfile);
   LogFile::Start();
   while (! latin1File.bEOS() ){
      TeXChar ch = latin1File.Get();
      LOG( ch << ' ' );
   }
   return CompareLog("latin1.log", "Textio.TestLatin1");
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 81, 89, 103 and 112.}
\fwusedin{This macro is invoked in definition 119.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Textio TestTable}{104}\fwplusequals \fwodef \fwbtx[{"latin1", TestLatin1},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 82, 90, 104 and 113.}
\fwusedin{This macro is invoked in definition 119.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{latin1.dat}{105}\fwequals \fwodef \fwbtx[Some text
Line 2]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{latin1.log}{106}\fwequals \fwodef \fwbtx[S o m e   t e x t ]fwetx=%
\fwmacroname{Platform}{4}\fwoparen \fwoquote\fwbtx[\u(10)]fwetx=%
\fwcquote\fwcomma \fwoquote\fwbtx[\u(13) \u(10)]fwetx=%
\fwcquote\fwcparen \fwbtx[ L i n e   2 ]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwsecb{3.4}{Line Sources}

A \fwlit{LineSource} reads the character stream produced by the \fwlit{CharStream}
class and converts it to a sequence of \fwlit{LinesOfText}.

\fwbeginmacro
\fwmacroname{class LineSource}{107}\fwequals \fwodef \fwbtx[class LineSource {
private:
   CharStream& m_charStream;

public:
   LineSource(CharStream&);
   ~LineSource();
   bool bEmpty() const;
   bool GetLine(LineOfText* line);
private:
   // Unimplemented
   LineSource(const LineSource&);
   LineSource& operator=(const LineSource&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 117.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{LineSource implementation}{108}\fwplusequals \fwodef \fwbtx[LineSource::LineSource(CharStream& cs)
   : m_charStream(cs)
{
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 108, 109, 110 and 111.}
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{LineSource implementation}{109}\fwplusequals \fwodef \fwbtx[LineSource::~LineSource()
{
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 108, 109, 110 and 111.}
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{LineSource implementation}{110}\fwplusequals \fwodef \fwbtx[bool LineSource::bEmpty() const
{
   return m_charStream.bEOS();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 108, 109, 110 and 111.}
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro



Note the use of \fwlit{LINE\_END} here. This needs to be changed.
There is going to be a parameter \fwlit{\char`\\endlinechar} that holds the
charater to be used as an end of line mark regardless of what
the system uses.

\fwbeginmacro
\fwmacroname{LineSource implementation}{111}\fwplusequals \fwodef \fwbtx[const TeXChar LINE_END = 0x000A;

bool LineSource::GetLine(LineOfText* pLine)
{
   ASSERT(pLine != 0);
   if (m_charStream.bEOS()){
      return false;
   }
   pLine -> Clear();
   while (true){
      TeXChar ch = m_charStream.Get();
      if (ch == LINE_END){
         pLine -> Append('\x0d');
         break;
      } else
         pLine -> Append(ch);

      if (m_charStream.bEOS())
         break;

   }
   // I think a line should be able to have
   // a line end character or not, so I'll
   // remove this for now.
   //pLine -> Append(LINE_END);
   return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 108, 109, 110 and 111.}
\fwusedin{This macro is invoked in definition 118.}
\fwendmacronotes
\fwendmacro



\fwsecc{3.4.1}{Tests}

\fwbeginmacro
\fwmacroname{Textio tests}{112}\fwplusequals \fwodef \fwbtx[bool TestLineSource()
{
   // Test with an empty file
   Filename fn1("empty.dat");
   InputByteFile bfile1;
   bfile1.Open(fn1);
   Latin_1_in charStream1(bfile1);
   LineSource lines1(charStream1);
   ASSERT(lines1.bEmpty());

   // Normal Case
   Filename fn2("lines2.dat");
   InputByteFile bfile2;
   bfile2.Open(fn2);
   Latin_1_in charStream2(bfile2);
   LineSource lines2(charStream2);
   LineOfText line;
   int i = 0;
   LogFile::Start();
   while ( !lines2.bEmpty() ) {
     ++i;
     lines2.GetLine(&line);
     if (i != 1) LOG ('\n');
     LOG("Line " << i << '\n');
     LOG("Size = " << line.nRemaining() << '\n');
     LOG(line);
   }
   return CompareLog("lines2.log", "Textio.TestLineSource");
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 81, 89, 103 and 112.}
\fwusedin{This macro is invoked in definition 119.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Textio TestTable}{113}\fwplusequals \fwodef \fwbtx[{"linesource", TestLineSource},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 82, 90, 104 and 113.}
\fwusedin{This macro is invoked in definition 119.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwfilename{lines2.dat}{114}\fwequals \fwodef \fwbtx[First line
Second line
Third line]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwfilename{lines2.log}{115}\fwequals \fwodef \fwbtx[Line 1
Size = 11
First line\u(13)
Line 2
Size = 12
Second line\u(13)
Line 3
Size = 10
Third line]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro




\fwsecb{3.5}{Overall subsystem}


\fwbeginmacro
\fwfilename{a.x}{116}\fwequals \fwodef \fwbtx[Testing one, two, three...
here is another line
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwsecb{3.6}{Physical layout}
\fwbeginmacro
\fwfilename{textio.h}{117}\fwequals \fwodef \fwbtx[#ifndef TEXTIO_H
#define TEXTIO_H

#ifndef PLATFORM_H
   #include "platform.h"
#endif

]fwetx=%
\fwmacroname{class LineOfText}{83}\fwbtx[
]fwetx=%
\fwmacroname{class CharStream}{91}\fwbtx[
]fwetx=%
\fwmacroname{class LineSource}{107}\fwbtx[
]fwetx=%
\fwmacroname{class Latin\_1\_in}{93}\fwbtx[
]fwetx=%
\fwmacroname{class Codepage932\_in}{95}\fwbtx[
]fwetx=%
\fwmacroname{class Codepage936\_in}{97}\fwbtx[
]fwetx=%
\fwmacroname{class Codepage949\_in}{99}\fwbtx[
]fwetx=%
\fwmacroname{class Codepage950\_in}{101}\fwbtx[


]fwetx=%
\fwmacroname{IOSys interface}{79}\fwbtx[

#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{textio.cpp}{118}\fwequals \fwodef \fwbtx[#include "textio.h"
#include <string>
]fwetx=%
\fwmacroname{static data}{80}\fwbtx[
]fwetx=%
\fwmacroname{LineOfText implementation}{85}\fwbtx[
]fwetx=%
\fwmacroname{CharStream implementation}{92}\fwbtx[
]fwetx=%
\fwmacroname{LineSource implementation}{108}\fwbtx[
]fwetx=%
\fwmacroname{Latin\_1\_in implementation}{94}\fwbtx[
]fwetx=%
\fwmacroname{Codepage932\_in implementation}{96}\fwbtx[
]fwetx=%
\fwmacroname{Codepage936\_in implementation}{98}\fwbtx[
]fwetx=%
\fwmacroname{Codepage949\_in implementation}{100}\fwbtx[
]fwetx=%
\fwmacroname{Codepage950\_in implementation}{102}\fwbtx[

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{textio.t.cpp}{119}\fwequals \fwodef \fwbtx[#include "platform.h"
#include "textio.h"
#include <string>
]fwetx=%
\fwmacroname{CompareLog utility}{17}\fwbtx[
]fwetx=%
\fwmacroname{Test jig}{8}\fwoparen \fwoquote\fwmacroname{Textio tests}{81}\fwcquote\fwcomma \fwoquote\fwmacroname{Textio TestTable}{82}\fwcquote\fwcparen \fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro




\fwseca{4}{The symbols subsystem}

\fwsecb{4.1}{Interface}

For us a \fwlit{Symbol} is something like a control sequence name.  Thus
\fwlit{baselineskip} and \fwlit{let} are symbols, and when you execute
\fwlit{\char`\\def\char`\\mymacro\char`\{blah blah blah\char`\}} you create a new symbol \fwlit{mymacro}.

The \fwlit{SymbolTable} associates a symbol with a pointer to some
data. The pointer is opaque to the table. That is, the \fwlit{SymbolTable}
does not know what type of object it holds a pointer to.  The data
associated with a symbol is unknown to the symbol subsystem.  So we
define an abstract type \fwlit{SymbolData} and let the \fwlit{SymbolTable}
operate with pointers to this type. The \fwlit{SymbolTable}'s clients
presumably know what they stored in the table and can cast the data to
the appropriate type.


Here is the interface
\fwbeginmacro
\fwmacroname{Symbols interface}{120}\fwequals \fwodef \fwbtx[
class SymbolData;

struct Symbols {
   ]fwetx=%
\fwmacroname{enum CreateStatus}{121}\fwbtx[
   typedef int SymId;

   // A way to directly enter into the symbol table
   static void CreateSymbol(const char*, SymbolData*);

   // Get an id from the name, create if needed
   static void GetId(const String& name, SymId* id, CreateStatus create);

   // Get a name from an id
   static String GetName(SymId id);

   static void SetDef(SymId id, SymbolData* pData, bool bGlobal);
   static void GetDef(SymId id, SymbolData** pData);
   static void GetDefLoc(SymId id, void** pLoc);

   static void SetActiveDef(TeXChar c, SymbolData* pData, bool bGlobal);
   static void GetActiveDef(TeXChar c, SymbolData** pData);
   static void GetActiveDefLoc(TeXChar c, void** pLoc);

   // Traverse symbols in alphabetical order
   static void GetFirstSym(SymId* id);
   static void GetNextSym(SymId* id);

   // Traverse definitions from innermost to global
   static void GetFirstDef(SymId id, SymbolData* pData);
   static void GetNextDef(SymbolData* pData);

   static SymId NullCS();

   // Save and load the symbol information
   static void Dump();
   static void Load();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 134.}
\fwendmacronotes
\fwendmacro



Symbols are entered into the system with the \fwlit{Symbols::GetID}
function. This takes a string of TeXChars and converts it to an
identification number that is used to identify the symbol in other
operations. \fwlit{GetID} may be allowed to create a new symbol if it is
passed a \fwlit{ALLOW\_CREATE}, otherwise it returns an undefined control
sequence.





\fwbeginmacro
\fwmacroname{enum CreateStatus}{121}\fwequals \fwodef \fwbtx[enum CreateStatus  {NO_CREATE, CREATE};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 120.}
\fwendmacronotes
\fwendmacro





\fwsecb{4.2}{Hash table implementation}

The \fwlit{TableEntry} contains a \fwlit{m\_defLevel} member that records the
(braces) level at which a definition occured. If a new definition is
made at the same level it replaces the old one. If the new definition
is made at a deeper level then the old definition is saved

\fwbeginmacro
\fwmacroname{HashTable implementation}{122}\fwequals \fwodef \fwbtx[const int hash_size = 12000;
const int hash_prime = 9973;
const int UNDEFINED = 0;  // index reserved for undefined,
                          // is it the same as NULL_CS?
int hash_used = hash_size - 1;

struct TableEntry {
   String         m_str;
   int            m_defLevel;
   SymbolData*    m_data;
   TableEntry*    m_next;
};

static TableEntry hash_table[hash_size];

int Hash(const String& str)
{
   int h = 0;
   for (unsigned int i = 0; i < str.Size(); ++i){
      h = h + h + str[i];
      while (h >= hash_prime) h = h - hash_prime;
   }
   ASSERT( h < hash_prime );
   return h;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 135.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{GetId imp}{123}\fwequals \fwodef \fwbtx[void Symbols::GetId(const String& str, SymId* id, CreateStatus create)
{
   int h = Hash(str);
   TableEntry* pEntry = &hash_table[h];

   bool found = false;
   bool searching = true;
   while ( searching ){
      if (str == pEntry -> m_str){
         found = true;
         searching = false;
      }else{
         if (pEntry -> m_next == 0){
            searching = false;
         }else{
            pEntry = pEntry -> m_next;
         }
      }
   }

   ASSERT(found || pEntry -> m_next == 0);

   if (! found ){
      if ( create == CREATE ){
         // Create a new entry
         if (pEntry -> m_str.Size() == 0){
            // This space available
         }else{
            while (hash_table[hash_used].m_str.Size() != 0){
               --hash_used;
               if (hash_used == 0){
                   throw TeXException("");
               }
            }
            TableEntry* newEntry = &hash_table[hash_used];
            pEntry -> m_next = newEntry;
            pEntry = newEntry;
         }
         pEntry -> m_str = str;
      }else{
         pEntry = UNDEFINED;
      }
   } else {
      StringBuilder::Discard(str);
   }
   *id = pEntry - &hash_table[0];
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 135.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{GetDef imp}{124}\fwequals \fwodef \fwbtx[void Symbols::GetDef(SymId id, SymbolData** pData)
{
   (*pData) = hash_table[id].m_data;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 135.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{GetDefLoc imp}{125}\fwequals \fwodef \fwbtx[void Symbols::GetDefLoc(SymId id, void** pLoc)
{
   (*pLoc) = &hash_table[id].m_data;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 135.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{SetDef imp}{126}\fwequals \fwodef \fwbtx[void Symbols::SetDef(SymId id, SymbolData* pData, bool bGlobal)
{
   hash_table[id].m_data = pData;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 135.}
\fwendmacronotes
\fwendmacro



\fwsecc{4.2.1}{Active character definitions}

\fwbeginmacro
\fwmacroname{Symbols implementation}{127}\fwplusequals \fwodef \fwbtx[static SymbolData* s_activeDef[NUM_TEX_CHARS];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 127 and 128.}
\fwusedin{This macro is invoked in definition 135.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Symbols implementation}{128}\fwplusequals \fwodef \fwbtx[void Symbols::SetActiveDef(TeXChar c, SymbolData* pData, bool bGlobal)
{
   s_activeDef[c] = pData;
}

void Symbols::GetActiveDef(TeXChar c, SymbolData** pData)
{
   *pData = s_activeDef[c];
}

void Symbols::GetActiveDefLoc(TeXChar c, void** pLoc)
{
   *pLoc = &s_activeDef[c];
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 127 and 128.}
\fwusedin{This macro is invoked in definition 135.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{GetName imp}{129}\fwequals \fwodef \fwbtx[String Symbols::GetName(Symbols::SymId id)
{
   return hash_table[id].m_str;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 135.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{NullCS imp}{130}\fwequals \fwodef \fwbtx[Symbols::SymId Symbols::NullCS()
{
   return 0;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 135.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{CreateSymbol imp}{131}\fwequals \fwodef \fwbtx[void Symbols::CreateSymbol(const char* name, SymbolData* data)
{
   for (int i  = 0; i < strlen(name); ++i){
      StringBuilder::Append(name[i]);
   }
   String strName = StringBuilder::Create();
   SymId id;
   GetId(strName, &id, CREATE);
   SetDef(id, data, true);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 135.}
\fwendmacronotes
\fwendmacro




\fwsecc{4.2.2}{Tests}

To test the hash table we'll enter a bunch of symbols and then check
that they are still correctly in the table


\fwbeginmacro
\fwmacroname{Symbols TestTable entries}{132}\fwplusequals \fwodef \fwbtx[{"hash", TestHashTable},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 132.}
\fwusedin{This macro is invoked in definition 136.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Symbols test functions}{133}\fwplusequals \fwodef \fwbtx[bool TestHashTable()
{
   try{
      String name = StringBuilder::Create("immediate");
      Symbols::SymId id1, id2;
      Symbols::GetId(name, &id1, Symbols::CREATE);
      Symbols::GetId(name, &id2, Symbols::CREATE);
      ASSERT(id1 == id2);
      String str = Symbols::GetName(id1);
      ASSERT(str == name);
   }
   catch(...){
       return false;
   }
   return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 133.}
\fwusedin{This macro is invoked in definition 136.}
\fwendmacronotes
\fwendmacro




\fwsecb{4.3}{Physical layout}

This component consists of two files: \fwlit{symbols.h} and
\fwlit{symbols.cpp}

\fwbeginmacro
\fwfilename{symbols.h}{134}\fwequals \fwodef \fwbtx[#ifndef SYMBOLS_H
#define SYMBOLS_H

#include "platform.h"
]fwetx=%
\fwmacroname{Symbols interface}{120}\fwbtx[

#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{symbols.cpp}{135}\fwequals \fwodef \fwbtx[#include "symbols.h"
#include <string> // for strlen
]fwetx=%
\fwmacroname{HashTable implementation}{122}\fwbtx[
]fwetx=%
\fwmacroname{GetId imp}{123}\fwbtx[
]fwetx=%
\fwmacroname{GetDef imp}{124}\fwbtx[
]fwetx=%
\fwmacroname{GetDefLoc imp}{125}\fwbtx[
]fwetx=%
\fwmacroname{SetDef imp}{126}\fwbtx[
]fwetx=%
\fwmacroname{GetName imp}{129}\fwbtx[
]fwetx=%
\fwmacroname{CreateSymbol imp}{131}\fwbtx[
]fwetx=%
\fwmacroname{NullCS imp}{130}\fwbtx[
]fwetx=%
\fwmacroname{Symbols implementation}{127}\fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{symbols.t.cpp}{136}\fwequals \fwodef \fwbtx[#include "platform.h"
#include "symbols.h"
#include <string>
#include <iostream>

]fwetx=%
\fwmacroname{Test jig}{8}\fwoparen \fwoquote\fwmacroname{Symbols test functions}{133}\fwcquote\fwcomma \fwoquote\fwmacroname{Symbols TestTable entries}{132}\fwcquote\fwcparen \fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro

\fwseca{5}{Basic TeX data types and parameters}

Now we introduce the data types used throughout the rest of \TeX{}.
These include integers, dimensions, glue, tokens, token lists,
fonts, and boxes. We also gather together all of the parameters
defined in the \TeX{} language. These include simple parameters
like \fwlit{\char`\\baselineskip} and arrays like \fwlit{\char`\\count} and \fwlit{\char`\\catcode}.

Here's ths structure that holds all the parameters:

\fwbeginmacro
\fwmacroname{Parameter struct declaration}{137}\fwequals \fwodef \fwbtx[struct Global {
   ]fwetx=%
\fwmacroname{Parameters}{138}\fwbtx[
   ]fwetx=%
\fwmacroname{Input and Output files}{191}\fwbtx[
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro


\fwsecb{5.1}{Integers}

There is not too much to say here. We'll just use the built-in C++ type
\fwlit{int}.

\fwbeginmacro
\fwmacroname{Parameters}{138}\fwplusequals \fwodef \fwbtx[static int pretolerance;
static int tolerance;
static int hbadness;
static int vbadness;
static int linepenalty;
static int hyphenpenalty;
static int exhyphenpenalty;
static int binoppenalty;
static int relpenalty;
static int clubpenalty;
static int widowpenalty;
static int displaywidowpenalty;
static int brokenpenalty;
static int predisplaypenalty;
static int postdisplaypenalty;
static int interlinepenalty;
static int floatingpenalty;
static int outputpenalty;
static int doublehyphendemerits;
static int finalhyphendemerits;
static int adjdemerits;
static int looseness;
static int pausing;
static int holdinginserts;
static int tracingonline;
static int tracingmacros;
static int tracingstats;
static int tracingparagraphs;
static int tracingpages;
static int tracingoutput;
static int tracinglostchars;
static int tracingcommands;
static int tracingrestores;
static int language;
static int uchyph;
static int lefthyphenmin;
static int righthyphenmin;
static int globaldefs;
static int defaulthyphenchar;
static int defaultskewchar;
static int escapechar;
static int endlinechar;
static int newlinechar;
static int showboxbreadth;
static int showboxdepth;
static int errorcontextlines;
static int delimiterfactor;
static int fam;
static int maxdeadcycles;
static int hangafter;
static int mag;
static int time;
static int day;
static int month;
static int year;
static int inputlineno;
static int lastpenalty;
static int deadcycles;
static int spacefactor;
static int msidobraces;
static int msidollar;
static int msioutput;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 138, 140, 143, 145, 148, 150, 152, 164 and 166.}
\fwusedin{This macro is invoked in definition 137.}
\fwendmacronotes
\fwendmacro



And these have to be defined in the \fwlit{.cpp} file:

\fwbeginmacro
\fwmacroname{Parameter definitions}{139}\fwplusequals \fwodef \fwbtx[int Global::pretolerance;
int Global::tolerance;
int Global::hbadness;
int Global::vbadness;
int Global::linepenalty;
int Global::hyphenpenalty;
int Global::exhyphenpenalty;
int Global::binoppenalty;
int Global::relpenalty;
int Global::clubpenalty;
int Global::widowpenalty;
int Global::displaywidowpenalty;
int Global::brokenpenalty;
int Global::predisplaypenalty;
int Global::postdisplaypenalty;
int Global::interlinepenalty;
int Global::floatingpenalty;
int Global::outputpenalty;
int Global::doublehyphendemerits;
int Global::finalhyphendemerits;
int Global::adjdemerits;
int Global::looseness;
int Global::pausing;
int Global::holdinginserts;
int Global::tracingonline;
int Global::tracingmacros;
int Global::tracingstats;
int Global::tracingparagraphs;
int Global::tracingpages;
int Global::tracingoutput;
int Global::tracinglostchars;
int Global::tracingcommands;
int Global::tracingrestores;
int Global::language;
int Global::uchyph;
int Global::lefthyphenmin;
int Global::righthyphenmin;
int Global::globaldefs;
int Global::defaulthyphenchar;
int Global::defaultskewchar;
int Global::escapechar;
int Global::endlinechar;
int Global::newlinechar;
int Global::showboxbreadth;
int Global::showboxdepth;
int Global::errorcontextlines;
int Global::delimiterfactor;
int Global::fam;
int Global::maxdeadcycles;
int Global::hangafter;
int Global::mag;
int Global::time;
int Global::day;
int Global::month;
int Global::year;
int Global::inputlineno;
int Global::lastpenalty;
int Global::deadcycles;
int Global::spacefactor;
int Global::msidobraces;
int Global::msidollar;
int Global::msioutput;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 139, 141, 144, 146, 149, 151, 153, 165 and 167.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



The \fwlit{CountReg} array holds all the counter registers.
These are accessed via the \TeX{} primitive \fwlit{\char`\\count}.

\fwbeginmacro
\fwmacroname{Parameters}{140}\fwplusequals \fwodef \fwbtx[static int CountReg[256];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 138, 140, 143, 145, 148, 150, 152, 164 and 166.}
\fwusedin{This macro is invoked in definition 137.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Parameter definitions}{141}\fwplusequals \fwodef \fwbtx[int Global::CountReg[256];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 139, 141, 144, 146, 149, 151, 153, 165 and 167.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



\fwsecb{5.2}{Scaled}

\fwbeginmacro
\fwmacroname{Basic type declarations}{142}\fwplusequals \fwodef \fwbtx[typedef int Scaled;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 142, 147, 154, 155, 156, 163 and 171.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Parameters}{143}\fwplusequals \fwodef \fwbtx[static Scaled hfuzz;
static Scaled vfuzz;
static Scaled boxmaxdepth;
static Scaled splitmaxdepth;
static Scaled delimitershortfall;
static Scaled nulldelimiterspace;
static Scaled scriptspace;
static Scaled parindent;
static Scaled overfullrule;
static Scaled emergencystretch;
static Scaled hsize;
static Scaled vsize;
static Scaled maxdepth;
static Scaled lineskiplimit;
static Scaled mathsurround;
static Scaled predisplaysize;
static Scaled displaywidth;
static Scaled displayindent;
static Scaled hangindent;
static Scaled hoffset;
static Scaled voffset;
static Scaled lastkern;
static Scaled prevdepth;
static Scaled pagegoal;
static Scaled pagetotal;
static Scaled pagestretch;
static Scaled pagefilstretch;
static Scaled pagefillstretch;
static Scaled pagefilllstretch;
static Scaled pageshrink;
static Scaled pagedepth;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 138, 140, 143, 145, 148, 150, 152, 164 and 166.}
\fwusedin{This macro is invoked in definition 137.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Parameter definitions}{144}\fwplusequals \fwodef \fwbtx[Scaled Global::hfuzz;
Scaled Global::vfuzz;
Scaled Global::boxmaxdepth;
Scaled Global::splitmaxdepth;
Scaled Global::delimitershortfall;
Scaled Global::nulldelimiterspace;
Scaled Global::scriptspace;
Scaled Global::parindent;
Scaled Global::overfullrule;
Scaled Global::emergencystretch;
Scaled Global::hsize;
Scaled Global::vsize;
Scaled Global::maxdepth;
Scaled Global::lineskiplimit;
Scaled Global::mathsurround;
Scaled Global::predisplaysize;
Scaled Global::displaywidth;
Scaled Global::displayindent;
Scaled Global::hangindent;
Scaled Global::hoffset;
Scaled Global::voffset;
Scaled Global::lastkern;
Scaled Global::prevdepth;
Scaled Global::pagegoal;
Scaled Global::pagetotal;
Scaled Global::pagestretch;
Scaled Global::pagefilstretch;
Scaled Global::pagefillstretch;
Scaled Global::pagefilllstretch;
Scaled Global::pageshrink;
Scaled Global::pagedepth;


]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 139, 141, 144, 146, 149, 151, 153, 165 and 167.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro


The \fwlit{DimenReg} array holds all the dimension registers.
These are accessed via the \TeX{} primitive \fwlit{\char`\\dimen}.

\fwbeginmacro
\fwmacroname{Parameters}{145}\fwplusequals \fwodef \fwbtx[static int DimenReg[256];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 138, 140, 143, 145, 148, 150, 152, 164 and 166.}
\fwusedin{This macro is invoked in definition 137.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Parameter definitions}{146}\fwplusequals \fwodef \fwbtx[int Global::DimenReg[256];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 139, 141, 144, 146, 149, 151, 153, 165 and 167.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



\fwsecb{5.3}{Glue}

\fwbeginmacro
\fwmacroname{Basic type declarations}{147}\fwplusequals \fwodef \fwbtx[enum GlueOrder {ORD_FINITE, ORD_FIL, ORD_FILL, ORD_FILLL};

class GlueSpec {
private:
   Scaled m_width;
   Scaled m_shrink;
   GlueOrder m_shrinkOrder;
   Scaled m_stretch;
   GlueOrder m_stretchOrder;

public:

};

typedef GlueSpec* Glue;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 142, 147, 154, 155, 156, 163 and 171.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Parameters}{148}\fwplusequals \fwodef \fwbtx[static Glue baselineskip;
static Glue lineskip;
static Glue parskip;
static Glue abovedisplayskip;
static Glue belowdisplayskip;
static Glue abovedisplayshortskip;
static Glue belowdisplayshortskip;
static Glue leftskip;
static Glue rightskip;
static Glue topskip;
static Glue splittopskip;
static Glue spaceskip;
static Glue xspaceskip;
static Glue parfillskip;
static Glue thinmuskip;
static Glue medmuskip;
static Glue thickmuskip;
static Glue tabskip;
static Glue lastskip;

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 138, 140, 143, 145, 148, 150, 152, 164 and 166.}
\fwusedin{This macro is invoked in definition 137.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Parameter definitions}{149}\fwplusequals \fwodef \fwbtx[Glue Global::baselineskip;
Glue Global::lineskip;
Glue Global::parskip;
Glue Global::abovedisplayskip;
Glue Global::belowdisplayskip;
Glue Global::abovedisplayshortskip;
Glue Global::belowdisplayshortskip;
Glue Global::leftskip;
Glue Global::rightskip;
Glue Global::topskip;
Glue Global::splittopskip;
Glue Global::spaceskip;
Glue Global::xspaceskip;
Glue Global::parfillskip;
Glue Global::thinmuskip;
Glue Global::medmuskip;
Glue Global::thickmuskip;
Glue Global::tabskip;
Glue Global::lastskip;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 139, 141, 144, 146, 149, 151, 153, 165 and 167.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



The \fwlit{SkipReg} array holds all the glue registers.
These are accessed via the \TeX{} primitive \fwlit{\char`\\skip}.

\fwbeginmacro
\fwmacroname{Parameters}{150}\fwplusequals \fwodef \fwbtx[static int SkipReg[256];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 138, 140, 143, 145, 148, 150, 152, 164 and 166.}
\fwusedin{This macro is invoked in definition 137.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Parameter definitions}{151}\fwplusequals \fwodef \fwbtx[int Global::SkipReg[256];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 139, 141, 144, 146, 149, 151, 153, 165 and 167.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



\fwsecb{5.4}{Boxes}


The \fwlit{BoxReg} array holds all the box registers.
These are accessed via the \TeX{} primitive \fwlit{\char`\\box}.

\fwbeginmacro
\fwmacroname{Parameters}{152}\fwplusequals \fwodef \fwbtx[static int BoxReg[256];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 138, 140, 143, 145, 148, 150, 152, 164 and 166.}
\fwusedin{This macro is invoked in definition 137.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Parameter definitions}{153}\fwplusequals \fwodef \fwbtx[int Global::BoxReg[256];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 139, 141, 144, 146, 149, 151, 153, 165 and 167.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro







\fwsecb{5.5}{TeXTokens}

Every \fwlit{TeXToken} consists of a \fwlit{TokenType}, and then either a
character if the token is a single (non-active) character token, or
else a \fwlit{SymID} that we get from the symbols subsystem. This is used
to look up a symbol's definition.

Here is a list of the basic token types we use in \TeX. Basic means
that these token types come out of the tokenizer. However, there may
be other types that get into \fwlit{TokenList}s. So we are faced with this
issue: We don't want this piece of code (the Tokens component) to
depend on knowledge of higher level stuff like the macro
processor. Therefore we can't give a complete list of the token types
here. We could peek ahead and get a complete list but we don't really
want to do that unless we have to. On the other hand, providing a
complete list here provides a bit of type safety. The compiler would
be able to ensure that only the declared values ever get to be the
value of a token type variable.

We can actually get both type safety and code independence by working
hard enough but that seems like overkill here. I lean towards maintaining
independence and giving up a bit of type safety.

\fwbeginmacro
\fwmacroname{Basic type declarations}{154}\fwplusequals \fwodef \fwbtx[enum TokenType {
   TT_SYMBOL,
   TT_LEFT_BRACE,
   TT_RIGHT_BRACE,
   TT_MATH_SHIFT,
   TT_TAB,
   TT_ACTIVE,
   TT_LETTER,
   TT_OTHER,
   TT_SPACE,
   TT_PARAM,
   TT_SUBSCRIPT,
   TT_SUPERSCRIPT,
   TT_PAR,
   TT_MATCH,      // used in macro processor to mark parameter
   TT_END_MATCH,  // used in macro processor to mark end of param description
   TT_OUTPARAM,   // used in macro processor to denote a parmeter subst.
   TT_ENDV,       // used to mark the end of an alignment column
   TT_ENDR,       // used to mark the end of an alignment row
   FIRST_NONBASIC_TOKENTYPE // must go last in this enum
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 142, 147, 154, 155, 156, 163 and 171.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Basic type declarations}{155}\fwplusequals \fwodef \fwbtx[enum Catcode{
   CC_ESCAPE,     // 0
   CC_LEFTBRACE,  // 1
   CC_RIGHTBRACE, // 2
   CC_MATHSHIFT,  // 3
   CC_ALIGNTAB,   // 4
   CC_ENDOFLINE,  // 5
   CC_PARAM,      // 6
   CC_SUPER,      // 7
   CC_SUBS,       // 8
   CC_IGNORE,     // 9
   CC_SPACE,      // 10
   CC_LETTER,     // 11
   CC_OTHER,      // 12
   CC_ACTIVE,     // 13
   CC_COMMENT,    // 14
   CC_INVALID};   // 15
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 142, 147, 154, 155, 156, 163 and 171.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Basic type declarations}{156}\fwplusequals \fwodef \fwbtx[class TeXToken {
private :
   TokenType m_type;
   TeXChar   m_chrCode;
   Symbols::SymId     m_sym;
public:
   TeXToken();
   TeXToken( TokenType t, TeXChar c, Symbols::SymId id);

   bool operator==(const TeXToken& right) const;
   bool operator!=(const TeXToken& right) const;

   TokenType Type() const { return m_type; }
   TeXChar   ChrCode() const { return m_chrCode; };
   Symbols::SymId Symbol() const { return m_sym; }

   void SetType(TokenType t) { m_type = t; }
   void SetChrCode(TeXChar c) { m_chrCode = c; }
   void SetSymbol(Symbols::SymId id) { m_sym = id; }
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 142, 147, 154, 155, 156, 163 and 171.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{TeXToken implementation}{157}\fwplusequals \fwodef \fwbtx[TeXToken::TeXToken()
   : m_type(TT_LETTER),
     m_chrCode(0),
     m_sym(0)
{
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 157, 158, 159 and 160.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{TeXToken implementation}{158}\fwplusequals \fwodef \fwbtx[TeXToken::TeXToken( TokenType t, TeXChar c, Symbols::SymId id)
   : m_type(t), m_chrCode(c), m_sym(id)
{}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 157, 158, 159 and 160.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{TeXToken implementation}{159}\fwplusequals \fwodef \fwbtx[bool TeXToken::operator==(const TeXToken& right) const
{
   return (m_type == right.m_type) &&
          (m_chrCode == right.m_chrCode) &&
          (m_sym == right.m_sym);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 157, 158, 159 and 160.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{TeXToken implementation}{160}\fwplusequals \fwodef \fwbtx[bool TeXToken::operator!=(const TeXToken& right) const
{
   return !(*this == right);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 157, 158, 159 and 160.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro




Next let's add a method for writing tokens to the execution log.


\fwbeginmacro
\fwmacroname{TeXToken logging}{161}\fwplusequals \fwodef \fwbtx[#ifdef LOGGING
   LogFile& operator<<(LogFile&, const TeXToken&);
#endif
static int s_paramno = 0; // Used to print  #1, #2, etc
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 161.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{TeXToken logging imp}{162}\fwplusequals \fwodef \fwbtx[#ifdef LOGGING
static bool s_bLogSymbolNumber = false;

LogFile& operator<<(LogFile& f, const TeXToken& tt)
{
   switch (tt.Type()){
      case TT_SYMBOL:
         if (tt.Symbol() == Symbols::NullCS()){
            LOG("null");
         }else{
            LOG("\\" << Symbols::GetName(tt.Symbol()) );
         }
         #ifdef LOGGING
            if (s_bLogSymbolNumber){
               LOG(", #" << tt.Symbol() );
            }
         #endif
         break;

      case TT_PAR:   LOG(tt.ChrCode() << " (\\Par)"); break;
      case TT_MATCH:
           ++s_paramno;
           LOG("#" << s_paramno);
           break;
      case TT_END_MATCH:   LOG("-->"); break;
      case TT_OUTPARAM:    LOG("#"); LOG(1+(int)tt.ChrCode());break;
      case TT_ENDV:        LOG("ENDV"); break;
      case TT_ENDR:        LOG("ENDR"); break;
      default:
         LOG(tt.ChrCode());
         if (tt.Type() != s_usualtokentype[tt.ChrCode()]){
           switch (tt.Type()){
             case TT_LEFT_BRACE:   LOG(",(Left Brace)" ); break;
             case TT_RIGHT_BRACE:  LOG(",(Right Brace)" ); break;
             case TT_MATH_SHIFT:   LOG(",(Math shift)" ); break;
             case TT_TAB:          LOG(",(Align tab)" ); break;
             case TT_ACTIVE:       LOG(",(Active)"); break;
             case TT_LETTER:       LOG(",(Letter)"); break;
             case TT_OTHER:        LOG(",(Other)"); break;
             case TT_SPACE:        LOG(",(Space)"); break;
             case TT_PARAM:        LOG(",(Param)"); break;
             case TT_SUBSCRIPT:    LOG(",(Subscript)"); break;
             case TT_SUPERSCRIPT:  LOG(",(Superscript)"); break;
             default: {
                LOG("\nCan't happen. Tokens. ");
                LOG(tt.ChrCode() << " has catcode " << s_catcode[tt.ChrCode()]);
                break;
             }
           }
         }
         break;
   }
   return f;
}
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 162.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



\fwsecb{5.6}{Token lists}

In this section we describe \fwlit{TokenList}s which are simply reference
counted lists of \fwlit{TeXTokens}. We consider implementing a
\fwlit{ReferenceCounted} class and a ``smart pointer" that manages the
reference count. But until there is more than one of this sort of
thing going on we'll not do that. Finally we have
\fwlit{TokenListTokenSource}s that are \fwlit{TokenSource}s that manage a
\fwlit{TokenList}.

\fwbeginmacro
\fwmacroname{Basic type declarations}{163}\fwplusequals \fwodef \fwbtx[class TokenList : public std::list<TeXToken>{
private:
   mutable long m_refCount;
public:
   TokenList() : m_refCount(0) {}
   void AddReference() const { ++m_refCount; }
   void RemoveReference() const {
       --m_refCount;
       if (m_refCount == 0)
          delete this;
   }

   void AppendSymbol(const char* str);
   //bool operator==(const TokenList& right) const;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 142, 147, 154, 155, 156, 163 and 171.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro






\fwbeginmacro
\fwmacroname{Parameters}{164}\fwplusequals \fwodef \fwbtx[static TokenList output;
static TokenList everypar;
static TokenList everymath;
static TokenList everydisplay;
static TokenList everyhbox;
static TokenList everyvbox;
static TokenList everyjob;
static TokenList everycr;
static TokenList errhelp;
static TokenList msieverycellstart;
static TokenList msieverycellend;

static TokenList msieveryrowstart;
static TokenList msieveryrowend;


static TokenList msiinlinemathproc;
static TokenList msidisplaymathproc;
static TokenList msieverypar;
static TokenList msieveryhbox;

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 138, 140, 143, 145, 148, 150, 152, 164 and 166.}
\fwusedin{This macro is invoked in definition 137.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Parameter definitions}{165}\fwplusequals \fwodef \fwbtx[TokenList Global::output;
TokenList Global::everypar;
TokenList Global::everymath;
TokenList Global::everydisplay;
TokenList Global::everyhbox;
TokenList Global::everyvbox;
TokenList Global::everyjob;
TokenList Global::everycr;
TokenList Global::errhelp;
TokenList Global::msieverycellstart;
TokenList Global::msieverycellend;

TokenList Global::msieveryrowstart;
TokenList Global::msieveryrowend;

TokenList Global::msiinlinemathproc;
TokenList Global::msidisplaymathproc;
TokenList Global::msieverypar;
TokenList Global::msieveryhbox;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 139, 141, 144, 146, 149, 151, 153, 165 and 167.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro


The \fwlit{ToksReg} array holds all the token list registers.
These are accessed via the \TeX{} primitive \fwlit{\char`\\toks}.

\fwbeginmacro
\fwmacroname{Parameters}{166}\fwplusequals \fwodef \fwbtx[static TokenList ToksReg[256];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 138, 140, 143, 145, 148, 150, 152, 164 and 166.}
\fwusedin{This macro is invoked in definition 137.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Parameter definitions}{167}\fwplusequals \fwodef \fwbtx[TokenList Global::ToksReg[256];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 139, 141, 144, 146, 149, 151, 153, 165 and 167.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{TokenList implementation}{168}\fwequals \fwodef \fwbtx[void TokenList::AppendSymbol(const char* cstr)
{
  String str = StringBuilder::Create(cstr);
  Symbols::SymId id;
  Symbols::GetId(str, &id, Symbols::CREATE);
  push_back(TeXToken(TT_SYMBOL,0,id));
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{TokenList logging}{169}\fwequals \fwodef \fwbtx[struct LogFile;

#ifdef LOGGING
   LogFile& operator<<(LogFile&, const TokenList&);
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{TokenList logging imp}{170}\fwequals \fwodef \fwbtx[#ifdef LOGGING

   LogFile& operator<<(LogFile& lf, const TokenList& tl)
   {
      s_paramno = 0;
      for (TokenList::const_iterator it = tl.begin(); it != tl.end(); ++it)
      {
         LOG(*it << "  ");
      }
      return lf;
   }
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



\fwsecb{5.7}{Rules}

\fwbeginmacro
\fwmacroname{Basic type declarations}{171}\fwplusequals \fwodef \fwbtx[class RuleSpec {
public:
   RuleSpec() :
     m_width(0), m_height(0), m_depth(0)
   {}

   Scaled m_width;
   Scaled m_height;
   Scaled m_depth;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 142, 147, 154, 155, 156, 163 and 171.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro




\fwsecb{5.8}{Catcode and other tables}

There is a table of \fwlit{catcode}s. The table is accessed by the functions
\fwbeginmacro
\fwmacroname{Declare catcode functions}{172}\fwequals \fwodef \fwbtx[void InitCatcodes();
void SetCatcode(TeXChar ch, int catcode);
int* CatcodeLoc(TeXChar ch);
Catcode GetCatcode(TeXChar ch);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Implement catcode functions}{173}\fwequals \fwodef \fwbtx[
static Catcode s_catcode[NUM_TEX_CHARS];

#ifdef LOGGING
static TokenType s_usualtokentype[NUM_TEX_CHARS];
#endif

void InitCatcodes()
{
   // Initialize the catcode table

   for (TeXChar c = FIRST_TEX_CHAR; c <= LAST_TEX_CHAR; ++c){
      s_catcode[c] = CC_OTHER;
   }
   TeXChar letter;
   for (letter = L'a'; letter <= L'z'; ++letter) {
      s_catcode[letter] = CC_LETTER;
   }
   for (letter = L'A'; letter <= L'Z'; ++letter) {
      s_catcode[letter] = CC_LETTER;
   }
   s_catcode[L'\\'] = CC_ESCAPE;    s_catcode[L'{'] = CC_LEFTBRACE;
   s_catcode[L'}'] = CC_RIGHTBRACE; s_catcode[L'$'] = CC_MATHSHIFT;
   s_catcode[L'&'] = CC_ALIGNTAB;   s_catcode[L'%'] = CC_COMMENT;
   s_catcode[L'_'] = CC_SUBS;       s_catcode[L'^'] = CC_SUPER;
   s_catcode[L' '] = CC_SPACE;      s_catcode[L'~'] = CC_ACTIVE;
   s_catcode[L'#'] = CC_PARAM;

   // Need code to decide what to use here for \endlinechar

   //s_catcode[L'\n'] = CC_ENDOFLINE;
   s_catcode[13] = CC_ENDOFLINE;

#ifdef LOGGING
   for (int ch = 0; ch < 255; ++ch){
     switch (s_catcode[ch]){
        case CC_LEFTBRACE:  s_usualtokentype[ch] = TT_LEFT_BRACE;  break;
        case CC_RIGHTBRACE: s_usualtokentype[ch] = TT_RIGHT_BRACE; break;
        case CC_MATHSHIFT:  s_usualtokentype[ch] = TT_MATH_SHIFT;  break;
        case CC_ALIGNTAB:   s_usualtokentype[ch] = TT_TAB; break;
        case CC_SPACE:      s_usualtokentype[ch] = TT_SPACE; break;
        case CC_LETTER:     s_usualtokentype[ch] = TT_LETTER; break;
        case CC_OTHER:      s_usualtokentype[ch] = TT_OTHER; break;
        case CC_SUPER:      s_usualtokentype[ch] = TT_SUPERSCRIPT; break;
        case CC_SUBS:       s_usualtokentype[ch] = TT_SUBSCRIPT; break;
        case CC_ACTIVE:     s_usualtokentype[ch] = TT_ACTIVE; break;
     }
   }
#endif

}


void SetCatcode(TeXChar ch, int catcode)
{
   ASSERT(catcode >= CC_ESCAPE && catcode <= CC_INVALID);

   s_catcode[ch] = (Catcode) catcode;
}

Catcode GetCatcode(TeXChar ch)
{
   return s_catcode[ch];
}

int* CatcodeLoc(TeXChar ch)
{
   return (int*)&s_catcode[ch];
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro





Here's a table of \fwlit{uccodes}s.
\fwbeginmacro
\fwmacroname{Uccode table}{174}\fwequals \fwodef \fwbtx[
static int s_uccode[NUM_TEX_CHARS];

void InitUccodes()
{
   // Initialize the catcode table

   for (TeXChar c = FIRST_TEX_CHAR; c <= LAST_TEX_CHAR; ++c){
      s_uccode[c] = c;
   }
   TeXChar letter;
   for (letter = L'a'; letter <= L'z'; ++letter) {
      s_uccode[letter] = letter - L'a' + L'A';
   }
}


void SetUccode(TeXChar ch, int code)
{
   s_uccode[ch] = code;
}

int GetUccode(TeXChar ch)
{
   return s_uccode[ch];
}

int* UccodeLoc(TeXChar ch)
{
   return &s_uccode[ch];
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



Here's a table of \fwlit{sfcodes}s.

\fwbeginmacro
\fwmacroname{Declare other code functions}{175}\fwplusequals \fwodef \fwbtx[void InitSfcodes();
void SetSfcode(TeXChar ch, int sfcode);
int* SfcodeLoc(TeXChar ch);
int  GetSfcode(TeXChar ch);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 175, 177 and 179.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Sfcode table}{176}\fwequals \fwodef \fwbtx[
static int s_sfcode[NUM_TEX_CHARS];

void InitSfcodes()
{
   // Initialize the sfcode table

   for (TeXChar c = FIRST_TEX_CHAR; c <= LAST_TEX_CHAR; ++c){
      s_sfcode[c] = 1000;
   }
   TeXChar letter;
   for (letter = L'a'; letter <= L'z'; ++letter) {
      s_sfcode[letter] = 999;
   }
}


void SetSfcode(TeXChar ch, int code)
{
   s_sfcode[ch] = code;
}

int GetSfcode(TeXChar ch)
{
   return s_sfcode[ch];
}

int* SfcodeLoc(TeXChar ch)
{
   return &s_sfcode[ch];
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{Declare other code functions}{177}\fwplusequals \fwodef \fwbtx[void InitUccodes();
void SetUccode(TeXChar ch, int catcode);
int* UccodeLoc(TeXChar ch);
int  GetUccode(TeXChar ch);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 175, 177 and 179.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro



Here's a table of \fwlit{lccodes}s.
\fwbeginmacro
\fwmacroname{Lccode table}{178}\fwequals \fwodef \fwbtx[
static int s_lccode[NUM_TEX_CHARS];

void InitLccodes()
{
   // Initialize the lccode table

   for (TeXChar c = FIRST_TEX_CHAR; c <= LAST_TEX_CHAR; ++c){
      s_lccode[c] = c;
   }
   TeXChar letter;
   for (letter = L'A'; letter <= L'Z'; ++letter) {
      s_lccode[letter] = letter - L'A' + L'a';
   }
}


void SetLccode(TeXChar ch, int code)
{
   s_lccode[ch] = code;
}

int GetLccode(TeXChar ch)
{
   return s_lccode[ch];
}

int* LccodeLoc(TeXChar ch)
{
   return &s_lccode[ch];
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Declare other code functions}{179}\fwplusequals \fwodef \fwbtx[void InitLccodes();
void SetLccode(TeXChar ch, int catcode);
int* LccodeLoc(TeXChar ch);
int  GetLccode(TeXChar ch);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 175, 177 and 179.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro





Here is a table of \fwlit{mathcode}s. The table is accessed by the functions
\fwbeginmacro
\fwmacroname{Declare mathcode functions}{180}\fwequals \fwodef \fwbtx[void InitMathcodes();
void SetMathcode(TeXChar ch, int mathcode);
int* MathcodeLoc(TeXChar ch);
int  GetMathcode(TeXChar ch);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Implement mathcode functions}{181}\fwequals \fwodef \fwbtx[
static int s_mathcode[NUM_TEX_CHARS];

void InitMathcodes()
{
   TeXChar letter;
   for (letter = L'a'; letter <= L'z'; ++letter) {
      s_mathcode[letter] = 256 + letter;
   }
   for (letter = L'A'; letter <= L'Z'; ++letter) {
      s_mathcode[letter] = 256 + letter;
   }
}

void SetMathcode(TeXChar ch, int mathcode)
{
   s_mathcode[ch] = mathcode;
}

int* MathcodeLoc(TeXChar ch)
{
   return &s_mathcode[ch];
}

int  GetMathcode(TeXChar ch)
{
   return s_mathcode[ch];
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{Declare InitData}{182}\fwequals \fwodef \fwbtx[void InitData();
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{InitData}{183}\fwequals \fwodef \fwbtx[void InitData()
{
   InitCatcodes();
   InitUccodes();
   InitLccodes();
   InitMathcodes();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro




\fwsecb{5.9}{Converting of basic types to strings}


\fwbeginmacro
\fwmacroname{Conversion to strings}{184}\fwplusequals \fwodef \fwbtx[struct StringUtils {
   static void AppendCStr(const char*);
   static void AppendStr(const String&);
   static void AppendInt(int n);
   static void AppendScaled(Scaled s);
   static void AppendToks(const TokenList& tl);
   static void AppendToken(const TeXToken& tok);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 184.}
\fwusedin{This macro is invoked in definition 193.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Conversion to strings implementation}{185}\fwplusequals \fwodef \fwbtx[void StringUtils::AppendStr(const String& str)
{
   for (int k = 0; k < str.Size(); ++k){
      StringBuilder::Append(str[k]);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 185, 186, 187, 188, 189 and 190.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Conversion to strings implementation}{186}\fwplusequals \fwodef \fwbtx[void StringUtils::AppendCStr(const char* cstr)
{
   for (unsigned int k = 0; k < strlen(cstr); ++k){
      StringBuilder::Append(cstr[k]);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 185, 186, 187, 188, 189 and 190.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Conversion to strings implementation}{187}\fwplusequals \fwodef \fwbtx[
void printdigits(TeXChar dig[], int k)
{
   while ( k > 0){
      -- k;
      if (dig[k] < 10){
         StringBuilder::Append(L'0' + dig[k]);
      } else {
         StringBuilder::Append(L'A' + dig[k] -10);
      }
    }
}


void StringUtils::AppendInt(int n)
{
   TeXChar dig[17];
   int k = 0;
   if (n < 0){
      StringBuilder::Append(L'-');
      if (n > -100000000){
         n = -n;
      } else {
         int m = -1 - n;
         n = m / 10;
         m = m % 10 + 1;
         k = 1;
         if (m < 10){
            dig[0] = m;
         } else {
            dig[0] = 0;
            ++n;
         }
      }
   }
   do {
      dig[k] = n % 10;
      n = n / 10;
      ++k;
   } while (n != 0);

   printdigits(dig, k);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 185, 186, 187, 188, 189 and 190.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Conversion to strings implementation}{188}\fwplusequals \fwodef \fwbtx[
void StringUtils::AppendScaled(Scaled s)
{
   const int unity = 65536;
   const int half = unity / 2;

   if (s < 0){
      StringBuilder::Append(L'-');
      s = - s;
   }
   AppendInt(s / unity);
   StringBuilder::Append(L'.');
   s = 10 * (s % unity) + 5;
   int delta = 10;
   do {
     if (delta > unity){
        s = s + half - (delta / 2);
     }
     StringBuilder::Append(L'0' + ( s / unity));
     s = 10 * (s % unity);
     delta = delta * 10;
   } while ( s > delta);
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 185, 186, 187, 188, 189 and 190.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Conversion to strings implementation}{189}\fwplusequals \fwodef \fwbtx[void StringUtils::AppendToks(const TokenList& tl)
{
   for (TokenList::const_iterator it = tl.begin(); it != tl.end(); ++it){
      AppendToken(*it);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 185, 186, 187, 188, 189 and 190.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Conversion to strings implementation}{190}\fwplusequals \fwodef \fwbtx[void StringUtils::AppendToken(const TeXToken& tt)
{
   switch (tt.Type()){
      case TT_SYMBOL:
         if (tt.Symbol() == Symbols::NullCS()){
            AppendCStr("null");
         }else{
            AppendCStr("\\");
            String str = Symbols::GetName(tt.Symbol());
            AppendStr(str);
            if (str.Size() > 1){
              AppendCStr(" ");
            } else {
              char ch = str[0];
              if (('a' <= ch && ch <= 'z') ||
                  ('A' <= ch && ch <= 'Z')){
                AppendCStr(" ");
              }
            }
         }
         #ifdef LOGGING
         if (s_bLogSymbolNumber){
            LOG(", #" << tt.Symbol() );
         }
         #endif
         break;

      case TT_PAR:
         AppendCStr("\\par");
         break;
      case TT_MATCH:
         ++s_paramno;
         AppendCStr("#");
         AppendInt(1 + s_paramno);
         break;
      case TT_END_MATCH:
         AppendCStr("-->");
         break;
      case TT_ENDV:
         AppendCStr("ENDV");
         break;
      case TT_ENDR:
         AppendCStr("ENDR");
         break;
      case TT_OUTPARAM:
         AppendCStr("#");
         AppendInt(1+(int)tt.ChrCode());
         break;
      default:
         StringBuilder::Append(tt.ChrCode());
         break;
   }

}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 185, 186, 187, 188, 189 and 190.}
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



\fwsecb{5.10}{Input and Output files}


\fwbeginmacro
\fwmacroname{Input and Output files}{191}\fwequals \fwodef \fwbtx[static OutputByteFile* g_writeFile[15];
static InputByteFile* g_readFile[15];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 137.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Implement Input and Output files}{192}\fwequals \fwodef \fwbtx[OutputByteFile* Global::g_writeFile[15];
InputByteFile* Global::g_readFile[15];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 194.}
\fwendmacronotes
\fwendmacro



\fwsecb{5.11}{Physical layout}

\fwbeginmacro
\fwfilename{basicdata.h}{193}\fwequals \fwodef \fwbtx[#ifndef BASICDATA_H
#define BASICDATA_H
#include "platform.h"
#include "symbols.h"
#include <list>

]fwetx=%
\fwmacroname{Basic type declarations}{142}\fwbtx[
]fwetx=%
\fwmacroname{Parameter struct declaration}{137}\fwbtx[
]fwetx=%
\fwmacroname{Declare catcode functions}{172}\fwbtx[
]fwetx=%
\fwmacroname{Declare other code functions}{175}\fwbtx[
]fwetx=%
\fwmacroname{Declare mathcode functions}{180}\fwbtx[
]fwetx=%
\fwmacroname{Declare InitData}{182}\fwbtx[
]fwetx=%
\fwmacroname{TokenList logging}{169}\fwbtx[
]fwetx=%
\fwmacroname{TeXToken logging}{161}\fwbtx[
]fwetx=%
\fwmacroname{Conversion to strings}{184}\fwbtx[


#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{basicdata.cpp}{194}\fwequals \fwodef \fwbtx[#include "basicdata.h"
#include "platform.h"
]fwetx=%
\fwmacroname{Parameter definitions}{139}\fwbtx[
]fwetx=%
\fwmacroname{Implement catcode functions}{173}\fwbtx[
]fwetx=%
\fwmacroname{Uccode table}{174}\fwbtx[
]fwetx=%
\fwmacroname{Lccode table}{178}\fwbtx[
]fwetx=%
\fwmacroname{Sfcode table}{176}\fwbtx[
]fwetx=%
\fwmacroname{Implement mathcode functions}{181}\fwbtx[
]fwetx=%
\fwmacroname{InitData}{183}\fwbtx[
]fwetx=%
\fwmacroname{TeXToken implementation}{157}\fwbtx[
]fwetx=%
\fwmacroname{TeXToken logging imp}{162}\fwbtx[
]fwetx=%
\fwmacroname{TokenList implementation}{168}\fwbtx[
]fwetx=%
\fwmacroname{TokenList logging imp}{170}\fwbtx[
]fwetx=%
\fwmacroname{Conversion to strings implementation}{185}\fwbtx[
]fwetx=%
\fwmacroname{Implement Input and Output files}{192}\fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro






\fwseca{6}{Saving and restoring definitions}

In this short section we describe the method for saving and
restoring definitions. When we are inside a group and and make
a definition the outside definition must be saved and restored
when the group ends.

\fwbeginmacro
\fwmacroname{Restore interface}{195}\fwequals \fwodef \fwbtx[#include "symbols.h"

void NewSaveLevel();
void SaveRestoration(Restoration*, bool bGlobal);
void EndSaveLevel();
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 208.}
\fwendmacronotes
\fwendmacro




Whenever we make a definition we have to decide whether the
definition was made in the same level as the current level.
If so the old definition is overwritten, otherwise it is
pushed onto the restore stack.

A \fwlit{Restoratation} encapsulates the action taken to later
restore data. It is a virtual class. When we later create
for instance a derived \fwlit{IntegerRestoration} we specify
the old (integer) data to be restored. All \fwlit{Restorations}
have a \fwlit{void*} member that points to the address where
the restoration is to take place.

\fwbeginmacro
\fwmacroname{class Restoration}{196}\fwequals \fwodef \fwbtx[class Restoration {
private:
   void* m_loc;
   const char* m_id;
public:
   virtual ~Restoration() {};
   virtual void Restore() = 0;
   void* Loc()
   {
     return m_loc;
   }
   const char* Id()
   {
     return m_id;
   }

protected:
   Restoration(void* loc, const char* id)
      : m_loc(loc), m_id(id)
   {};
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 208.}
\fwendmacronotes
\fwendmacro



The RestoreStack contains all the restorations created by the
interpretter.  It is a stack of \fwlit{RestoreLevel}s. Each \fwlit{RestoreLevel}
is a list of restorations created in a particular level.

\fwbeginmacro
\fwmacroname{RestoreStack}{197}\fwequals \fwodef \fwbtx[#include <list>
class RestoreLevel : public std::list<Restoration*> {

};

class RestoreStack : public std::list<RestoreLevel*> {

};

static RestoreStack s_restoreStack;

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 209.}
\fwendmacronotes
\fwendmacro



We first have a function to start a new save level.
\fwbeginmacro
\fwmacroname{Restore implementation}{198}\fwplusequals \fwodef \fwbtx[void NewSaveLevel()
{
   RestoreLevel* newlevel = new RestoreLevel;
   s_restoreStack.push_back(newlevel);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 198, 199 and 201.}
\fwusedin{This macro is invoked in definition 209.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Restore implementation}{199}\fwplusequals \fwodef \fwbtx[void SaveRestoration(Restoration* restoration, bool bGlobal)
{
   if (s_restoreStack.size() != 0){
      if (bGlobal){
         ]fwetx=%
\fwmacroname{Kill all restorations of the same location}{200}\fwbtx[
      } else {
         LOG("\nSaving restoration for " << restoration -> Id());
         RestoreLevel* level = s_restoreStack.back();
         // see if there's already a restoration
         RestoreLevel::iterator it = level -> begin();
         bool found = false;
         while (it != level -> end()){
            if ((*it) -> Loc() == restoration -> Loc()){
               found = true;
               break;
            }
            ++it;
         }
         if (!found)
            level -> push_back(restoration);
      }
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 198, 199 and 201.}
\fwusedin{This macro is invoked in definition 209.}
\fwendmacronotes
\fwendmacro



The idea is that if we make a \fwlit{\char`\\global} assignment then
we don't want a restoration to happen at all.

\fwbeginmacro
\fwmacroname{Kill all restorations of the same location}{200}\fwequals \fwodef \fwbtx[LOG("\n   Killing restorations for " << restoration -> Id());
RestoreStack::iterator it;
for (it = s_restoreStack.begin(); it != s_restoreStack.end(); ++it){
   RestoreLevel* level = *it;
   RestoreLevel::iterator j = level -> begin();
   while (j != level -> end()){
      RestoreLevel::iterator next = j;
      ++next;
      if ((*j) -> Loc() == restoration -> Loc()){
        delete (*j);
        level -> erase(j);
      }
      j = next;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 199.}
\fwendmacronotes
\fwendmacro


Next, a function to leave a save level. This must
traverse the restorations in reverse order and put
definitions back the way they were.

\fwbeginmacro
\fwmacroname{Restore implementation}{201}\fwplusequals \fwodef \fwbtx[void EndSaveLevel()
{
   RestoreLevel* exitlevel = s_restoreStack.back();
   s_restoreStack.pop_back();
   std::list<Restoration*>::reverse_iterator it = exitlevel -> rbegin();
   while (it != (exitlevel -> rend())){
      (*it) -> Restore();
      delete (*it);
      ++it;
   }
   delete exitlevel;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 198, 199 and 201.}
\fwusedin{This macro is invoked in definition 209.}
\fwendmacronotes
\fwendmacro


Finally, here are the derived classes of \fwlit{Restoration}.

\fwbeginmacro
\fwmacroname{class IntRestoration}{202}\fwequals \fwodef \fwbtx[class IntRestoration  : public Restoration {
private:
   int m_oldValue;
public:
   IntRestoration(int* p, const char* id)
       : Restoration(p, id),
         m_oldValue(*p)
   {}

   void Restore();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 208.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{IntRestoration implementation}{203}\fwequals \fwodef \fwbtx[   void IntRestoration::Restore()
   {
      LOG("\nRestoring " << Id() << " to " << m_oldValue);
      int& loc = * (int*) Loc();
      loc = m_oldValue;
   }

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 209.}
\fwendmacronotes
\fwendmacro


This is for token registers

\fwbeginmacro
\fwmacroname{class ToksRestoration}{204}\fwequals \fwodef \fwbtx[class TokenList;

class ToksRestoration  : public Restoration {
private:
   TokenList m_oldValue;
public:
   ToksRestoration(TokenList* p, const char* id)
       : Restoration(p, id),
         m_oldValue(*p)
   {}

   void Restore();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 208.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{ToksRestoration implementation}{205}\fwequals \fwodef \fwbtx[   void ToksRestoration::Restore()
   {
      LOG("\nRestoring " << Id() << " to " << m_oldValue);
      TokenList& loc = * (TokenList*) Loc();
      loc = m_oldValue;
   }

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 209.}
\fwendmacronotes
\fwendmacro




This one is used to restore definitions of symbols

\fwbeginmacro
\fwmacroname{class DefRestoration}{206}\fwequals \fwodef \fwbtx[class SymbolData;

class DefRestoration  : public Restoration {
private:
   SymbolData* m_oldValue;
public:
   DefRestoration(SymbolData** p, const char* id)
       : Restoration(p, id),
         m_oldValue(*p)
   {}

   void Restore();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 208.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{DefRestoration implementation}{207}\fwequals \fwodef \fwbtx[   void DefRestoration::Restore()
   {
      LOG("\nRestoring " << Id());
      SymbolData*& loc = * (SymbolData**) Loc();
      loc = m_oldValue;
   }

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 209.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwfilename{restore.h}{208}\fwequals \fwodef \fwbtx[#ifndef RESTORE_H
#define RESTORE_H
#include "basicdata.h"
]fwetx=%
\fwmacroname{class Restoration}{196}\fwbtx[
]fwetx=%
\fwmacroname{class IntRestoration}{202}\fwbtx[
]fwetx=%
\fwmacroname{class ToksRestoration}{204}\fwbtx[
]fwetx=%
\fwmacroname{class DefRestoration}{206}\fwbtx[
]fwetx=%
\fwmacroname{Restore interface}{195}\fwbtx[
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{restore.cpp}{209}\fwequals \fwodef \fwbtx[#include "restore.h"
#include "platform.h"
]fwetx=%
\fwmacroname{RestoreStack}{197}\fwbtx[
]fwetx=%
\fwmacroname{Restore implementation}{198}\fwbtx[
]fwetx=%
\fwmacroname{IntRestoration implementation}{203}\fwbtx[
]fwetx=%
\fwmacroname{ToksRestoration implementation}{205}\fwbtx[
]fwetx=%
\fwmacroname{DefRestoration implementation}{207}\fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



Some tests

\fwbeginmacro
\fwmacroname{Restore tests}{210}\fwplusequals \fwodef \fwbtx[
bool TestStack()
{
   int x,y;
   x = 5;
   y = 7;
   NewSaveLevel();
     SaveRestoration(new IntRestoration(&x, "x"), false);
     x = 2;

     SaveRestoration(new IntRestoration(&y, "y"), false);
     y = 3;
     NewSaveLevel();
       SaveRestoration(new IntRestoration(&x, "x"), false);
       x = 0;

       SaveRestoration(new IntRestoration(&y, "y"), true);
       y = 0;
     EndSaveLevel();
     ASSERT(x == 2 && y == 0);
     x = 1;
   EndSaveLevel();
   return (x == 5 && y == 0);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 210.}
\fwusedin{This macro is invoked in definition 212.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Restore TestTable entries}{211}\fwequals \fwodef \fwbtx[{"testa", TestStack},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 212.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{restore.t.cpp}{212}\fwequals \fwodef \fwbtx[#include "restore.h"
#include <string>
#include <iostream>
]fwetx=%
\fwmacroname{Test jig}{8}\fwoparen \fwoquote\fwmacroname{Restore tests}{210}\fwcquote\fwcomma \fwoquote\fwmacroname{Restore TestTable entries}{211}\fwcquote\fwcparen \fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwseca{7}{The Token subsystem}

\fwsecb{7.1}{Introduction}

The token subsystem manages the stream of tokens that the
\fwlit{MacroProcessor} sybsystem sees. It maintains a stack of
\fwlit{TokenSource}'s. \fwlit{TokenSource} is an abstract class that
represents a place that \fwlit{TeXToken}s come from. These are (1)
character streams, such as a file, that need to be tokenized, (2)
\fwlit{tokenlist}s that were backed up say during a macro expansion.



\fwsecb{7.2}{Token Sources}

\fwlit{TokenSource} is can abstract class. It is a place that we can get
tokens from. The main concrete derived classes
are \fwlit{FileTokenizer} which tokenizes a file, and \fwlit{TokenList} which
represents a saved list of tokens.

\fwbeginmacro
\fwmacroname{class TokenSource}{213}\fwequals \fwodef \fwbtx[class TokenSource {
public:
   virtual ~TokenSource();
   virtual bool bEmpty() const = 0;
   virtual void GetToken(TeXToken*) = 0;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 267.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{TokenSource implementation}{214}\fwequals \fwodef \fwbtx[TokenSource::~TokenSource()
{
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{class TokenListTokenSource}{215}\fwequals \fwodef \fwbtx[class TokenListTokenSource : public TokenSource {
private:
   TokenList& m_list;
   TokenList::const_iterator m_iter;
public:
   TokenListTokenSource(TokenList& pList);
   ~TokenListTokenSource();
   bool bEmpty() const;
   void GetToken(TeXToken*);
private:
   // Unimplemented
   TokenListTokenSource(const TokenListTokenSource&);
   TokenListTokenSource& operator=(const TokenListTokenSource&);

};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 267.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{TokenListTokenSource imp}{216}\fwequals \fwodef \fwbtx[
TokenListTokenSource::TokenListTokenSource(TokenList& lis)
   : m_list(lis),
     m_iter(lis.begin())
{

}

TokenListTokenSource::~TokenListTokenSource()
{
   m_list.RemoveReference();
}

bool TokenListTokenSource::bEmpty() const
{
   return m_iter == m_list.end();
}

void TokenListTokenSource::GetToken(TeXToken* tt)
{
   *tt = *m_iter;
   ++m_iter;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro





\fwsecb{7.3}{Tokenizer}

A \fwlit{Tokenizer} is constructed with a \fwlit{LineSource}. The \fwlit{LineSource}
provides buffered input.


It must handle the \fwlit{\char`\^\char`\^} convention, replacing them with the correct
characters while tokenizing.

Handle Omega Tranlation Processes.


\fwbeginmacro
\fwmacroname{class Tokenizer}{217}\fwequals \fwodef \fwbtx[class TokenizerImp;

class Tokenizer : public TokenSource {
private:
   TokenizerImp* m_tokenizerImp;
   TokenList*    m_pTap;
public:
   Tokenizer(LineSource* pLineSource);
   ~Tokenizer();
   bool bEmpty() const;
   void GetToken(TeXToken*);
   void StartTap(TokenList*);
   void StopTap();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 267.}
\fwendmacronotes
\fwendmacro




Should alignstate be part of the macroprocessor? I think so.
There should be an overall brace level and a local brace level
for reading lines of a file via \fwlit{\char`\\read}, and maybe more.

\fwbeginmacro
\fwmacroname{alignstate}{218}\fwequals \fwodef \fwbtx[static int s_alignState = 0;]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Tokenizer implementation}{219}\fwplusequals \fwodef \fwbtx[Tokenizer::Tokenizer(LineSource* pLineSource)
   : m_tokenizerImp(new TokenizerImp (pLineSource) ),
     m_pTap(0)
{
}

Tokenizer::~Tokenizer()
{
   delete m_tokenizerImp;
   m_tokenizerImp = 0;
}

void Tokenizer::GetToken(TeXToken* tt)
{
   m_tokenizerImp -> GetToken(tt);
   if (m_pTap != 0){
      m_pTap -> push_back(*tt);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 219, 220 and 221.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Tokenizer implementation}{220}\fwplusequals \fwodef \fwbtx[bool Tokenizer::bEmpty() const
{
   return m_tokenizerImp -> bEmpty();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 219, 220 and 221.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Tokenizer implementation}{221}\fwplusequals \fwodef \fwbtx[   void Tokenizer::StartTap(TokenList* pTL)
   {
      ASSERT(m_pTap == 0);
      ASSERT(pTL != 0);
      m_pTap = pTL;
   }
   void Tokenizer::StopTap()
   {
      m_pTap = 0;
   }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 219, 220 and 221.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{class TokenizerImp}{222}\fwequals \fwodef \fwbtx[enum State {STATE_NEWLINE, STATE_MIDLINE, STATE_SKIPPING_BLANKS};


class TokenizerImp {
private:
   mutable LineOfText m_line; // allow refill without const violation
   mutable State m_state;
   mutable LineSource* m_pLineSource; // ditto...
public:
   TokenizerImp(LineSource* pLineSource);
   ~TokenizerImp();
   bool bEmpty() const;
   void GetToken(TeXToken*);
   TeXChar GetNextChar();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{TokenizerImp implementation}{223}\fwplusequals \fwodef \fwbtx[TokenizerImp::TokenizerImp(LineSource* pLineSource)
   : m_state(STATE_NEWLINE),
     m_pLineSource(pLineSource)

{
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 223, 224, 225 and 227.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{TokenizerImp implementation}{224}\fwplusequals \fwodef \fwbtx[TokenizerImp::~TokenizerImp()
{
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 223, 224, 225 and 227.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{TokenizerImp implementation}{225}\fwplusequals \fwodef \fwbtx[bool TokenizerImp::bEmpty() const
{
   while (m_line.bEmpty()){
     if (m_pLineSource -> bEmpty())
        return true;
     m_pLineSource -> GetLine(&m_line);
   }
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 223, 224, 225 and 227.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{TokenizerImp::GetNextChar}{226}\fwequals \fwodef \fwbtx[TeXChar TokenizerImp::GetNextChar()
{
   while (true) {
      TeXChar ch = m_line.chGet();
      if ( GetCatcode(ch) != CC_SUPER){
        return ch;
      }
      if ( (m_line.nRemaining() >= 2) && ( m_line.chPeek(0) == ch) ){
         // Have a ^^
         // ... check for two hex digits 0-9a-f
         if (m_line.nRemaining() >= 3){
            if ( bHexDigit(m_line.chPeek(1)) && bHexDigit(m_line.chPeek(2)) ){
               m_line.chGet(); // Skip the second ^
               unsigned int d0 = uHexToInt(m_line.chGet());
               unsigned int d1 = uHexToInt(m_line.chGet());
               unsigned int n = (d0 << 4) | d1;
               TeXChar c = n;
               m_line.Putback(c);
               continue; // go back to top of while loop
            }
         }

         TeXChar ch1 =  m_line.chPeek(1);
         if (0 <= ch1 && ch1 < 128){
             ch1 = m_line.chGet(); // Get the second ^
             ch1 = m_line.chGet(); // Get the char
             if (ch1 >= 64)
                 ch1 -= 64;
             else
                 ch1 += 64;
             m_line.Putback(ch1);
             continue;
         }
         // if we reach this point we have ch = ^ but there
         // is no special continuation. The character is
         // just the ^
         return ch;
      } else {
         return ch;
      }
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{TokenizerImp implementation}{227}\fwplusequals \fwodef \fwbtx[void TokenizerImp::GetToken(TeXToken* tt)
{
   // Clear old token
   tt->SetType(TT_SPACE);
   tt->SetChrCode('\0');
   tt->SetSymbol(0);

   // The body of this loop may be executed more than once
   // if characters are ignored.
   while (!bEmpty()) {
      // Todo: Check if the line is empty. If so
      // get another from the LineSource. If that
      // is empty, ...?
      // GetNextChar() is like  m_line.chGet() but
      // it looks for ^^.. sequences
      TeXChar ch = GetNextChar();
      Catcode cat = GetCatcode(ch);
      switch (cat) {
         ]fwetx=%
\fwmacroname{Tokenizer cases}{228}\fwbtx[
      }
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 223, 224, 225 and 227.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Tokenizer cases}{228}\fwplusequals \fwodef \fwbtx[case CC_ESCAPE:{
   tt -> SetType(TT_SYMBOL);
   if (m_line.bEmpty()){
      tt -> SetSymbol(Symbols::NullCS());
   }else{
      ch = GetNextChar();
      cat = GetCatcode(ch);
      if (cat == CC_LETTER){
         StringBuilder::Append(ch);
         m_state = STATE_SKIPPING_BLANKS;
         // scan rest of cs
         bool loop = true;
         while (!m_line.bEmpty() && loop) {
            ch = GetNextChar();
            cat = GetCatcode(ch);
            if (cat == CC_LETTER){
               StringBuilder::Append(ch);
            }else{
               // Replace the last char
               m_line.Putback(ch);
               loop = false;
            }
         }
      } else if (cat == CC_SPACE){
         m_state = STATE_SKIPPING_BLANKS;
         StringBuilder::Append(ch);
      } else {
         m_state = STATE_MIDLINE;
         StringBuilder::Append(ch);
      }
      String str = StringBuilder::Create();
      // lookup cs in symbols table
      Symbols::SymId id;
      Symbols::GetId(str, &id, Symbols::CREATE);
      tt -> SetSymbol(id);
      return;
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Tokenizer cases}{229}\fwplusequals \fwodef \fwbtx[case CC_LEFTBRACE:{
   ++s_alignState;
   // Is m_alignState part of this class or is it
   // global to the input stack?
   m_state = STATE_MIDLINE;
   tt -> SetType( TT_LEFT_BRACE );
   tt -> SetChrCode(ch);
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Tokenizer cases}{230}\fwplusequals \fwodef \fwbtx[case CC_RIGHTBRACE:{
   --s_alignState;
   m_state = STATE_MIDLINE;
   tt -> SetType(TT_RIGHT_BRACE);
   tt -> SetChrCode(ch);
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Tokenizer cases}{231}\fwplusequals \fwodef \fwbtx[case CC_MATHSHIFT:{
   m_state = STATE_MIDLINE;
   tt -> SetType(TT_MATH_SHIFT);
   tt -> SetChrCode(ch);
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Tokenizer cases}{232}\fwplusequals \fwodef \fwbtx[case CC_ALIGNTAB:{
   m_state = STATE_MIDLINE;
   tt -> SetType(TT_TAB);
   tt -> SetChrCode(ch);
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Tokenizer cases}{233}\fwplusequals \fwodef \fwbtx[case CC_ENDOFLINE:{
   m_line.SkipToEnd(); // so next time we go to next line...
   if (m_state == STATE_MIDLINE){
      tt -> SetType(TT_SPACE);
      tt -> SetChrCode(' '); // Unicode 0020
      m_state = STATE_NEWLINE;
      return;
   }else if (m_state == STATE_NEWLINE){
      // blank line -- should look like \par
      tt -> SetType(TT_SYMBOL);
      tt -> SetChrCode(0);
      String par = StringBuilder::Create("par");
      int id;
      Symbols::GetId(par, &id, Symbols::NO_CREATE);
      tt -> SetSymbol(id);
      m_state = STATE_NEWLINE;
      // Check outer validity...
      return;
   }else{
      m_state = STATE_NEWLINE;
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Tokenizer cases}{234}\fwplusequals \fwodef \fwbtx[case CC_PARAM:{
   m_state = STATE_MIDLINE;
   tt -> SetType(TT_PARAM);
   tt -> SetChrCode(ch);
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Tokenizer cases}{235}\fwplusequals \fwodef \fwbtx[case CC_SUPER:{
   m_state = STATE_MIDLINE;
   tt -> SetType(TT_SUPERSCRIPT);
   tt -> SetChrCode(ch);
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Tokenizer cases}{236}\fwplusequals \fwodef \fwbtx[case CC_SUBS:{
   m_state = STATE_MIDLINE;
   tt -> SetType(TT_SUBSCRIPT);
   tt -> SetChrCode(ch);
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro



In the case of an ignore code we go back to the top
and get the next character.

\fwbeginmacro
\fwmacroname{Tokenizer cases}{237}\fwplusequals \fwodef \fwbtx[case CC_IGNORE:{
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro



If we see a space and the state is not \fwlit{STATE\_MIDLINE} then
we drop through to the top of the loop again. We ignore the
space in that case.

\fwbeginmacro
\fwmacroname{Tokenizer cases}{238}\fwplusequals \fwodef \fwbtx[case CC_SPACE:{
   if (m_state == STATE_MIDLINE){
      tt -> SetType(TT_SPACE);
      tt -> SetChrCode(' '); // Unicode 00020 ?
      m_state = STATE_SKIPPING_BLANKS;
      return;
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Tokenizer cases}{239}\fwplusequals \fwodef \fwbtx[case CC_LETTER:{
   m_state = STATE_MIDLINE;
   tt -> SetType(TT_LETTER);
   tt -> SetChrCode(ch);
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Tokenizer cases}{240}\fwplusequals \fwodef \fwbtx[case CC_OTHER:{
   m_state = STATE_MIDLINE;
   tt -> SetType(TT_OTHER);
   tt -> SetChrCode(ch);
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Tokenizer cases}{241}\fwplusequals \fwodef \fwbtx[case CC_ACTIVE:{
   // Regardless of state...
   tt -> SetType(TT_ACTIVE);
   tt -> SetChrCode(ch);
   m_state = STATE_MIDLINE;
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Tokenizer cases}{242}\fwplusequals \fwodef \fwbtx[case CC_COMMENT:{
   m_line.SkipToEnd();
   // and try again...
   m_state = STATE_NEWLINE;
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Tokenizer cases}{243}\fwplusequals \fwodef \fwbtx[case CC_INVALID:{
   LOG("\nInvalid character!");
   ASSERT(false);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Tokenizer cases}{244}\fwplusequals \fwodef \fwbtx[default:
   LOG("\nDefault case in tokenizer -- can't happen");
   ASSERT(false);
   break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243 and 244.}
\fwusedin{This macro is invoked in definition 227.}
\fwendmacronotes
\fwendmacro









\fwbeginmacro
\fwmacroname{function bHexDigit}{245}\fwequals \fwodef \fwbtx[bool bHexDigit(TeXChar c)
{
   return ( '0' <= c && c <= '9') || ( 'a' <= c && c <= 'z');
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{function uHexToInt}{246}\fwequals \fwodef \fwbtx[unsigned int uHexToInt(TeXChar c)
{
   if ('0' <= c && c <= '9') {
      return c - '0';
   } else if ( 'a' <= c && c <= 'z') {
      return c  + 10 - 'a';
   } else {
      ASSERT(false);
      return 0;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro







\fwsecb{7.4}{Input Stack}


\fwbeginmacro
\fwmacroname{class InputStack}{247}\fwequals \fwodef \fwbtx[
class InputStack {
public:
   InputStack();
   ~InputStack();
   static bool bEmpty();
   static TeXToken& CurTok();
   static void GetRawToken();
   static void Push(TokenSource* pSource);
   static void Putback(TeXToken);
   static void Putback(TokenList& tl);
   static void EndInput();
   static void Clean();
   static bool StartTap(TokenList*);
   static void StopTap();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 267.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{function bSymbol}{248}\fwequals \fwodef \fwbtx[inline bool bSymbol(TeXToken* tt)
{
   return TT_SYMBOL == (tt -> Type());
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 267.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{function bActive}{249}\fwequals \fwodef \fwbtx[inline bool bActive(const TeXToken* tt)
{
   return TT_ACTIVE == (tt -> Type());
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 267.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Clean Stack}{250}\fwmany{}\fwequals \fwodef \fwbtx[while (!s_stack.empty() && s_stack.back() -> bEmpty()){
   delete s_stack.back();
   s_stack.pop_back();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 253 and 253.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{InputStack implementation}{251}\fwplusequals \fwodef \fwbtx[
namespace{
   std::vector<TokenSource*> s_stack;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 251, 252, 253, 254, 255, 256 and 257.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{InputStack implementation}{252}\fwplusequals \fwodef \fwbtx[
static TeXToken s_curtok;

TeXToken& InputStack::CurTok()
{
   return s_curtok;
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 251, 252, 253, 254, 255, 256 and 257.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{InputStack implementation}{253}\fwplusequals \fwodef \fwbtx[
InputStack::InputStack()
{
}

InputStack::~InputStack()
{
}

bool InputStack::bEmpty()
{
   return s_stack.empty();
}

void InputStack::Clean()
{
  ]fwetx=%
\fwmacroname{Clean Stack}{250}\fwbtx[
}


void InputStack::Push(TokenSource* pSource)
{
   LOG("\nPushing token source onto input stack.");
   if (pSource == 0){
     LOG("\nNULL source!");
     ASSERT(false);
   } else if (pSource -> bEmpty()){
     LOG("\nIgnoring empty source");
   } else {
      s_stack.push_back(pSource);
   }
}

void InputStack::GetRawToken()
{
   ]fwetx=%
\fwmacroname{Clean Stack}{250}\fwbtx[
   s_stack.back() -> GetToken(&s_curtok);
   LOG("\nInput: " << s_curtok);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 251, 252, 253, 254, 255, 256 and 257.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{InputStack implementation}{254}\fwplusequals \fwodef \fwbtx[
void InputStack::Putback(TeXToken tt)
{
   LOG("\nPutback: " << tt);
   TokenList* tl = new TokenList;
   tl -> push_back(tt);
   tl -> AddReference();

   TokenListTokenSource* ts = new TokenListTokenSource(*tl);
   s_stack.push_back(ts);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 251, 252, 253, 254, 255, 256 and 257.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{InputStack implementation}{255}\fwplusequals \fwodef \fwbtx[void InputStack::Putback(TokenList& tl)
{
   if (tl.size() > 0){
      Push(new TokenListTokenSource( tl ));
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 251, 252, 253, 254, 255, 256 and 257.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{InputStack implementation}{256}\fwplusequals \fwodef \fwbtx[void InputStack::EndInput()
{
  while(true){
   TokenSource* pTS = s_stack.back();
   s_stack.pop_back();
   Tokenizer* pT = dynamic_cast<Tokenizer*>(pTS);
   if (pT != 0){
      break;
   }
  }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 251, 252, 253, 254, 255, 256 and 257.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{InputStack implementation}{257}\fwplusequals \fwodef \fwbtx[bool InputStack::StartTap(TokenList* pTL)
{
   TokenSource* pTS = s_stack.back();
   Tokenizer* pT = dynamic_cast<Tokenizer*>(pTS);
   if (pT == 0){
      return false;
   } else {
      pT -> StartTap(pTL);
      return true;
   }
}
void InputStack::StopTap()
{
   TokenSource* pTS = s_stack.back();
   Tokenizer* pT = dynamic_cast<Tokenizer*>(pTS);
   if (pT == 0){
      ASSERT(pT == 0);
   } else {
      pT -> StopTap();
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 251, 252, 253, 254, 255, 256 and 257.}
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro





Here's the initalization function

\fwbeginmacro
\fwmacroname{Declare Init}{258}\fwequals \fwodef \fwbtx[void InitTokens();
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 267.}
\fwendmacronotes
\fwendmacro


and implementation

\fwbeginmacro
\fwmacroname{Init}{259}\fwequals \fwodef \fwbtx[void InitTokens()
{
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 268.}
\fwendmacronotes
\fwendmacro




\fwsecb{7.5}{Tests}


\fwbeginmacro
\fwmacroname{Tokens tests}{260}\fwplusequals \fwodef \fwbtx[bool TestTokenizer()
{
   InitTokens();
   Filename fn ("trip.tex");
   InputByteFile bfile;
   bfile.Open(fn);
   Latin_1_in latin1filt(bfile);
   LineSource lineSource(latin1filt);
   Tokenizer tokenizer(&lineSource);
   LogFile::Start();
   TeXToken tt;
   while (!tokenizer.bEmpty()){
      tokenizer.GetToken(&tt);
      LOG("\n" << tt);
   }

   return CompareLog("trip1.dat", "Tokens.TestTokenizer");
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 260, 261 and 264.}
\fwusedin{This macro is invoked in definition 269.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Tokens tests}{261}\fwplusequals \fwodef \fwbtx[bool TestTokenList()
{
   InitTokens();
   TokenList* tl = new TokenList();
   TeXToken tok1, tok2;
   tok1.SetType(TT_LETTER);
   tok1.SetChrCode('D');
   tok2.SetType(TT_OTHER);
   tok2.SetChrCode('4');

   tl -> push_back(tok1);
   tl -> push_back(tok2);

   TokenListTokenSource ts(*tl);
   ASSERT(!ts.bEmpty());
   TeXToken tok;
   ts.GetToken(&tok);
   ASSERT(tok.Type() == TT_LETTER);
   ASSERT(tok.ChrCode() == 'D');
   ASSERT(!ts.bEmpty());

   return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 260, 261 and 264.}
\fwusedin{This macro is invoked in definition 269.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{tok1.tex}{262}\fwequals \fwodef \fwbtx[A test \foobar
another line. Follwed by an empty line

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{tok1.dat}{263}\fwequals \fwodef \fwbtx[
(D   Letter)
(4   Other)
(D   Letter)
(A   Letter)
(    Space)
(t   Letter)
(e   Letter)
(s   Letter)
(t   Letter)
(    Space)
(\foobar,Symbol[1297])
(a   Letter)
(n   Letter)
(o   Letter)
(t   Letter)
(h   Letter)
(e   Letter)
(r   Letter)
(    Space)
(l   Letter)
(i   Letter)
(n   Letter)
(e   Letter)
(.   Other)
(    Space)
(F   Letter)
(o   Letter)
(l   Letter)
(l   Letter)
(w   Letter)
(e   Letter)
(d   Letter)
(    Space)
(b   Letter)
(y   Letter)
(    Space)
(a   Letter)
(n   Letter)
(    Space)
(e   Letter)
(m   Letter)
(p   Letter)
(t   Letter)
(y   Letter)
(    Space)
(l   Letter)
(i   Letter)
(n   Letter)
(e   Letter)
(    Space)
(\u(0)   \Par)
(D   Letter)
(4   Other)]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Tokens tests}{264}\fwplusequals \fwodef \fwbtx[bool TestInputStack()
{
   InitTokens();
   TokenList* tl1 = new TokenList();
   TokenList* tl2 = new TokenList();

   InputStack tstk;

   TeXToken tok1, tok2;
   tok1.SetType(TT_LETTER);
   tok1.SetChrCode('D');

   tok2.SetType(TT_OTHER);
   tok2.SetChrCode('4');

   tl1 -> push_back(tok1);
   tl1 -> push_back(tok2);

   tl2 -> push_back(tok2);
   tl2 -> push_back(tok1);

   // Set up the tokenizer
   Filename fn ("tok1.tex");
   InputByteFile bfile;
   bfile.Open(fn);
   Latin_1_in latin1filt(bfile);
   LineSource lineSource(latin1filt);
   Tokenizer* ts3 = new Tokenizer(&lineSource);

   // Push the first token list, the tokenizer, and the second token list
   TokenListTokenSource* ts1 = new TokenListTokenSource(*tl1);
   TokenListTokenSource* ts2 = new TokenListTokenSource(*tl2);
   tstk.Push(ts1);
   tstk.Push(ts3);
   tstk.Push(ts2);
   // ... then putback a token
   tstk.Putback(tok1);
   LogFile::Start();
   while (!tstk.bEmpty()){
      tstk.GetRawToken();
      LOG("\n" << tstk.CurTok());
   }


   return CompareLog("tok1.dat", "Tokens.TestInputStack");
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 260, 261 and 264.}
\fwusedin{This macro is invoked in definition 269.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Tokens TestTable}{265}\fwplusequals \fwodef \fwbtx[{"tokenizer", TestTokenizer},
{"tokenlist", TestTokenList},
{"inputstack", TestInputStack},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 265.}
\fwusedin{This macro is invoked in definition 269.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwfilename{test1.tex}{266}\fwequals \fwodef \fwbtx[aA02 *?^_^^M^^5e^v\boo
x 0{}$&#\boo   % here's some more
%

    test
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwsecb{7.6}{Physical layout}

\fwbeginmacro
\fwfilename{tokens.h}{267}\fwequals \fwodef \fwbtx[#ifndef TOKENSOURCE_H
#define TOKENSOURCE_H

#include "platform.h"
#include "textio.h"
#include "symbols.h"
#include "basicdata.h"
#include <vector>
#include <list>

]fwetx=%
\fwmacroname{Declare Init}{258}\fwbtx[
]fwetx=%
\fwmacroname{class TokenSource}{213}\fwbtx[
]fwetx=%
\fwmacroname{class TokenListTokenSource}{215}\fwbtx[
]fwetx=%
\fwmacroname{class Tokenizer}{217}\fwbtx[
]fwetx=%
\fwmacroname{class InputStack}{247}\fwbtx[
]fwetx=%
\fwmacroname{function bSymbol}{248}\fwbtx[
]fwetx=%
\fwmacroname{function bActive}{249}\fwbtx[

#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{tokens.cpp}{268}\fwequals \fwodef \fwbtx[#include "tokens.h"
#include "textio.h"
]fwetx=%
\fwmacroname{alignstate}{218}\fwbtx[
]fwetx=%
\fwmacroname{Init}{259}\fwbtx[
]fwetx=%
\fwmacroname{function bHexDigit}{245}\fwbtx[
]fwetx=%
\fwmacroname{function uHexToInt}{246}\fwbtx[
]fwetx=%
\fwmacroname{TokenSource implementation}{214}\fwbtx[
]fwetx=%
\fwmacroname{TokenListTokenSource imp}{216}\fwbtx[
]fwetx=%
\fwmacroname{class TokenizerImp}{222}\fwbtx[
]fwetx=%
\fwmacroname{TokenizerImp implementation}{223}\fwbtx[
]fwetx=%
\fwmacroname{Tokenizer implementation}{219}\fwbtx[
]fwetx=%
\fwmacroname{TokenizerImp::GetNextChar}{226}\fwbtx[
]fwetx=%
\fwmacroname{InputStack implementation}{251}\fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{tokens.t.cpp}{269}\fwequals \fwodef \fwbtx[#include "platform.h"
#include "textio.h"
#include "symbols.h"
#include "tokens.h"
#include <string>
]fwetx=%
\fwmacroname{CompareLog utility}{17}\fwbtx[
]fwetx=%
\fwmacroname{Test jig}{8}\fwoparen \fwoquote\fwmacroname{Tokens tests}{260}\fwcquote\fwcomma \fwoquote\fwmacroname{Tokens TestTable}{265}\fwcquote\fwcparen \fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro








\fwseca{8}{Basic scanning functions}

\fwsecb{8.1}{Overview}
Now we can begin the process of scanning and parsing.  Things become
a bit more complicated at this point. One reason is that \TeX{}
doesn't parse directly on the appearance of certain
tokens but on the current (and changable) definitions of those tokens.
Another reason is that processing takes place on two levels, the level
of unexpandable tokens like most commands, and the level of expandable
tokens like macros, conditionals, and a few others.
A third reason is that these levels are mutually recursive.

As an example of the first point, consider the \TeX{} command

\noindent\null\hskip .4in \fwlit{\char`\\hskip 3pt plus 1pt}.

\noindent On the surface it seems that this should produce a
horizontal skip in the output. However, it is possible that
this command was preceeded somewhere by the command

\noindent\null\hskip .4in \fwlit{\char`\\let\char`\\hskip=\char`\\vskip }

\noindent and in that case the token \fwlit{\char`\\hskip} is no longer defined
as the primitive \fwlit{hskip} command. Furthermore, had the catcode of
the letter `u' been changed, the characters `plus' would not be
recognized as a keyword.

\vskip12pt As an example of the second point, consider the \TeX{} command

\noindent\null\hskip .4in \fwlit{\char`\\hskip 3p\char`\\iftrue t plu\char`\\else \char`\\foo\char`\\fi s 1pt}.

\noindent While parsing a primitive command, i.e.  \fwlit{\char`\\hskip}, the scanner
may run across an expandable token such as \fwlit{\char`\\iftrue}. The code parsing
the \fwlit{\char`\\hskip}'s arguments is not supposed to see \fwlit{\char`\\iftrue} but rather
the result of expanding the entire conditional construct. In this case the
conditional construct

\noindent\null\hskip .4in \fwlit{\char`\\iftrue t plu\char`\\else \char`\\foo\char`\\fi}

\noindent is replaced with the tokens

\noindent\null\hskip .4in \fwlit{t plu}

\noindent because those are the tokens of the true branch, and the
else branch is skipped. Thus this example has the same affect as the first
example.

\vskip 12pt Finally, these levels are mutually recursive. An expandable
token may require arguments. These arguments may have further expandable
and unexpandable tokens. Consider the code

\noindent\null\hskip .4in \fwlit{\char`\\count\char`\\ifnum\char`\\count5\char`\<\char`\\count4 1\char`\\else 2\char`\\fi=7}.

\noindent First \TeX{} sees the token \fwlit{\char`\\count}. It knows that the next
thing should be an integer, so that we have something like \fwlit{\char`\\count45}.
However, we have instead an \fwlit{\char`\\ifnum}. This is an expandable token so it
has to be replaced with it's expansion before continuing with the parse of
\fwlit{\char`\\count}. Now \fwlit{\char`\\ifnum} requires three arguments, an integer, a relation,
and another integer. The first integer argument starts with \fwlit{\char`\\count}
so we need to scan an integer as the argument to this \fwlit{\char`\\count}. That
integer is 5.  An so on. The upshot is that the conditional construct

\noindent\null\hskip .4in \fwlit{\char`\\ifnum\char`\\count5\char`\<\char`\\count4 1\char`\\else 2\char`\\fi}

is replaced by the token \fwlit{1} if counter 5 is less than counter
4, and by the token \fwlit{2} otherwise. So the initial assignment reduces to
either of

\noindent\null\hskip .4in \fwlit{\char`\\count1=7}

\noindent or

\noindent\null\hskip .4in \fwlit{\char`\\count2=7}.



In this section we collect together several functions that
perform parts of the parsing of \TeX{} primitive commands
and expandables.


\fwbeginmacro
\fwmacroname{Scanning declarations}{270}\fwplusequals \fwodef \fwbtx[TeXToken& CurTok();
CommandCode CurCmdCode();
void SetCmdCode(CommandCode c);
SymbolData* CurData();
void SetCurData(SymbolData* pd);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 270.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Some static scanning data}{271}\fwplusequals \fwodef \fwbtx[static TeXToken s_curtok;
static SymbolData* s_curdata;
static CommandCode s_curcmdcode;


TeXToken& CurTok()
{
   return s_curtok;
}

CommandCode CurCmdCode()
{
   return s_curcmdcode;
}

void SetCmdCode(CommandCode c)
{
   s_curcmdcode = c;
}

SymbolData* CurData()
{
   return s_curdata;
}

void SetCurData(SymbolData* pd)
{
   s_curdata = pd;
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 271.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro


\fwsecb{8.2}{Expandable and Primitive symbol data}


\fwbeginmacro
\fwmacroname{class SymbolData}{272}\fwequals \fwodef \fwbtx[class SymbolData{
public:
   virtual ~SymbolData();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{SymbolData implementation}{273}\fwequals \fwodef \fwbtx[SymbolData::~SymbolData()
{}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{class Primitive}{274}\fwequals \fwodef \fwbtx[class Primitive : public SymbolData{
private:
   CommandCode m_curcmd;
   bool        m_bInternalQuantity;
   int         m_data;
public:
   Primitive(CommandCode cmd)
     : m_curcmd(cmd), m_bInternalQuantity(false), m_data(0)
   {}

   Primitive(CommandCode cmd, bool bInternal, int data)
     : m_curcmd(cmd), m_bInternalQuantity(bInternal), m_data(data)
   {}

   CommandCode curcmd() const
   {
      return m_curcmd;
   }

   int Data() const
   {
      return m_data;
   }

   bool bInternalQuantity() const
   {
      return m_bInternalQuantity;
   }
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Parsing helpers}{275}\fwplusequals \fwodef \fwbtx[void NewPrimitive(const char* name,
                  CommandCode cc,
                  bool bInternal,
                  int data)
{
   Symbols::CreateSymbol(name, new Primitive(cc, bInternal, data));
}


void NewPrimitive(const char* name, CommandCode cc)
{
   Symbols::CreateSymbol(name, new Primitive(cc, false, 0));
}

void NewExpandable(const char* name, EXPFUNC f, int data)
{
   Symbols::CreateSymbol(name, new Expandable(f, data));
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro




This subsystem handles ``expandable" tokens.These are either
(1) symbol tokens whose definition is an \fwlit{Expandable} or (2)
an active character token. These tokens are not executed by
the command interpretter but are handled here instead. They
are replaced in the input stream by their expansions. The
expanded tokens go on to the command interpretter where they
are parsed into commands.


There are a number of ``Expansion functions" that can be called. These
may scan for further tokens, put tokens back into the intput stream,
and may decide to set the token and definition themselves. These
functions return true if they do in fact set the token and definition.

\fwbeginmacro
\fwmacroname{typedef EXPFUNC}{276}\fwequals \fwodef \fwbtx[typedef bool (*EXPFUNC)(int, TeXToken*, SymbolData**);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


The \fwlit{Expandable} class is a derivation of a \fwlit{SymbolData}. It
holds a \fwlit{EXPFUNC} which is a function to be executed when the token
is expanded.  It also holds data to be passed to the function. An
\fwlit{EXPFUNC} requires two parameters. The first is a pointer to the
\fwlit{MacroProcessor} because expansion of a token is likely to require
recursive work by that processor.


\fwbeginmacro
\fwmacroname{class Expandable}{277}\fwequals \fwodef \fwbtx[class Expandable : public SymbolData {
public:
   EXPFUNC   m_fcnExpand;
   int       m_data;

   Expandable(EXPFUNC func, int data)
      : m_fcnExpand(func),
        m_data(data)
   {}

   virtual inline bool Expand(TeXToken* tok, SymbolData** ppData) const
   {
       return (*m_fcnExpand)(m_data, tok, ppData);
   }
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{function bExpandable}{278}\fwequals \fwodef \fwbtx[inline bool bExpandable(const SymbolData* pDef)
{
   return 0 != dynamic_cast<const Expandable*>(pDef);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro




\fwsecb{8.3}{GetToken}

Here is the main function of this subsystem. The idea is to get the
next raw token, and see if it is expandable or an active character.
If so then we call the associated expansion function which results in
the expansion being placed back into the input stream. Then we go back
to the start and try again. If the token is not expandable we return
it.

\fwbeginmacro
\fwmacroname{Parsing helper declarations}{279}\fwplusequals \fwodef \fwbtx[void GetToken();
void GetRawToken();
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 279, 282, 287 and 294.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{GetToken imp}{280}\fwplusequals \fwodef \fwbtx[
void GetToken()
{
   while (true) {
      GetRawToken();
      const Expandable* exp = dynamic_cast<const Expandable*>( s_curdata );
      if (exp != 0){
         LOG(" (expandable)");
         // expand and put new tokens back into stream
         // returns true if curtok and curdata are set (eg \noexpand)
         if (exp -> Expand(&s_curtok, &s_curdata))
            break;
         else
            continue;
      } else {
         break;
      }
      break;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 280.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{GetRawToken imp}{281}\fwequals \fwodef \fwbtx[void GetRawToken()
{
   InputStack::GetRawToken();
   s_curtok = InputStack::CurTok();
   s_curdata = 0;
   if (bSymbol(&s_curtok)){
      Symbols::GetDef(s_curtok.Symbol(), &s_curdata);
   } else if (bActive(&s_curtok)){
      Symbols::GetActiveDef(s_curtok.ChrCode(), &s_curdata);
   } else if (s_curtok.Type() == TT_TAB){
      LOG("\n--- Got raw tab");
      int id;
      String tab = StringBuilder::Create("]&[");
      Symbols::GetId(tab, &id, Symbols::NO_CREATE);
      Symbols::GetDef(id, &s_curdata);
      //StringBuilder::Discard(tab);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro





Some forward declarations:
\fwbeginmacro
\fwmacroname{Parsing helper declarations}{282}\fwplusequals \fwodef \fwbtx[enum ScanType {SCAN_INT, SCAN_DIMEN, SCAN_GLUE, SCAN_MU, SCAN_IDENT, SCAN_TOKS};

struct ScanSomethingResult {
   ScanType m_type;
   int      m_int;
   int      m_dim;
   TokenList* m_toks;
};

void NewPrimitive(const char* name,
                  CommandCode cc,
                  bool bInternal,
                  int data);
void NewPrimitive(const char* name, CommandCode cc);

void NewExpandable(const char* name, EXPFUNC f, int data);



void GetNext_NonBlank_NonCall();
void GetNext_NonBlank_NonRelax_NonCall();
void ScanLeftBrace();
void ScanRightBrace();
bool ScanKeyword(String str, TokenList* pList = 0);
bool ScanInt(int* n, TokenList* pList=0);
bool ScanDim(bool mu, bool inf, bool bShortcut, int* dim, TokenList* pList = 0);
void ScanSomethingInternal(int sign,
                           ScanSomethingResult& r,
                           TokenList* pList = 0 );
bool ScanGlue();
void ScanTokenList(TokenList* pTL, bool bExpand);
RuleSpec* ScanRuleSpec();
void ScanBox();
void DetermineCommandCode();
void InitializeKeywords();

struct Keywords {
   ]fwetx=%
\fwmacroname{Keywords}{303}\fwbtx[
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 279, 282, 287 and 294.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



The first functions of this subsystem are \fwlit{GetRawToken} and \fwlit{GetToken}
just like in the \fwlit{tokens} subsystem. But here we do a couple more things
with the tokens.

The first thing we have to do with a \fwlit{TeXToken} is determine a
command code.

\fwbeginmacro
\fwmacroname{Parsing helpers}{283}\fwplusequals \fwodef \fwbtx[void DetermineCommandCode()
{
   SetCmdCode(CMD_NONE);
   if (CurTok().Type() == TT_SYMBOL || CurTok().Type() == TT_ACTIVE){
      ]fwetx=%
\fwmacroname{Get the command code associated with the symbol}{284}\fwbtx[
   }
   switch (CurTok().Type()) {
      case TT_SYMBOL: {
         LOG("Can't happen");
         break;
      }
      case TT_LETTER:
         SetCmdCode(CMD_LETTER);
         break;
      case TT_SPACE:
         SetCmdCode(CMD_SPACER);
         break;
      case TT_OTHER:
         SetCmdCode(CMD_OTHER);
         break;
      case TT_LEFT_BRACE:
         SetCmdCode(CMD_LEFT_BRACE);
         break;
      case TT_RIGHT_BRACE:
         SetCmdCode(CMD_RIGHT_BRACE);
         break;
      case TT_PAR: { // This is a blank line.
         ]fwetx=%
\fwmacroname{Get the command code associated with the symbol}{284}\fwbtx[
         //SetCmdCode(CMD_END_PAR);
         break;
      }
      case TT_MATH_SHIFT:
         SetCmdCode(CMD_MATH_SHIFT);
         break;
      case TT_SUBSCRIPT:
         SetCmdCode(CMD_SUBSCRIPT);
         break;
      case TT_SUPERSCRIPT:
         SetCmdCode(CMD_SUPERSCRIPT);
         break;
      case TT_TAB:
         SetCmdCode(CMD_ALIGN_TAB);
         break;
      case TT_ENDV:
         SetCmdCode(CMD_ENDV);
         break;
      case TT_ENDR:
         SetCmdCode(CMD_ENDR);
         break;
      default:
         SetCmdCode(CMD_NONE);
         break;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro








\fwbeginmacro
\fwmacroname{Get the command code associated with the symbol}{284}\fwmany{}\fwequals \fwodef \fwbtx[
// Is the def a primitive command?
Primitive* prim = dynamic_cast<Primitive*>(CurData());
if (prim != 0){
    CommandCode cc = prim -> curcmd();
    SetCmdCode(cc);
    if (CurCmdCode() == CMD_LET_TOK){
       TeXToken* pTok = (TeXToken*) prim -> Data();
       LOG("\nReplacing " << CurTok()
                          << " with " << *pTok);
       s_curtok = *pTok;
    } else {
       return;
    }
} else {
   LOG("\nUndefined symbol " << CurTok());
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 283 and 283.}
\fwendmacronotes
\fwendmacro



The next couple find the next non-blank token.
Sometimes \fwlit{\char`\\relax} is counted among the blank tokens.

\fwbeginmacro
\fwmacroname{Parsing helpers}{285}\fwplusequals \fwodef \fwbtx[void GetNext_NonBlank_NonCall()
{
   do {
     GetToken();
     DetermineCommandCode();
   } while (CurCmdCode() == CMD_SPACER);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Parsing helpers}{286}\fwplusequals \fwodef \fwbtx[void GetNext_NonBlank_NonRelax_NonCall()
{
   do {
     GetToken();
     DetermineCommandCode();
   } while (CurCmdCode() == CMD_SPACER ||
            CurCmdCode() == CMD_RELAX);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Parsing helper declarations}{287}\fwplusequals \fwodef \fwbtx[void ScanOptionalEquals(TokenList* pList = 0);
void ScanOptionalSpaces(TokenList* pList = 0);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 279, 282, 287 and 294.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Parsing helpers}{288}\fwplusequals \fwodef \fwbtx[void ScanOptionalEquals(TokenList* pList)
{
   GetNext_NonBlank_NonCall();
   if (CurTok() != TeXToken(TT_OTHER, '=', 0)){
      InputStack::Putback(CurTok());
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Parsing helpers}{289}\fwplusequals \fwodef \fwbtx[void IgnoreCurrentSpace(TokenList* pList = 0)
{
    DetermineCommandCode();
    if (CurCmdCode() != CMD_SPACER)
       InputStack::Putback(CurTok());
    else
       if (pList)
          pList -> push_back(CurTok());
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Parsing helpers}{290}\fwplusequals \fwodef \fwbtx[void ScanOptionalSpace(TokenList* pList = 0)
{
    GetToken();
    IgnoreCurrentSpace();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Parsing helpers}{291}\fwplusequals \fwodef \fwbtx[void ScanOptionalSpaces(TokenList* pList)
{
  do {
    GetToken();
    DetermineCommandCode();
  } while (CurCmdCode() == CMD_SPACER);
  InputStack::Putback(CurTok());
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Parsing helpers}{292}\fwplusequals \fwodef \fwbtx[void ScanLeftBrace()
{
   GetNext_NonBlank_NonRelax_NonCall();
   DetermineCommandCode();
   if (CurCmdCode() != CMD_LEFT_BRACE){
      InputStack::Putback(CurTok());
      LOG("\n! Missing `{' inserted.");
      LOG(" -- todo: implement");
      //curtok = TeXToken(TT_LEFT_BRACE, '{', 0);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro

\fwbeginmacro
\fwmacroname{Parsing helpers}{293}\fwplusequals \fwodef \fwbtx[void ScanRightBrace()
{
   DetermineCommandCode();
   if (CurCmdCode() != CMD_RIGHT_BRACE){
      InputStack::Putback(CurTok());
      LOG("\n! Missing `}' inserted.");
      LOG(" -- todo: implement");
      //curtok = TeXToken(TT_LEFT_BRACE, '{', 0);
   } else {
     GetToken();
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro



This next function is used by \fwlit{\char`\\countdef} etc. It scans a
token to be defined, followed by an integer parameter.

\fwbeginmacro
\fwmacroname{Parsing helper declarations}{294}\fwplusequals \fwodef \fwbtx[bool ScanShorthand(TeXToken* defining, int* pn);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 279, 282, 287 and 294.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Parsing helpers}{295}\fwplusequals \fwodef \fwbtx[bool ScanShorthand(TeXToken* defining, int* pn)
{
   do {
      GetToken();
   } while(CurTok().Type() == TT_SPACE);
   if (CurTok().Type() == TT_SYMBOL ||
       CurTok().Type() == TT_ACTIVE) {
      *defining = CurTok();
      // Temporarily define to be \relax
      // todo: remove this memory leak
      Primitive* cmd = new Primitive(CMD_RELAX);
      Symbols::SetDef(CurTok().Symbol(),
                     cmd,
                     false /* non-global*/);
   } else {
      LOG("ERROR -- can't define" << CurTok());
      InputStack::Putback(CurTok());
      return false;
   }

   ScanOptionalEquals();
   ScanInt(pn);
   return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro




\fwsecb{8.4}{Scan an integer: ScanInt}

\fwbeginmacro
\fwmacroname{Parsing helpers}{296}\fwplusequals \fwodef \fwbtx[int ScanSign(TokenList* pList = 0)
{
   int sign = +1;
   do {
      GetNext_NonBlank_NonCall();
      if (CurTok().Type() == TT_OTHER && CurTok().ChrCode() == '-'){
         if (pList)
           pList->push_back(CurTok());
         sign = -sign;
         CurTok().SetChrCode('+');
      } else if (CurTok().Type() == TT_OTHER && CurTok().ChrCode() == '+'){
         if (pList)
           pList->push_back(CurTok());
      }
   } while (CurTok().Type() == TT_OTHER &&
            CurTok().ChrCode() == '+');
   return sign;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Parsing helpers}{297}\fwplusequals \fwodef \fwbtx[bool bDecimalDigit(TeXToken tok, int* d)
{
   if (tok.Type() != TT_OTHER)
     return false;
   TeXChar ch = CurTok().ChrCode();
   if (ch >= L'0' && ch <= L'9'){
      *d = ch - L'0';
      return true;
   }
   return false;
}


bool bHexadecimalDigit(TeXToken tok, int* d)
{
   if (tok.Type() == TT_OTHER){
      TeXChar ch = CurTok().ChrCode();
      if (ch >= L'0' && ch <= L'9'){
         *d = ch - L'0';
         return true;
      } else if (ch >= L'A' && ch <= L'Z'){
         *d = ch - L'A' + 10;
         return true;
      }
      return false;
   } else if (tok.Type() == TT_LETTER){
      TeXChar ch = CurTok().ChrCode();
      if (ch >= L'A' && ch <= L'Z'){
         *d = ch - L'A' + 10;
         return true;
      }
      return false;
   }
   return false;
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Parsing helpers}{298}\fwplusequals \fwodef \fwbtx[TeXToken alpha_token (TT_OTHER, '`',  0);
TeXToken octal_token (TT_OTHER, '\'', 0);
TeXToken hex_token   (TT_OTHER, '"',  0);

bool ScanInt(int* n, TokenList* pList)
{
   int iVal = 0;
   bool bOK = true;
   int sign = ScanSign(pList);
   DetermineCommandCode();
   if (CurData() != 0 &&
       ((Primitive*)CurData()) -> bInternalQuantity()){
      ]fwetx=%
\fwmacroname{Scan internal integer}{299}\fwbtx[
   } else {
      ]fwetx=%
\fwmacroname{Scan numeral}{300}\fwbtx[
   }

   iVal = sign * iVal;

   *n = iVal;
   return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Scan internal integer}{299}\fwequals \fwodef \fwbtx[      // Scan something internal
      ScanSomethingResult res;
      ScanSomethingInternal(+1, res, pList);
      if (res.m_type == SCAN_INT)
        iVal = res.m_int;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 298.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Scan numeral}{300}\fwequals \fwodef \fwbtx[   if (CurTok() == alpha_token){
      if (pList)
         pList -> push_back(CurTok());

      // Scan alphabetic char code  TTP 442
      GetRawToken();
      if (pList)
         pList -> push_back(CurTok());

      if (CurTok().Type() == TT_SYMBOL){
         // We should have something like '\$
         Symbols::SymId symId = CurTok().Symbol();
         String str = Symbols::GetName(symId);
         if (str.Size() == 1){
            iVal = str[0];
         }
      } else {
         // We should have something like `a or `& ...
         iVal = CurTok().ChrCode();
      }
      ScanOptionalSpace();
   } else {
       bool bVacuous = false;
       if (CurTok() == octal_token) {
          if (pList)
             pList -> push_back(CurTok());
          //scan octal digits
          GetToken();
          int max = 268435456;
          int d = 0;
          while (bDecimalDigit(CurTok(), &d) &&
                   iVal <= max) {
             if (d < 8){
                if (pList)
                   pList -> push_back(CurTok());
                iVal = 8 * iVal + d;
                GetToken();
             } else
                break;
          }
       } else if (CurTok() == hex_token) {
          // scan hecadecimal digits
          if (pList)
             pList -> push_back(CurTok());

          GetToken();
          int max = 134217728;
          int d = 0;
          while (bHexadecimalDigit(CurTok(), &d) &&
                 iVal <= max) {
             if (pList)
                pList -> push_back(CurTok());
             bVacuous = false;
             iVal = 16 * iVal + d;
             GetToken();
          }
       } else {
          //scan decimal constant();
          int max = 214748364;
          int d = 0;
          while (bDecimalDigit(CurTok(), &d) &&
                 iVal <= max) {
             if (pList)
                pList -> push_back(CurTok());
             bVacuous = false;
             iVal = 10 * iVal + d;
             GetToken();
          }
       }
       IgnoreCurrentSpace(pList);
       if (bVacuous){
          LOG("Error -- Missing number");
          iVal = 0;
       }
   }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 298.}
\fwendmacronotes
\fwendmacro



\fwsecb{8.5}{ScanSomethingInternal}

\fwbeginmacro
\fwmacroname{Parsing helpers}{301}\fwplusequals \fwodef \fwbtx[void ScanSomethingInternal(int sign, ScanSomethingResult& res, TokenList* pList)
{
   CommandCode cc = CurCmdCode();
   if (pList)
     pList -> push_back(CurTok());

   switch (cc) {
      ]fwetx=%
\fwmacroname{ScanSomethingInternal cases}{521}\fwbtx[
      case CMD_DEFCODE : {
         Primitive* prim = dynamic_cast<Primitive*>(CurData());
         DefCode subtype = (DefCode) prim -> Data();
         int m;
         if (ScanInt(&m)){
            if (subtype == CATCODE){
               res.m_type = SCAN_INT;
               res.m_int = GetCatcode(m);
               //res.m_int = -res.m_int;
            } else if (subtype == UCCODE){
               res.m_type = SCAN_INT;
               res.m_int = GetUccode(m);
            } else if (subtype = SFCODE){
               res.m_type = SCAN_INT;
               res.m_int = GetSfcode(m);
            } else
               ASSERT(false);
         }

         break;
      }

      case CMD_CHAR_GIVEN :{
         res.m_type = SCAN_INT;
         Primitive* prim = dynamic_cast<Primitive*>(CurData());
         res.m_int = prim -> Data();
         break;
      }

      case CMD_MATH_GIVEN :{
         res.m_type = SCAN_INT;
         Primitive* prim = dynamic_cast<Primitive*>(CurData());
         res.m_int = prim -> Data();
         break;
      }

      case CMD_REGISTER: {
         Primitive* prim = dynamic_cast<Primitive*>(CurData());
         RegisterCode subtype = (RegisterCode) prim -> Data();
         int n;
         ScanInt(&n);
         if (subtype == GLUE_REG){
           res.m_type = SCAN_GLUE;
         } else {
           ASSERT(false);
         }
         break;
      }
      default:
         ASSERT(false);
         break;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro


\fwsecc{8.5.1}{ScanKeyword}

\fwbeginmacro
\fwmacroname{Parsing helpers}{302}\fwplusequals \fwodef \fwbtx[bool ScanKeyword(String str, TokenList* pList)
{
   TokenList* tl = new TokenList();
   int k = 0;
   while (k < str.Size()){
      GetToken();
      DetermineCommandCode();
      if (CurTok().ChrCode() == str[k] ||
          CurTok().ChrCode() == str[k] - 'a' + 'A'){
         tl -> push_back(CurTok());
         ++k;
      } else {
         if (CurCmdCode() != CMD_SPACER || tl -> size() != 0){
            InputStack::Putback(CurTok());
            if (tl -> size() != 0){
               InputStack::Putback(*tl);
            }
            return false;
         }
         // If we get here CurCmdCode() ==
         //       CMD_SPACER and tl -> size() == 0
         // continue, thus ignoring blanks at the start of a keyword
      }
   }
   if (pList){
      TokenList::const_iterator it;
      for(it = tl -> begin(); it != tl -> end(); ++it){
         pList -> push_back(*it);
      }
   }
   delete tl;
   return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Keywords}{303}\fwplusequals \fwodef \fwbtx[static String KW_PT;
static String KW_IN;
static String KW_PC;
static String KW_CM;
static String KW_MM;
static String KW_BP;
static String KW_DD;
static String KW_CC;
static String KW_SP;
static String KW_EM;
static String KW_EX;
static String KW_TRUE;
static String KW_FIL;
static String KW_L;
static String KW_PLUS;
static String KW_MINUS;
static String KW_WIDTH;
static String KW_HEIGHT;
static String KW_DEPTH;
static String KW_BY;
static String KW_SPREAD;
static String KW_TO;
static String KW_MU;
static String KW_SCALED;
static String KW_AT;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 303.}
\fwusedin{This macro is invoked in definition 282.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Define keywords}{304}\fwequals \fwodef \fwbtx[String Keywords::KW_PT;
String Keywords::KW_IN;
String Keywords::KW_PC;
String Keywords::KW_CM;
String Keywords::KW_MM;
String Keywords::KW_BP;
String Keywords::KW_DD;
String Keywords::KW_CC;
String Keywords::KW_SP;
String Keywords::KW_EM;
String Keywords::KW_EX;
String Keywords::KW_TRUE;
String Keywords::KW_FIL;
String Keywords::KW_L;
String Keywords::KW_PLUS;
String Keywords::KW_MINUS;
String Keywords::KW_WIDTH;
String Keywords::KW_HEIGHT;
String Keywords::KW_DEPTH;
String Keywords::KW_BY;
String Keywords::KW_SPREAD;
String Keywords::KW_TO;
String Keywords::KW_MU;
String Keywords::KW_SCALED;
String Keywords::KW_AT;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Create keywords}{305}\fwplusequals \fwodef \fwbtx[  Keywords::KW_PT   = StringBuilder::Create("pt");
  Keywords::KW_IN   = StringBuilder::Create("in");
  Keywords::KW_PC   = StringBuilder::Create("pc");
  Keywords::KW_CM   = StringBuilder::Create("cm");
  Keywords::KW_MM   = StringBuilder::Create("mm");
  Keywords::KW_BP   = StringBuilder::Create("bp");
  Keywords::KW_DD   = StringBuilder::Create("dd");
  Keywords::KW_CC   = StringBuilder::Create("cc");
  Keywords::KW_SP   = StringBuilder::Create("sp");
  Keywords::KW_EM   = StringBuilder::Create("em");
  Keywords::KW_EX   = StringBuilder::Create("ex");
  Keywords::KW_TRUE = StringBuilder::Create("true");
  Keywords::KW_FIL  = StringBuilder::Create("fil");
  Keywords::KW_L    = StringBuilder::Create("l");
  Keywords::KW_PLUS = StringBuilder::Create("plus");
  Keywords::KW_MINUS= StringBuilder::Create("minus");
  Keywords::KW_WIDTH= StringBuilder::Create("width");
  Keywords::KW_HEIGHT= StringBuilder::Create("height");
  Keywords::KW_DEPTH= StringBuilder::Create("depth");
  Keywords::KW_BY   = StringBuilder::Create("by");
  Keywords::KW_SPREAD = StringBuilder::Create("spread");
  Keywords::KW_TO = StringBuilder::Create("to");
  Keywords::KW_MU = StringBuilder::Create("mu");
  Keywords::KW_SCALED = StringBuilder::Create("scaled");
  Keywords::KW_AT = StringBuilder::Create("at");
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 305.}
\fwusedin{This macro is invoked in definition 306.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{InitializeKeywords}{306}\fwequals \fwodef \fwbtx[void InitializeKeywords()
{
   ]fwetx=%
\fwmacroname{Create keywords}{305}\fwbtx[
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro



\fwlit{ScanTokenList} is responsible for the various methods of scanning
and creating \fwlit{TokenList}s. For some reason I didn't use this function
for scanning bodies of macro definitions. Should I?

\fwbeginmacro
\fwmacroname{Parsing helpers}{307}\fwplusequals \fwodef \fwbtx[void ScanTokenList(TokenList* pTL, bool bExpand)
{
   ScanLeftBrace();
   ASSERT(CurTok().Type() == TT_LEFT_BRACE);
   bool scanning = true;
   int balance = 1;
   while (scanning) {
      if (InputStack::bEmpty()){
         ASSERT(false);
         //SetError("End of file reached while scanning definition of "
         //         << defining);
         scanning = false;
      }else{
         if (bExpand){
            GetToken();
         } else {
            GetRawToken();
         }
         if (CurTok().Type() == TT_LEFT_BRACE){
            balance += 1;
            pTL -> push_back(CurTok());
         } else if (CurTok().Type() == TT_RIGHT_BRACE){
            balance -= 1;
            if (balance == 0){
               scanning = false;
               // Don't insert the final right brace
            } else {
               pTL -> push_back(CurTok());
            }
 //      } else if (CurTok().Type() == TT_PARAM){
 //         CurTok().SetType(TT_OUTPARAM);
 //         pTL -> push_back(CurTok());
         }  else {
            pTL -> push_back(CurTok());
         }
      }
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro



\fwsecb{8.6}{Scan dimension}

\fwbeginmacro
\fwmacroname{Parsing helpers}{308}\fwplusequals \fwodef \fwbtx[bool ScanDecimalFraction(int* res, TokenList* pList)
{
   int dig[17];
   int k = 0;
   int d;

   GetRawToken(); // re-scan point_token
   GetToken();
   while(bDecimalDigit(CurTok(), &d)) {
      if (pList)
         pList -> push_back(CurTok());
      if (k < 17){
         dig[k] = d;
         ++k;
      }
      GetToken();
   }
   DetermineCommandCode();
   if (CurCmdCode() != CMD_SPACER){
      InputStack::Putback(CurTok());
   } else if (pList) {
      pList -> push_back(CurTok());
   }
   int a = 0;
   while (k > 0){
      --k;
      a = (a + dig[k] * 0x20000) / 10;
   }
   *res = (a + 1) / 2;
   return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Parsing helpers}{309}\fwplusequals \fwodef \fwbtx[
TeXToken continental_point_token = TeXToken(TT_OTHER, ',', 0);
TeXToken point_token = TeXToken(TT_OTHER, '.', 0);


bool ScanDim(bool mu, bool inf, bool bShortcut, int* dim, TokenList* pList)
{
    bool arith_error = false;
    int iVal = 0;
    int sign = +1;
    int f = 0;
    bool bScanUnit = true;
    if (! bShortcut){
       int sign = ScanSign(pList);
       DetermineCommandCode();
       Primitive* prim = dynamic_cast<Primitive*>(CurData());
       if (prim != 0 && prim -> bInternalQuantity()){
          ]fwetx=%
\fwmacroname{Scan internal dimension}{311}\fwbtx[
       } else {
          InputStack::Putback(CurTok());
          if (CurTok() == continental_point_token){
             if (pList)
                pList -> push_back(CurTok());
             CurTok() = point_token;
          } else if (CurTok() == point_token){
             if (pList)
                pList -> push_back(CurTok());
          }

          if (CurTok() != point_token) {
             int d;
             if (!bDecimalDigit(CurTok(), &d)){
                ScanInt(&iVal, pList);
             } else {
                ScanInt(&iVal, pList);
                if (CurTok() == continental_point_token){
                   if (pList)
                      pList -> push_back(CurTok());
                   CurTok() = point_token;
                } else if (CurTok() == point_token){
                   if (pList)
                      pList -> push_back(CurTok());
                }
                if (CurTok() == point_token){
                   ScanDecimalFraction(&f, pList);
                }
             }
          } else {
             iVal = 0;
             ScanDecimalFraction(&f, pList);
          }
       }
    }

    // We start here if there's a shortcut

    if (iVal < 0){
       sign = -sign;
       iVal = -iVal;
    }
    *dim = sign * (iVal * 2^16 + f);
    if (bScanUnit){
      ]fwetx=%
\fwmacroname{Scan unit}{310}\fwbtx[
    }

    ScanOptionalSpace();

    if (iVal > 0x4000){
       // out of range
       ASSERT(false);
    } else {

    }

    return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Scan unit}{310}\fwequals \fwodef \fwbtx[bool bFoundInf = false;
if (inf){
   if (ScanKeyword(Keywords::KW_FIL, pList)){
      bFoundInf = true;
      while (ScanKeyword(Keywords::KW_L, pList)){
      }
   }
}
if (!bFoundInf){
   int numer,denom;
   if (ScanKeyword(Keywords::KW_TRUE, pList)){
   }
   if (ScanKeyword(Keywords::KW_PT, pList)){
       numer = 1; denom = 1;
   } else if (ScanKeyword(Keywords::KW_IN, pList)){
       numer = 7227; denom = 100;
   } else if (ScanKeyword(Keywords::KW_PC, pList)){
       numer = 12; denom = 1;
   } else if (ScanKeyword(Keywords::KW_CM, pList)){
       numer = 7227; denom = 254;
   } else if (ScanKeyword(Keywords::KW_MM, pList)){
       numer = 7227; denom = 2540;
   } else if (ScanKeyword(Keywords::KW_BP, pList)){
       numer = 7227; denom = 7200;
   } else if (ScanKeyword(Keywords::KW_DD, pList)){
       numer = 1238; denom = 1157;
   } else if (ScanKeyword(Keywords::KW_CC, pList)){
       numer = 14856; denom = 1157;
   } else if (ScanKeyword(Keywords::KW_SP, pList)){
       numer = 1; denom = 1;
   } else if (ScanKeyword(Keywords::KW_MU, pList)){
       numer = 1; denom = 1;
   } else if (ScanKeyword(Keywords::KW_EM, pList)){
       numer = 1; denom = 1;
   } else if (ScanKeyword(Keywords::KW_EX, pList)){
       numer = 1; denom = 1;
   } else {
      GetToken();
      ScanSomethingResult res;
      ScanSomethingInternal(+1, res, pList);
      if (res.m_type == SCAN_DIMEN){
         numer = res.m_int;
         denom = 1;
      } else if (res.m_type == SCAN_GLUE){
         numer = res.m_int;
         denom = 1;
      } else {
         // Unknown unit
         ASSERT(false);
      }
   }
   *dim = (*dim) * numer / denom;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 309.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Scan internal dimension}{311}\fwequals \fwodef \fwbtx[ScanSomethingResult res;
if (mu){
   ScanSomethingInternal(+1, res);
} else {
   ScanSomethingInternal(+1, res);
}
if (res.m_type == SCAN_DIMEN || res.m_type == SCAN_GLUE){
   bScanUnit = false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 309.}
\fwendmacronotes
\fwendmacro





\fwsecb{8.7}{ScanGlue}

\fwbeginmacro
\fwmacroname{Parsing helpers}{312}\fwplusequals \fwodef \fwbtx[bool ScanGlue()
{
   int sign = ScanSign();
   int dim = 0;
   DetermineCommandCode();
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   if (prim && prim -> bInternalQuantity()){
      ScanSomethingResult res;
      ScanSomethingInternal(+1, res);
      if (res.m_type == SCAN_INT){
         ScanDim(false, false, true, &dim);
      }
   } else {
      InputStack::Putback(CurTok());
      ScanDim(false, false, false, &dim);
   }
   if (ScanKeyword(Keywords::KW_PLUS)){
      ScanDim(false, true, false, &dim);
   }
   if (ScanKeyword(Keywords::KW_MINUS)){
      ScanDim(false, true, false, &dim);
   }
   return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro


\fwsecb{8.8}{Rules}

\fwbeginmacro
\fwmacroname{Parsing helpers}{313}\fwplusequals \fwodef \fwbtx[const int default_rule = 26214; // 0.4 pt

RuleSpec* ScanRuleSpec()
{
   RuleSpec* rs = new RuleSpec;
   Scaled dim;
   if (CurCmdCode() == CMD_VRULE){
      rs -> m_width = default_rule;
   } else {
      rs -> m_height = default_rule;
      rs -> m_depth = 0;
   }
   while (true){
      if (ScanKeyword(Keywords::KW_WIDTH)){
        ScanDim(false, false, false, &dim);
      } else if (ScanKeyword(Keywords::KW_HEIGHT)){
        ScanDim(false, false, false, &dim);
      } else if (ScanKeyword(Keywords::KW_DEPTH)){
        ScanDim(false, false, false, &dim);
      } else {
        break;
      }
   }
   return rs;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 275, 283, 285, 286, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 301, 302, 307, 308, 309, 312 and 313.}
\fwusedin{This macro is invoked in definition 315.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwfilename{scanutils.h}{314}\fwequals \fwodef \fwbtx[#ifndef SCANUTILS_H
#define SCANUTILS_H
#include "platform.h"
#include "basicdata.h"
#include "tokens.h"

enum CommandCode{
   ]fwetx=%
\fwmacroname{Command Codes}{390}\fwbtx[
   CMD_NONE
};

]fwetx=%
\fwmacroname{Command subcodes}{464}\fwbtx[

]fwetx=%
\fwmacroname{Scanning declarations}{270}\fwbtx[
]fwetx=%
\fwmacroname{class SymbolData}{272}\fwbtx[
]fwetx=%
\fwmacroname{class Primitive}{274}\fwbtx[
]fwetx=%
\fwmacroname{typedef EXPFUNC}{276}\fwbtx[
]fwetx=%
\fwmacroname{class Expandable}{277}\fwbtx[
]fwetx=%
\fwmacroname{Parsing helper declarations}{279}\fwbtx[
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwfilename{scanutils.cpp}{315}\fwequals \fwodef \fwbtx[#include "scanutils.h"
#include "tokens.h"
]fwetx=%
\fwmacroname{Some static scanning data}{271}\fwbtx[
]fwetx=%
\fwmacroname{SymbolData implementation}{273}\fwbtx[
]fwetx=%
\fwmacroname{Define keywords}{304}\fwbtx[
]fwetx=%
\fwmacroname{InitializeKeywords}{306}\fwbtx[
]fwetx=%
\fwmacroname{function bExpandable}{278}\fwbtx[
]fwetx=%
\fwmacroname{GetToken imp}{280}\fwbtx[
]fwetx=%
\fwmacroname{GetRawToken imp}{281}\fwbtx[
]fwetx=%
\fwmacroname{Parsing helpers}{275}\fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwseca{9}{Basic expandables}

\fwsecb{9.1}{$\backslash$input}

\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{316}\fwplusequals \fwodef \fwbtx[NewExpandable("input", xfcnInput, 0);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Expandable declarations}{317}\fwplusequals \fwodef \fwbtx[bool xfcnInput(int /* ignored */, TeXToken*, SymbolData**);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 317, 321, 324, 327, 330, 332 and 336.}
\fwusedin{This macro is invoked in definition 344.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Scan filename}{318}\fwmany{}\fwequals \fwodef \fwbtx[GetNext_NonBlank_NonCall();
bool braced = false;
if (CurTok().Type() == TT_LEFT_BRACE){
   braced = true;
   GetToken();
}
while (true){
   if (CurTok().Type() == TT_SYMBOL ||
       CurTok().Type() == TT_ACTIVE){
      InputStack::Putback(CurTok());
      break;
   } else if (!fn.Accept(CurTok().ChrCode(),false)){
      break;
   } else {
      GetToken();
   }
}
if (braced){
   if (CurTok().Type() != TT_RIGHT_BRACE){
      LOG("\nERROR missing right brace in filename.");
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 319, 461, 466, 466 and 469.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc functions}{319}\fwplusequals \fwodef \fwbtx[bool xfcnInput(int /* ignored */, TeXToken*, SymbolData**)
{
   Filename fn;
   ]fwetx=%
\fwmacroname{Scan filename}{318}\fwbtx[
   const char* name = fn.GetNameString();
   const char* ext = fn.GetExtString();
   if (ext == 0)
     ext = "tex";

   InputByteFile* pbf = new InputByteFile;
   pbf -> Open(fn);
   Latin_1_in*  platin1filt = new Latin_1_in(*pbf);
   LineSource* plineSource = new LineSource(*platin1filt);
   Tokenizer* ts = new Tokenizer(plineSource);
   InputStack::Push(ts);
   LOG("\n----\\input " << name);
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 319, 322, 325, 328, 331, 334 and 337.}
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro


\fwsecb{9.2}{$\backslash$number}

\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{320}\fwplusequals \fwodef \fwbtx[NewExpandable("number", xfcnNumber, 0);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Expandable declarations}{321}\fwplusequals \fwodef \fwbtx[
bool xfcnNumber(int /* ignored */, TeXToken*, SymbolData**);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 317, 321, 324, 327, 330, 332 and 336.}
\fwusedin{This macro is invoked in definition 344.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc functions}{322}\fwplusequals \fwodef \fwbtx[
void StrToToks(String str, TokenList* tl)
{
   for (int i = 0; i < str.Size(); ++i){
      if (str[i] == L' '){
         tl -> push_back(TeXToken(TT_SPACE, L' ', 0));
      } else {
         tl -> push_back(TeXToken(TT_OTHER, str[i], 0));
      }
   }
}


bool xfcnNumber(int /* ignored */, TeXToken*, SymbolData**)
{
   int n;
   ScanInt(&n);
   StringUtils::AppendInt(n);
   String str = StringBuilder::Create();
   TokenList* tl = new TokenList;
   StrToToks(str, tl);
   StringBuilder::Discard(str);
   TokenListTokenSource* ts = new TokenListTokenSource(*tl);
   InputStack::Push(ts);
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 319, 322, 325, 328, 331, 334 and 337.}
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro




\fwsecb{9.3}{$\backslash$romannumeral}

\fwsecb{9.4}{$\backslash$meaning}

\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{323}\fwplusequals \fwodef \fwbtx[NewExpandable("meaning", xfcnMeaning, 0);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Expandable declarations}{324}\fwplusequals \fwodef \fwbtx[
bool xfcnMeaning(int /* ignored */, TeXToken*, SymbolData**);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 317, 321, 324, 327, 330, 332 and 336.}
\fwusedin{This macro is invoked in definition 344.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc functions}{325}\fwplusequals \fwodef \fwbtx[
bool xfcnMeaning(int /* ignored */, TeXToken*, SymbolData**)
{
   GetRawToken();
   DetermineCommandCode();
   MacroDef* pMacDef = dynamic_cast<MacroDef*>(CurData());
   if (pMacDef != 0){
      StringUtils::AppendToks(pMacDef -> Toks());
      String str = StringBuilder::Create();
      TokenList* tl = new TokenList;
      StrToToks(str, tl);
      StringBuilder::Discard(str);
      InputStack::Putback(*tl);
   }
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 319, 322, 325, 328, 331, 334 and 337.}
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro



\fwsecb{9.5}{$\backslash$jobname}

\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{326}\fwplusequals \fwodef \fwbtx[NewExpandable("jobname", xfcnJobname, 0);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Expandable declarations}{327}\fwplusequals \fwodef \fwbtx[bool xfcnJobname(int /* ignored */, TeXToken*, SymbolData**);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 317, 321, 324, 327, 330, 332 and 336.}
\fwusedin{This macro is invoked in definition 344.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc functions}{328}\fwplusequals \fwodef \fwbtx[extern const char* s_inputfilename;

bool xfcnJobname(int /* ignored */, TeXToken*, SymbolData**)
{
   Filename fn(s_inputfilename);
   StringUtils::AppendCStr(fn.GetNameString());
   String str = StringBuilder::Create();
   TokenList* toks = new TokenList;;
   StrToToks(str, toks);
   InputStack::Putback(*toks);
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 319, 322, 325, 328, 331, 334 and 337.}
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro




\fwsecb{9.6}{$\backslash$fontname}

\fwsecb{9.7}{$\backslash$the}

\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{329}\fwplusequals \fwodef \fwbtx[NewExpandable("the", xfcnThe, 0);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Expandable declarations}{330}\fwplusequals \fwodef \fwbtx[
bool xfcnThe(int /* ignored */, TeXToken*, SymbolData**);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 317, 321, 324, 327, 330, 332 and 336.}
\fwusedin{This macro is invoked in definition 344.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc functions}{331}\fwplusequals \fwodef \fwbtx[
TokenListTokenSource* xfcnThe_nopush(int /* ignored */, TeXToken*, SymbolData**)
{
   GetToken();
   DetermineCommandCode();
   ScanSomethingResult res;
   ScanSomethingInternal(+1, res);
   if (res.m_type == SCAN_TOKS){
      TokenList* pList = res.m_toks;
      //StringUtils::AppendToks(*pList);
      TokenListTokenSource* ts = new TokenListTokenSource(*pList);
      return ts;
      //InputStack::Push(ts);
      //return false;
   } else  if (res.m_type == SCAN_INT){
      StringUtils::AppendInt(res.m_int);
   } else if (res.m_type == SCAN_DIMEN){
      StringUtils::AppendScaled(res.m_int);
      StringBuilder::Append(L'p');
      StringBuilder::Append(L't');
   } else if (res.m_type == SCAN_GLUE){
      StringUtils::AppendScaled(res.m_int);
      StringBuilder::Append(L'p');
      StringBuilder::Append(L't');
   } else {
      ASSERT(false);
   }
   String str = StringBuilder::Create();
   TokenList* tl = new TokenList;
   StrToToks(str, tl);
   StringBuilder::Discard(str);
   TokenListTokenSource* ts = new TokenListTokenSource(*tl);
   //InputStack::Push(ts);
   return ts;
}


bool xfcnThe(int i, TeXToken* pt, SymbolData** psd)
{
    TokenListTokenSource* ts = xfcnThe_nopush(i, pt, psd);
    InputStack::Push(ts);
    return false;
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 319, 322, 325, 328, 331, 334 and 337.}
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro


\fwsecb{9.8}{$\backslash$noexpand}

\fwbeginmacro
\fwmacroname{Expandable declarations}{332}\fwplusequals \fwodef \fwbtx[bool xfcnNoexpand(int, TeXToken*, SymbolData**);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 317, 321, 324, 327, 330, 332 and 336.}
\fwusedin{This macro is invoked in definition 344.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{333}\fwplusequals \fwodef \fwbtx[NewExpandable("noexpand", xfcnNoexpand, 0);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Misc functions}{334}\fwplusequals \fwodef \fwbtx[bool xfcnNoexpand(int /* ignored*/, TeXToken* tt, SymbolData** ppDef)
{
   static SymbolData* frozen_relax = new Primitive(CMD_RELAX);
   TeXToken next;
   GetRawToken();
   next = CurTok();
   if (next.Type() == TT_SYMBOL){
      LOG(" (don't expand token)");
      *tt = next;
      *ppDef = frozen_relax;
      return true;
   }
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 319, 322, 325, 328, 331, 334 and 337.}
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro



\fwsecb{9.9}{$\backslash$uppercase and $\backslash$lowercase}

\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{335}\fwplusequals \fwodef \fwbtx[NewExpandable("uppercase", xfcnCaseshift, 0);
NewExpandable("lowercase", xfcnCaseshift, 1);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Expandable declarations}{336}\fwplusequals \fwodef \fwbtx[
bool xfcnCaseshift(int dir, TeXToken*, SymbolData**);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 317, 321, 324, 327, 330, 332 and 336.}
\fwusedin{This macro is invoked in definition 344.}
\fwendmacronotes
\fwendmacro

\fwbeginmacro
\fwmacroname{Misc functions}{337}\fwplusequals \fwodef \fwbtx[bool xfcnCaseshift(int dir, TeXToken*, SymbolData**)
{
   TokenList* tl = new TokenList;
   ScanTokenList(tl, false);
   LOG("\nCase shift.");
   LOG("\n...I read " << *tl);
   TokenList::iterator it;
   for (it = tl -> begin(); it != tl -> end(); ++it){
      if ((*it).Type() != TT_SYMBOL){
         TeXChar ch = (*it).ChrCode();
         if (dir == 0){
            TeXChar uc = GetUccode(ch);
            if (uc != 0)
               (*it).SetChrCode(uc);
         } else {
            TeXChar lc = GetLccode(ch);
            if (lc != 0)
               (*it).SetChrCode(lc);
         }
      }
   }
   LOG("\n... I put back: " << *tl);
   InputStack::Putback(*tl);
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 319, 322, 325, 328, 331, 334 and 337.}
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro




\fwsecb{9.10}{$\backslash$mark}

\fwbeginmacro
\fwmacroname{Expansion functions}{338}\fwplusequals \fwodef \fwbtx[bool xfcnExpandMark(int which, TeXToken*, SymbolData**)
{
   TeXToken tok;
   tok.SetType(TT_LEFT_BRACE);
   tok.SetChrCode('{');
   InputStack::Putback(tok);
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 338, 339, 340 and 341.}
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro



\fwsecb{9.11}{$\backslash$expandafter}

\fwbeginmacro
\fwmacroname{Expansion functions}{339}\fwplusequals \fwodef \fwbtx[bool xfcnExpandafter(int /*ignored*/, TeXToken*, SymbolData**)
{
   GetRawToken();
   TeXToken next1 = CurTok();
   LOG(" (first token)");

   GetRawToken();
   TeXToken next2 = CurTok();
   LOG(" (second token)");

   if (bSymbol(&next2)){
      SymbolData* pDef = 0;
      Symbols::GetDef(next2.Symbol(),&pDef);
      const Expandable* exp = dynamic_cast<const Expandable*>(pDef);
      if (exp != 0){
         LOG("\n--Expandafter expanding " << next2);
         TeXToken tmptt;
         SymbolData* tmpsd;
         exp -> Expand(&tmptt, &tmpsd);
      } else
         InputStack::Putback(next2);

   }else{
      InputStack::Putback(next2);
   }
   InputStack::Putback(next1);
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 338, 339, 340 and 341.}
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro



\fwsecb{9.12}{$\backslash$csname}

\fwbeginmacro
\fwmacroname{Expansion functions}{340}\fwplusequals \fwodef \fwbtx[bool xfcnCsname(int /* ignored */, TeXToken*, SymbolData**)
{
   TokenList tl;
   while (true) {
      GetToken();
      if (CurTok().Type() == TT_SYMBOL){
         LOG("todo: check that we have \\endcsname def");
         break;
      } else {
         tl.push_back(CurTok());
      }
   }
   TokenList::const_iterator it;
   for (it = tl.begin(); it != tl.end(); ++it){
      StringBuilder::Append((*it).ChrCode());
   }
   String name = StringBuilder::Create();
   int id;
   Symbols::GetId(name, &id, Symbols::CREATE);
   TeXToken newtok(TT_SYMBOL, 0, id);
   InputStack::Putback(newtok);
   SymbolData* pData;
   Symbols::GetDef(id, &pData);
   if (pData == 0){
      static SymbolData* frozen_relax = new Primitive(CMD_RELAX);
      LOG("\n\\csname will define the nyew symbol as \\relax.");
      Symbols::SetDef(id, frozen_relax, true);
   }
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 338, 339, 340 and 341.}
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro


\fwsecb{9.13}{$\backslash$string}

\fwbeginmacro
\fwmacroname{Expansion functions}{341}\fwplusequals \fwodef \fwbtx[
TeXToken escape(TT_OTHER, '\\', 0);

bool xfcnString(int /* ignored */, TeXToken*, SymbolData**)
{
   GetRawToken();
   TeXToken next = CurTok();
   if (next.Type() == TT_SYMBOL){
      TokenList* pTL = new TokenList;
      if (Global::escapechar != -1){
         pTL -> push_back(escape);
      }
      String name = Symbols::GetName(next.Symbol());
      for (int i = 0; i < name.Size(); ++i){
         TeXToken ch(TT_OTHER, name[i], 0);
         pTL -> push_back(ch);
      }
      InputStack::Putback(*pTL);
   } else {
      TokenList* pTL = new TokenList;
      pTL ->  push_back(TeXToken(TT_LETTER, next.ChrCode(), 0));
      InputStack::Putback(*pTL);
   }
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 338, 339, 340 and 341.}
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro






\fwbeginmacro
\fwmacroname{Add predefined symbols}{342}\fwequals \fwodef \fwbtx[

void SetupExpandables()
{

   NewExpandable("expandafter", xfcnExpandafter, 0);
   NewExpandable("csname",      xfcnCsname, 0);
   NewExpandable("string",      xfcnString, 0);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 345.}
\fwendmacronotes
\fwendmacro




Here is an example of an unwanted dependency. The macro expander is a
low level thing that doesn't need to know about the typesetter,
another low-level thing. But we have to expand \fwlit{\char`\\topmarks} here. So
how do we know what the values are? There has to be an even lower
level repository of mark data. That everyone knows about.

\fwbeginmacro
\fwmacroname{Do mark}{343}\fwzero{}\fwequals \fwodef \fwbtx[   if (repository.topmark() != 0){
      iosys::push_token_list(repository.topmark());
   }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is NEVER invoked.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwfilename{expandables.h}{344}\fwequals \fwodef \fwbtx[#ifndef EXPANDABLES_H
#define EXPANDABLES_H

]fwetx=%
\fwmacroname{Expandable declarations}{317}\fwbtx[

#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwfilename{expandables.cpp}{345}\fwequals \fwodef \fwbtx[#include "platform.h"
#include "basicdata.h"
#include "tokens.h"
#include "scanutils.h"
#include "macros.h"
]fwetx=%
\fwmacroname{Expansion functions}{338}\fwbtx[
]fwetx=%
\fwmacroname{Misc functions}{319}\fwbtx[
]fwetx=%
\fwmacroname{Add predefined symbols}{342}\fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro









\fwseca{10}{Conditional processing}

We require some flexibility because we want to be able to add
conditionals later. Conditionals are not seen by the command
processor. On the other hand, we don't want the macro processor to
know about the various things that are the objects of conditionals
like glue, dimensions, and numbers.

\fwbeginmacro
\fwmacroname{Conditional symbols}{346}\fwplusequals \fwodef \fwbtx[NewExpandable("iftrue",  xfcnIf, (int)tfcnIfTrue);
NewExpandable("iffalse", xfcnIf, (int)tfcnIfFalse);

NewExpandable("ifvmode", xfcnIf, (int)tfcnIfVmode);
NewExpandable("ifhmode", xfcnIf, (int)tfcnIfHmode);
NewExpandable("ifmmode", xfcnIf, (int)tfcnIfMmode);
NewExpandable("ifinner", xfcnIf, (int)tfcnIfInner);

NewExpandable("ifvoid",  xfcnIf, (int)tfcnIfVoid);
NewExpandable("ifhbox",  xfcnIf, (int)tfcnIfHbox);
NewExpandable("ifvbox",  xfcnIf, (int)tfcnIfVbox);

NewExpandable("ifeof",   xfcnIf, (int)tfcnIfEof);

NewExpandable("ifx",     xfcnIf, (int)tfcnIfx);
NewExpandable("ifcat",   xfcnIf, (int)tfcnIfcat);
NewExpandable("if",      xfcnIf, (int)tfcnIf);

NewExpandable("ifnum",   xfcnIf, (int)tfcnIfnum);
NewExpandable("ifodd",   xfcnIf, (int)tfcnIfodd);
NewExpandable("ifdim",   xfcnIf, (int)tfcnIfdim);

NewExpandable("ifcase",  xfcnIf, (int)tfcnIfcase);
NewExpandable("else",    xfcnElse, 0);
NewExpandable("or",      xfcnOr, 0);
NewExpandable("fi",      xfcnFi, 0);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 346.}
\fwusedin{This macro is invoked in definition 355.}
\fwendmacronotes
\fwendmacro



In the case of an \fwlit{\char`\\if...} the data field of the \fwlit{Expandable}
is used to hold a pointer to a function that performs the required
test.

\fwsecb{10.1}{Condition stack}

Conditions may be nested inside conditions, e.g.
\fwlit{\char`\\ifnum\char`\\ifnum 3\char`\<4 12\char`\\fi\char`\>2 Yes\char`\\else no\char`\\fi} should work out to \fwlit{Yes}.

There is a problem with something like \fwlit{\char`\\ifnum5\char`\<4\char`\\else no\char`\\fi}
because we see the \fwlit{\char`\\else} while scanning the argument to the condition.

The expansion for \fwlit{\char`\\else} has to insert a \fwlit{\char`\\relax} to terminate the
tested expression. To faciliate this we have a condition stack.

\fwbeginmacro
\fwmacroname{Condition Stack}{347}\fwplusequals \fwodef \fwbtx[
enum IfState {IF_SCAN_COND, IF_SCAN_FI};

struct ConditionEntry {

};

static std::vector<ConditionEntry> s_condstack(10);

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 347.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro




\fwsecb{10.2}{Token related conditionals}


\fwbeginmacro
\fwmacroname{Interpretter forward declarations}{348}\fwplusequals \fwodef \fwbtx[bool tfcnIf();
bool tfcnIfx();
bool tfcnIfcat();
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 348, 353, 368, 370 and 372.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



The tests for \fwlit{\char`\\if}, and \fwlit{\char`\\ifcat} require the following auxiliary
function.

\fwbeginmacro
\fwmacroname{Condition test functions}{349}\fwplusequals \fwodef \fwbtx[void GetCodes(TokenType& cc, TeXChar& tc)
{
   TeXToken& tok = CurTok();
   if (tok.Type() != TT_SYMBOL && tok.Type() != TT_ACTIVE){
      cc = tok.Type(); //GetCatcode(tok.ChrCode());
      tc = tok.ChrCode();
      return;
   }
   if (tok.Type() == TT_SYMBOL || tok.Type() == TT_ACTIVE){
      // need to check whther \let to a character token
      if (CurCmdCode() == CMD_LET_TOK){
         Primitive* prim = dynamic_cast<Primitive*>(CurData());
         TeXToken* pTok = (TeXToken*) prim -> Data();
         tc = pTok -> ChrCode();
         cc = pTok -> Type(); //GetCatcode(tc);
      } else {
         cc = (TokenType)16;
         tc = 256;
      }
   } else {
      LOG("\nERROR: unimplemented test of active char defs");
      ASSERT(false);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Condition test functions}{350}\fwplusequals \fwodef \fwbtx[bool tfcnIf()
{
   TeXToken tok1, tok2;
   TokenType cc1, cc2;
   TeXChar tc1, tc2;

   GetToken();
   GetCodes(cc1, tc1);

   GetToken();
   GetCodes(cc2, tc2);

   return tc1 == tc2;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Condition test functions}{351}\fwplusequals \fwodef \fwbtx[bool tfcnIfcat()
{
   TeXToken tok1, tok2;
   TokenType cc1, cc2;
   TeXChar tc1, tc2;

   GetRawToken();
   GetCodes(cc1, tc1);

   GetRawToken();
   GetCodes(cc2, tc2);

   return cc1 == cc2;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Condition test functions}{352}\fwplusequals \fwodef \fwbtx[bool tfcnIfx()
{
   TeXToken tok1, tok2;
   const SymbolData* pData1 = 0;
   const SymbolData* pData2 = 0;

   TokenType cc1, cc2;
   TeXChar tc1, tc2;
   const MacroDef* pMacDef1 = 0;
   const MacroDef* pMacDef2 = 0;

   GetRawToken();
   tok1 = CurTok();
   DetermineCommandCode();
   pData1 = CurData();
   GetCodes(cc1, tc1);
   if (cc1 == 16){
      pMacDef1 = dynamic_cast<const MacroDef*>(CurData());
   }

   GetRawToken();
   tok2 = CurTok();
   DetermineCommandCode();
   pData2 = CurData();
   GetCodes(cc2, tc2);
   if (cc2 == 16){
      pMacDef2 = dynamic_cast<const MacroDef*>(CurData());
   }

   if (pMacDef1 != 0 && pMacDef2 != 0){
      // Both macros -- compare defs
      return (pMacDef1 -> Toks() == pMacDef2 -> Toks());
   } else if (pMacDef1 == 0 && pMacDef2 == 0){
      // Neither macro
      const Primitive* pPrim1 = dynamic_cast<const Primitive*>(pData1);
      const Primitive* pPrim2 = dynamic_cast<const Primitive*>(pData2);
      if (pPrim1 != 0 && pPrim2 != 0){
         if (pPrim1 -> curcmd() != pPrim2 -> curcmd()){
            return false;
         }
         if (  pPrim1 -> curcmd() == CMD_CHAR_GIVEN ){
            return (pPrim1 -> Data() == pPrim2 -> Data());
         } else if (pPrim1 -> curcmd() == CMD_LET_TOK){
            return ((tc1 == tc2) && (cc1 == cc2));
         } else {
            LOG("\nWARNING -- may be other cases");
            return true;
         }
      } else if (pPrim1 == 0 && pPrim2 == 0) {
         return (tc1 == tc2);
      } else
         return false;
   } else {
      return false;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro




\fwsecb{10.3}{Integer conditionals}

\fwbeginmacro
\fwmacroname{Interpretter forward declarations}{353}\fwplusequals \fwodef \fwbtx[bool tfcnIfnum();
bool tfcnIfdim();
bool tfcnIfodd();
bool tfcnIfcase();
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 348, 353, 368, 370 and 372.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Declare InitConditionalSymbols}{354}\fwequals \fwodef \fwbtx[void InitConditionalSymbols();
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 374.}
\fwendmacronotes
\fwendmacro

\fwbeginmacro
\fwmacroname{Implement InitConditionalSymbols}{355}\fwplusequals \fwodef \fwbtx[void InitConditionalSymbols()
{
   ]fwetx=%
\fwmacroname{Conditional symbols}{346}\fwbtx[
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 355.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro






\fwbeginmacro
\fwmacroname{Condition test functions}{356}\fwplusequals \fwodef \fwbtx[
TeXToken equal  (TT_OTHER, '=', 0);
TeXToken greater(TT_OTHER, '>', 0);
TeXToken less   (TT_OTHER, '<', 0);

enum Test { TEST_EQ, TEST_LESS, TEST_GREATER};

bool tfcnIfnum()
{
   int m,n;
   Test test;
   ScanInt(&m);
   GetNext_NonBlank_NonCall();
   if (CurTok() == equal){
      test = TEST_EQ;
   } else if (CurTok() == greater){
      test = TEST_GREATER;
   } else if (CurTok() == less){
      test = TEST_LESS;
   } else {
      test = TEST_EQ;
      ASSERT(false);
   }

   ScanInt(&n);
   bool b = false;
   if (test == TEST_EQ){
     b = (m == n);
   } else if (test == TEST_LESS){
     b = (m < n);
   } else if (test == TEST_GREATER){
     b = (m > n);
   }
   LOG("\n--ifnum " << m);
   if (test == TEST_EQ){
     LOG(" = ");
   } else if (test == TEST_LESS){
     LOG(" < ");
   } else if (test == TEST_GREATER){
     LOG(" > ");
   }
   LOG(n);
   if (b){
     LOG(" is true");
   } else {
     LOG(" is false");
   }

   return b;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Condition test functions}{357}\fwplusequals \fwodef \fwbtx[bool tfcnIfdim()
{
   int m,n;
   Test test;
   ScanDim(false, false, false, &m);
   GetNext_NonBlank_NonCall();
   if (CurTok() == equal){
      test = TEST_EQ;
   } else if (CurTok() == greater){
      test = TEST_GREATER;
   } else if (CurTok() == less){
      test = TEST_LESS;
   } else {
      test = TEST_EQ;
      ASSERT(false);
   }

   ScanDim(false, false, false, &n);
   bool b = false;
   if (test == TEST_EQ){
     b = (m == n);
   } else if (test == TEST_LESS){
     b = (m < n);
   } else if (test == TEST_GREATER){
     b = (m > n);
   }
   LOG("\n--ifnum " << m);
   if (test == TEST_EQ){
     LOG(" = ");
   } else if (test == TEST_LESS){
     LOG(" < ");
   } else if (test == TEST_GREATER){
     LOG(" > ");
   }
   LOG(n);
   if (b){
     LOG(" is true");
   } else {
     LOG(" is false");
   }

   return b;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Condition test functions}{358}\fwplusequals \fwodef \fwbtx[bool tfcnIfodd()
{
   int m;
   ScanInt(&m);
   return ((m % 2) == 1);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Condition test functions}{359}\fwplusequals \fwodef \fwbtx[bool tfcnIfcase()
{
   int m;
   ScanInt(&m);
   LOG("\nERROR -- unimplemented \\ifcase");
   return true;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{Some defines for conditionals}{360}\fwplusequals \fwodef \fwbtx[typedef bool (*TESTFUNCT)(void);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 360.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Conditional expansion functions}{361}\fwplusequals \fwodef \fwbtx[
void PassText();

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 361, 363, 364, 365 and 366.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro


Here are a couple simple condition test functions.

\fwbeginmacro
\fwmacroname{Condition test functions}{362}\fwplusequals \fwodef \fwbtx[bool tfcnIfTrue()
{
   return true;
}

bool tfcnIfFalse()
{
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Conditional expansion functions}{363}\fwplusequals \fwodef \fwbtx[bool xfcnElse(int /* ignored */, TeXToken*, SymbolData**)
{
   PassText();
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 361, 363, 364, 365 and 366.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Conditional expansion functions}{364}\fwplusequals \fwodef \fwbtx[bool xfcnOr(int /* ignored */, TeXToken*, SymbolData**)
{
   PassText();
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 361, 363, 364, 365 and 366.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Conditional expansion functions}{365}\fwplusequals \fwodef \fwbtx[bool xfcnFi(int /* ignored */, TeXToken*, SymbolData**)
{
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 361, 363, 364, 365 and 366.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Conditional expansion functions}{366}\fwplusequals \fwodef \fwbtx[
bool xfcnIf(int testfcnaddr, TeXToken*, SymbolData**)
{
   TESTFUNCT bTest = (TESTFUNCT) testfcnaddr;
   if (bTest()){
      LOG("\nCondition is true");
      // Take true branch
   } else {
      // Take false branch
      LOG("\nCondition is false");
      PassText();
   }
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 361, 363, 364, 365 and 366.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{PassText}{367}\fwequals \fwodef \fwbtx[void PassText()
{
   int level = 0;
   while (true) {
      GetRawToken();
      if (TT_SYMBOL == CurTok().Type()){
         SymbolData* pDef = 0;
         Symbols::GetDef(CurTok().Symbol(), &pDef);
         const Expandable* exp = dynamic_cast<const Expandable*>(pDef);
         if (exp != 0){
            EXPFUNC fcn = exp -> m_fcnExpand;
            if (fcn == xfcnElse || fcn == xfcnFi){
               if (level == 0)
                  break;
               if (fcn == xfcnFi)
                  --level;
            } else if (fcn == xfcnIf){
               ++level;
            }
         }
      }
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro



\fwsecb{10.4}{Mode testing conditionals}

\fwbeginmacro
\fwmacroname{Interpretter forward declarations}{368}\fwplusequals \fwodef \fwbtx[bool tfcnIfVmode();
bool tfcnIfHmode();
bool tfcnIfMmode();
bool tfcnIfInner();
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 348, 353, 368, 370 and 372.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Condition test functions}{369}\fwplusequals \fwodef \fwbtx[bool tfcnIfVmode()
{
   return (Typesetter::GetMode() == MODE_VERTICAL);
}


bool tfcnIfHmode()
{
   return (Typesetter::GetMode() == MODE_HORIZONTAL);
}

bool tfcnIfMmode()
{
   return (Typesetter::GetMode() == MODE_MATH);
}
bool tfcnIfInner()
{
   return (Typesetter::GetInner());
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro



\fwsecb{10.5}{ifeof}

\fwbeginmacro
\fwmacroname{Interpretter forward declarations}{370}\fwplusequals \fwodef \fwbtx[bool tfcnIfEof();
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 348, 353, 368, 370 and 372.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Condition test functions}{371}\fwplusequals \fwodef \fwbtx[bool tfcnIfEof()
{
   int m;
   ScanInt(&m);

   if (Global::g_readFile[m] == 0)
     return true;
   return (Global::g_readFile[m] -> bEOS());
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro







\fwsecb{10.6}{Box testing conditionals}

\fwbeginmacro
\fwmacroname{Interpretter forward declarations}{372}\fwplusequals \fwodef \fwbtx[bool tfcnIfVoid();
bool tfcnIfHbox();
bool tfcnIfVbox();
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 348, 353, 368, 370 and 372.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Condition test functions}{373}\fwplusequals \fwodef \fwbtx[bool tfcnIfVoid()
{
   int m;
   ScanInt(&m);
   LOG("\n---- ERROR: Unimplemented \\ifvoid");
   return false;
}

bool tfcnIfHbox()
{
   int m;
   ScanInt(&m);
   LOG("\n---- ERROR: Unimplemented \\ifhbox");
   return false;
}


bool tfcnIfVbox()
{
   int m;
   ScanInt(&m);
   LOG("\n---- ERROR: Unimplemented \\ifvbox");
   return false;
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 349, 350, 351, 352, 356, 357, 358, 359, 362, 369, 371 and 373.}
\fwusedin{This macro is invoked in definition 375.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwfilename{conditionals.h}{374}\fwequals \fwodef \fwbtx[#ifndef CONDITIONALS_H
#define CONDITIONALS_H
]fwetx=%
\fwmacroname{Declare InitConditionalSymbols}{354}\fwbtx[
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{conditionals.cpp}{375}\fwequals \fwodef \fwbtx[#include "conditionals.h"
#include "macros.h"
#include "symbols.h"
#include "tokens.h"
#include "scanutils.h"
#include "typesetter.h"
]fwetx=%
\fwmacroname{Condition Stack}{347}\fwbtx[
]fwetx=%
\fwmacroname{Some defines for conditionals}{360}\fwbtx[
]fwetx=%
\fwmacroname{Condition test functions}{349}\fwbtx[
]fwetx=%
\fwmacroname{Conditional expansion functions}{361}\fwbtx[
]fwetx=%
\fwmacroname{PassText}{367}\fwbtx[
]fwetx=%
\fwmacroname{Implement InitConditionalSymbols}{355}\fwbtx[

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwseca{11}{Fonts metric data}

A \fwlit{TFM} file is a binary file containing font information.
It contains the information needed to place the characters but does
not have information about how to draw the characters.

\fwbeginmacro
\fwmacroname{class TFM}{376}\fwequals \fwodef \fwbtx[class TFM {
   long lf; // length of file
   long lh; // length of header
   long bc; // smallest charcode in font
   long ec; // largest charcode in font
   long nw; // # of words in width table
   long nh; // # of words in the height table
   long nd; // # of words in the depth table
   long ni; // # of words in the italic correction table
   long nl; // # of words in the lig/kern table
   long nk; // # of words in the kern table
   long ne; // # of words in the extensible character table
   long np; // # of font parameter words

   // header
   checksum;
   design_size;
   char_info
       // for each character the following data
       width_index;
       height_index;
       depth_index;
       italic_index;
       tag;
       remainder;
    width  -  an array of widths indexed by the width_indicies to
       get the actual width
    height -  similar
    depth  -  similar
    italic -  similar
    lig_kern - a table of simple programming instructions for
       setting the ligatures and kerns.
    kern - a table of kern values indexed by lig_kern_instructions.
    exten - a table of extensible_recipes TRMRB (top, repeat, middle,
       repeat, bottom)
    param  -  font parameters
       slant
       space
       space_stretch
       space_shrink
       x_height
       quad
       extra_space (at end of sentence)
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 377.}
\fwendmacronotes
\fwendmacro


Omega extensions?

Internally we'll maintain a table of TFMs so that we may
reference quickly any particular font data.



\fwbeginmacro
\fwfilename{fonts.h}{377}\fwequals \fwodef \fwmacroname{class TFM}{376}\fwbtx[

struct FontData{
void Load(...);
void Unload(...);

};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwseca{12}{The Command Interpretter}

The Command Interpretter contains the main loop of \TeX{}. It gets
unexpandable tokens from the macro processor and parses tokens until
a command is recognized. The command is executed immediately.
Most commands will be addressed to the Typesetter, but not all.
Some, e.g. \fwlit{\char`\\catcode} are addresed to the text io subsystem.
Some change the state of the command interpretter itself.

\fwbeginmacro
\fwmacroname{class Interpretter}{378}\fwequals \fwodef \fwbtx[class Interpretter {
public:
   static void InitializeSymbolTable();
   static void MainLoop();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 497.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{InitializeSymbolTable}{379}\fwequals \fwodef \fwbtx[void Interpretter::InitializeSymbolTable()
{
   ]fwetx=%
\fwmacroname{Create symbols}{316}\fwbtx[
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro




Here are some variables global to the interpretter
\fwbeginmacro
\fwmacroname{Declare interpretter global variables}{380}\fwplusequals \fwodef \fwbtx[//static CommandCode curcmd;
//static Primitive* curcmddata;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 380.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Functions for inserting primitive hooks}{381}\fwplusequals \fwodef \fwbtx[
void hookA(const char* cmd)
{
   std::string idstr;
   idstr = "msi@hook@";
   idstr += cmd;

   TeXToken tt;
   String str = StringBuilder::Create(idstr.c_str());
   // lookup cs in symbols table
   Symbols::SymId id;
   Symbols::GetId(str, &id, Symbols::CREATE);
   tt.SetType(TT_SYMBOL);
   tt.SetSymbol(id);
   inp.Putback(tt);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 381.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwsecb{12.1}{Main Loop}
Here is the main loop. It fetches a token and jumps to a case in a
big switch statement. The case depends also on the current mode.
The case will parse the rest of the command and execute it.
The action will likely include more parsing to get the arguments
for the command.


\fwbeginmacro
\fwmacroname{Main Loop}{382}\fwequals \fwodef \fwbtx[void Interpretter::MainLoop()
{
 bool running = true;
 while (running && !inp.bEmpty()) {
   LOG("\n----Start cycle");
   GetToken();
   DetermineCommandCode();
   ]fwetx=%
\fwmacroname{Execute the command}{383}\fwbtx[
 }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


Each command processed by the command interpretter has a code
that is listed in the enumerated type \fwlit{CommandCode}.



\fwbeginmacro
\fwmacroname{Execute the command}{383}\fwequals \fwodef \fwbtx[   switch (CurCmdCode()) {
      ]fwetx=%
\fwmacroname{Node creation commands}{395}\fwbtx[
      ]fwetx=%
\fwmacroname{Prefix commands}{504}\fwbtx[
      ]fwetx=%
\fwmacroname{Basic assignment commands}{509}\fwbtx[
      ]fwetx=%
\fwmacroname{Macro definition commands}{666}\fwbtx[
      ]fwetx=%
\fwmacroname{Assign box dimension commands}{605}\fwbtx[
      ]fwetx=%
\fwmacroname{Register commands}{571}\fwbtx[
      ]fwetx=%
\fwmacroname{Box building commands}{612}\fwbtx[
      ]fwetx=%
\fwmacroname{Unboxing commands}{618}\fwbtx[
      ]fwetx=%
\fwmacroname{Message commands}{456}\fwbtx[
      ]fwetx=%
\fwmacroname{Stop commands}{428}\fwbtx[
      ]fwetx=%
\fwmacroname{Grouping commands}{445}\fwbtx[
      ]fwetx=%
\fwmacroname{Font commands}{469}\fwbtx[
      ]fwetx=%
\fwmacroname{Math commands}{750}\fwbtx[
      ]fwetx=%
\fwmacroname{Misc commands}{392}\fwbtx[
      ]fwetx=%
\fwmacroname{Extensions}{466}\fwbtx[
      case CMD_NONE:{
        LOG("\n----" << CurTok()
                     << " ERROR -- no command code.");

        std::cout << "\n-- Undefined " ;
        String s = Symbols::GetName(CurTok().Symbol());
        std::cout << "\\";
        for (int i = 0; i < s.Size(); ++i){
          if (s[i] >= 32 && s[i] <= 126){
             std::cout << (char) s[i];
          } else {
             std::cout << "[chr " << (int) s[i] << "]";
          }
        }
        // Give it a default definition and put back the token
        TokenList* pTokenList = new TokenList;
        pTokenList -> push_back(TeXToken(TT_END_MATCH,0,0));

        pTokenList -> AppendSymbol("msitexb");
        pTokenList -> push_back(TeXToken(TT_LEFT_BRACE,'{',0));
        pTokenList -> push_back(TeXToken(CurTok()));
        pTokenList -> push_back(TeXToken(TT_RIGHT_BRACE,'}',0));
        MacroDef* pMacroDef = new MacroDef(pTokenList);

        Symbols::SetDef(CurTok().Symbol(), pMacroDef, false);

        // Let's just append the token to the
        // output stream, and assume we go to hmode
        if (Typesetter::GetMode() == MODE_VERTICAL){
           inp.Putback(CurTok());
           Typesetter::GotoHMode();
           Typesetter::SetInner(false);
           inp.Putback(Global::msieverypar);
           inp.Putback(Global::everypar);
        } else {
           TokenList* pTL = new TokenList;
           pTL->push_back(CurTok());
           Typesetter::AppendTag(pTL);
        }
        break;
      }
      default:
        LOG("\n----" << CurTok()
                     << " ERROR -- can't happen");
        break;
   }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 382.}
\fwendmacronotes
\fwendmacro




The command interpretter must maintain a stack that records the current
level and type of level.

\fwbeginmacro
\fwmacroname{GroupStack}{384}\fwplusequals \fwodef \fwbtx[enum GroupType {
       SIMPLE_GROUP,
       SEMISIMPLE_GROUP,
       ALIGN_GROUP,
       HBOX_GROUP,
       VBOX_GROUP,
       INLINE_GROUP,  // for $...$
       DISPLAY_GROUP, // for $$...$$
       MATH_GROUP,    // for {...} inside math
       PROCESS_GROUP
     };
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 384, 385, 386, 387, 388 and 389.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{GroupStack}{385}\fwplusequals \fwodef \fwbtx[struct GroupRecord {
   GroupType  m_groupType;
   TokenList* m_afterGroup;
};

const int MAX_GROUPS = 400;
static GroupRecord s_groupStack[MAX_GROUPS];
static int s_groupStackTop = -1;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 384, 385, 386, 387, 388 and 389.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{GroupStack}{386}\fwplusequals \fwodef \fwbtx[void ShowGroupStack()
{
   LOG("\nGroups: ");
   int lev = s_groupStackTop;
   while (lev >= 0){
      GroupType type = s_groupStack[lev].m_groupType;
      if (type == HBOX_GROUP){
         LOG("hbox ");
      } else if (type == VBOX_GROUP){
         LOG("vbox ");
      } else if (type == SIMPLE_GROUP){
         LOG("simple ");
      } else if (type == SEMISIMPLE_GROUP){
         LOG(" semi-simple ");
      }  else if (type == INLINE_GROUP){
         LOG("inline ");
      }  else if (type == DISPLAY_GROUP){
         LOG("display ");
      }  else if (type == MATH_GROUP){
         LOG("subformula ");
      }  else if (type == ALIGN_GROUP){
         LOG("align ");
      } else if (type == PROCESS_GROUP){
         LOG("process ");
      } else {
         LOG("ERROR");
      }
      --lev;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 384, 385, 386, 387, 388 and 389.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{GroupStack}{387}\fwplusequals \fwodef \fwbtx[void NewLevel(GroupType type)
{
   if (s_groupStackTop < MAX_GROUPS){
      ++s_groupStackTop;
      s_groupStack[s_groupStackTop].m_groupType = type;
      s_groupStack[s_groupStackTop].m_afterGroup = 0;
      NewSaveLevel();
      if (type == HBOX_GROUP){
         LOG("\n----Begin group: hbox ");
      } else if (type == VBOX_GROUP){
         LOG("\n----Begin group: vbox");
      } else if (type == SIMPLE_GROUP){
         LOG("\n----Begin group: simple");
      } else if (type == SEMISIMPLE_GROUP){
         LOG("\n----Begin group: semi-simple");
      }  else if (type == INLINE_GROUP){
         LOG("\n----Begin group: inline math");
      }  else if (type == DISPLAY_GROUP){
         LOG("\n----Begin group: display math");
      }  else if (type == MATH_GROUP){
         LOG("\n----Begin group: math subformula");
      }  else if (type == ALIGN_GROUP){
         LOG("\n----Begin group: align");
      } else if (type == PROCESS_GROUP){
         LOG("\n----Begin group: process");
      } else {
         LOG("\nERROR -- begin unknown group type");
      }
      ShowGroupStack();

   } else {
      ASSERT(false);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 384, 385, 386, 387, 388 and 389.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{GroupStack}{388}\fwplusequals \fwodef \fwbtx[bool bCurrentLevelType(GroupType type){
   return s_groupStack[s_groupStackTop].m_groupType == type;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 384, 385, 386, 387, 388 and 389.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{GroupStack}{389}\fwplusequals \fwodef \fwbtx[void EndLevel()
{
   if (s_groupStackTop < 0){
      ASSERT(false);
   } else {
      if (bCurrentLevelType(HBOX_GROUP)){
         LOG("\n----End group: hbox");
         Typesetter::EndBox();
      } else if (bCurrentLevelType(VBOX_GROUP)){
         LOG("\n----End group: vbox");
         Typesetter::EndBox();
      } else if (bCurrentLevelType(SIMPLE_GROUP)){
         LOG("\n----End group: simple");
      } else if (bCurrentLevelType(SEMISIMPLE_GROUP)){
         LOG("\n----End group: semi-simple");
      } else if (bCurrentLevelType(INLINE_GROUP)){
         LOG("\n----End group: inline");
         Typesetter::EndInline();
      } else if (bCurrentLevelType(DISPLAY_GROUP)){
         LOG("\n----End group: dispaly");
         Typesetter::EndDisplay();
      } else if (bCurrentLevelType(MATH_GROUP)){
         Typesetter::EndSubformula();
         LOG("\n----End group: math subformula");
      } else if (bCurrentLevelType(ALIGN_GROUP)){
         LOG("\n----End group: align");
      } else if (bCurrentLevelType(PROCESS_GROUP)){
         Typesetter::EndProcess();
         LOG("\n----End group: process");
      } else {
         LOG("\n----End unknown group type");
         ASSERT(false);
      }
      EndSaveLevel();
      // Push the aftergroup tokens.
      TokenList* afterGroup = s_groupStack[s_groupStackTop].m_afterGroup;
      if (afterGroup != 0){
         InputStack::Putback(*afterGroup);
      }
      --s_groupStackTop;
      ShowGroupStack();
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 384, 385, 386, 387, 388 and 389.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwsecb{12.2}{Some debugging aids}

\noseealso

\fwbeginmacro
\fwmacroname{Command Codes}{390}\fwplusequals \fwodef \fwbtx[CMD_BREAKPOINT,
CMD_CHECKOUTER,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{391}\fwplusequals \fwodef \fwbtx[NewPrimitive("msibreak", CMD_BREAKPOINT);
NewPrimitive("msicheckouter", CMD_CHECKOUTER);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Misc commands}{392}\fwplusequals \fwodef \fwbtx[case CMD_BREAKPOINT : {
   LOG("\nSet breakpoint here");
   break;
}

case CMD_CHECKOUTER: {
   if (s_groupStackTop != -1){
     LOG("\nERROR -- Check outer failed.");
     ShowGroupStack();
     ASSERT(false);
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro







\fwsecb{12.3}{Commands to insert nodes into the current list}

\fwsecc{12.3.1}{Character node creation}


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{393}\fwplusequals \fwodef \fwbtx[CMD_LETTER,
CMD_OTHER,
CMD_CHAR,
CMD_CHAR_GIVEN,
CMD_MATH_GIVEN,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{394}\fwplusequals \fwodef \fwbtx[NewPrimitive("char", CMD_CHAR);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


If we encounter one of these commands in either horizontal mode
or mathmode we call the typesetter's SetChar routine. Otherwise, if we
are in vertical mode, we switch to \fwlit{HMODE} first: when a token
causes the switch to horizontal mode we first put the token back
into the input stream. It has to be interpretted
in the correct mode. Then we tell the typesetter to switch modes.
This will cause a new paragraph to start, so we also have to push the
the everypar tokens into the input stream.

\fwbeginmacro
\fwmacroname{Node creation commands}{395}\fwplusequals \fwodef \fwbtx[case CMD_LETTER :
   if (Typesetter::GetMode() == MODE_VERTICAL){
      // Goto HMODE, rescan token
      inp.Putback(CurTok());
      Typesetter::GotoHMode();
      Typesetter::SetInner(false);
      inp.Putback(Global::msieverypar);
      inp.Putback(Global::everypar);
   } else if (Typesetter::GetMode() == MODE_HORIZONTAL){
      Typesetter::SetChar(CurTok().ChrCode());
      LOG("\n----Character " << CurTok().ChrCode());
   } else if (Typesetter::GetMode() == MODE_MATH){
      if (CurTok().ChrCode() < 128){
         Typesetter::SetMathChar(CurTok().ChrCode());
      } else {
         Typesetter::SetMathChar(CurTok().ChrCode());
      }
      LOG("\n----Character " << CurTok().ChrCode());
   }
   break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Node creation commands}{396}\fwplusequals \fwodef \fwbtx[case CMD_OTHER :
   if (Typesetter::GetMode() == MODE_VERTICAL){
      // Goto HMODE, rescan token
      inp.Putback(CurTok());
      Typesetter::GotoHMode();
      Typesetter::SetInner(false);
      inp.Putback(Global::msieverypar);
      inp.Putback(Global::everypar);
   } else if (Typesetter::GetMode() == MODE_HORIZONTAL){
      Typesetter::SetChar(CurTok().ChrCode());
      LOG("\n----Character " << CurTok().ChrCode());
   }  else if (Typesetter::GetMode() == MODE_MATH){
      if (CurTok().ChrCode() < 128){
         Typesetter::SetMathChar(CurTok().ChrCode());
      } else {
         Typesetter::SetMathChar(CurTok().ChrCode());
      }
      LOG("\n----Character " << CurTok().ChrCode());
   }
   break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Node creation commands}{397}\fwplusequals \fwodef \fwbtx[case CMD_CHAR:{
   if (Typesetter::GetMode() == MODE_VERTICAL){
      // Goto HMODE, rescan token
      inp.Putback(CurTok());
      Typesetter::GotoHMode();
      Typesetter::SetInner(false);
      inp.Putback(Global::msieverypar);
      inp.Putback(Global::everypar);
   } else {
      int n;
      ScanInt(&n);
      if (Typesetter::GetMode() == MODE_HORIZONTAL){
         Typesetter::SetChar(n);
      } else if (Typesetter::GetMode() == MODE_MATH){
         if (CurTok().ChrCode() < 128){
            Typesetter::SetMathChar(n);
         } else {
            Typesetter::SetMathChar(n);
         }
      }
      LOG("\n----Character " << (TeXChar)n);
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Node creation commands}{398}\fwplusequals \fwodef \fwbtx[case CMD_CHAR_GIVEN : {
   LOG("\n----CMD_CHAR_GIVEN");
   ASSERT(CurData());
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   Typesetter::SetChar((TeXChar) (prim -> Data()));
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Node creation commands}{399}\fwplusequals \fwodef \fwbtx[case CMD_MATH_GIVEN : {
   LOG("\n----CMD_MATH_GIVEN");
   ASSERT(CurData());
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   Typesetter::SetChar((TeXChar) (prim -> Data()));
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwsecc{12.3.2}{Glue creation commands}


This is generated by a catcode 10 character. See TTP 1041-1045

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{400}\fwplusequals \fwodef \fwbtx[CMD_SPACER,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Node creation commands}{401}\fwplusequals \fwodef \fwbtx[case CMD_SPACER :
   if (Typesetter::GetMode() == MODE_HORIZONTAL){
      LOG("\n----Space " << CurTok().ChrCode());
      Typesetter::SetSpace();
   }
   break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



The explicit space command.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{402}\fwplusequals \fwodef \fwbtx[CMD_EX_SPACE,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Node creation commands}{403}\fwplusequals \fwodef \fwbtx[case CMD_EX_SPACE:{
   LOG("\n---- explicit space");
   ASSERT(false);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro




\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{404}\fwplusequals \fwodef \fwbtx[CMD_HSKIP,
CMD_VSKIP,
CMD_MSKIP,
CMD_HFIL,
CMD_HFILL,
CMD_HFILNEG,
CMD_HSS,
CMD_VFIL,
CMD_VFILL,
CMD_VFILNEG,
CMD_VSS,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{405}\fwplusequals \fwodef \fwbtx[NewPrimitive("hskip", CMD_HSKIP);
NewPrimitive("vskip", CMD_VSKIP);
NewPrimitive("mskip", CMD_MSKIP);

NewPrimitive("hfil",    CMD_HFIL);
NewPrimitive("hfill",   CMD_HFILL);
NewPrimitive("hfilneg", CMD_HFILNEG);
NewPrimitive("hss",     CMD_HSS);
NewPrimitive("vfil",    CMD_VFIL);
NewPrimitive("vfill",   CMD_VFILL);
NewPrimitive("vfilneg", CMD_VFILNEG);
NewPrimitive("vss",     CMD_VSS);

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Node creation commands}{406}\fwplusequals \fwodef \fwbtx[case CMD_VSKIP: {
   ScanGlue();
   LOG("\n----CMD_VSKIP");
   Typesetter::AppendTag("\n\n");
   break;
}

case CMD_HSKIP: {
   ScanGlue();
   LOG("\n----CMD_HSKIP");
   break;
}

case CMD_MSKIP: {
   ScanGlue();
   LOG("\n----CMD_MSKIP");
   break;
}


case CMD_HFIL:{
   LOG("\n----\\hfil");
   hookA("hfil");
   break;
}

case CMD_HFILL:{
   LOG("\n----\\hfill");
   hookA("hfill");
   break;
}
case CMD_HFILNEG:{
   LOG("\n----\\hfilneg");
   hookA("hfilneg");
   break;
}
case CMD_HSS:{
   LOG("\n----\\hss");
   hookA("hss");
   break;
}
case CMD_VFIL:{
   LOG("\n----\\vfil");
   hookA("vfil");
   break;
}
case CMD_VFILL:{
   LOG("\n----\\vfill");
   hookA("vfill");
   break;
}
case CMD_VFILNEG:{
   LOG("\n----\\vfilneg");
   hookA("vfilneg");
   break;
}
case CMD_VSS:{
   LOG("\n----\\vss");
   hookA("vss");
   break;
}


]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro




\fwsecc{12.3.3}{Kern node creation}


Insert a \fwlit{KernNode} into the current list.  TTP 1057

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{407}\fwplusequals \fwodef \fwbtx[CMD_KERN,
CMD_MKERN,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{408}\fwplusequals \fwodef \fwbtx[NewPrimitive("kern", CMD_KERN);
NewPrimitive("mkern", CMD_MKERN);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Node creation commands}{409}\fwplusequals \fwodef \fwbtx[case CMD_KERN:{
   Scaled dim;
   ScanDim(false, false, false, &dim);
   LOG("\n----\\kern " << dim);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Node creation commands}{410}\fwplusequals \fwodef \fwbtx[case CMD_MKERN:{
   Scaled dim;
   ScanDim(false, false, false, &dim);
   LOG("\n----\\mkern " << dim);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwsecc{12.3.4}{Insert node creation}

Insert an \fwlit{InsertNode} into the current list.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{411}\fwplusequals \fwodef \fwbtx[CMD_INSERT,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{412}\fwplusequals \fwodef \fwbtx[NewPrimitive("insert", CMD_INSERT);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Node creation commands}{413}\fwplusequals \fwodef \fwbtx[case CMD_INSERT:{
   int n;
   ScanInt(&n);
   TokenList* pTL = new TokenList;
   ScanTokenList(pTL, false);
   LOG("\n---- insert " << n << " : " << *pTL);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro
;



\fwsecc{12.3.5}{Create mark node}
Insert a \fwlit{MarkNode} into the current list.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{414}\fwplusequals \fwodef \fwbtx[CMD_MARK,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{415}\fwplusequals \fwodef \fwbtx[NewPrimitive("mark", CMD_MARK);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Node creation commands}{416}\fwplusequals \fwodef \fwbtx[case CMD_MARK:{
   TokenList* pTL = new TokenList;
   ScanTokenList(pTL, false);
   LOG("\n---- mark: " << * pTL);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro
;





This inserts an \fwlit{AdjustNode} into the current list.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{417}\fwplusequals \fwodef \fwbtx[CMD_VADJUST,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{418}\fwplusequals \fwodef \fwbtx[NewPrimitive("vadjust", CMD_VADJUST);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Node creation commands}{419}\fwplusequals \fwodef \fwbtx[case CMD_VADJUST:{
   TokenList* pTL = new TokenList;
   ScanTokenList(pTL, false);
   LOG("\n---- vadjust: " << *pTL);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro
;


\fwsecc{12.3.6}{Create penalty nodes}

This command causes a penalty node to be inserted.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{420}\fwplusequals \fwodef \fwbtx[CMD_PENALTY,]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{421}\fwplusequals \fwodef \fwbtx[NewPrimitive("penalty", CMD_PENALTY);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Node creation commands}{422}\fwplusequals \fwodef \fwbtx[case CMD_PENALTY:{
   int p;
   ScanInt(&p);
   LOG("\n---- penalty " << p);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro
;

\fwsecc{12.3.7}{Create rule nodes}

See TTP 1056

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{423}\fwplusequals \fwodef \fwbtx[CMD_HRULE,
CMD_VRULE,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{424}\fwplusequals \fwodef \fwbtx[NewPrimitive("hrule", CMD_HRULE);
NewPrimitive("vrule", CMD_VRULE);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Node creation commands}{425}\fwplusequals \fwodef \fwbtx[case CMD_VRULE: {
   RuleSpec* rs = ScanRuleSpec();
   LOG("\n----CMD_VRULE");
   break;
}

case CMD_HRULE: {
   RuleSpec* rs = ScanRuleSpec();
   LOG("\n----CMD_HRULE");
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 395, 396, 397, 398, 399, 401, 403, 406, 409, 410, 413, 416, 419, 422 and 425.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro







\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{426}\fwplusequals \fwodef \fwbtx[CMD_END,
CMD_DUMP,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{427}\fwplusequals \fwodef \fwbtx[NewPrimitive("end", CMD_END);
NewPrimitive("dump", CMD_DUMP);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Stop commands}{428}\fwequals \fwodef \fwbtx[
case CMD_DUMP: {
   LOG("\n----CMD_DUMP");
   running = false;
   break;
}

case CMD_END: {
   LOG("\n----\\end");
   running = false;
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro




\cmda{\char92/ (Italic correction)}



\cmda{\char92- (Discretionary)}


\cmda{\char92discretionary (Discretionary)}


\cmd{accent}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{429}\fwplusequals \fwodef \fwbtx[CMD_ACCENT,]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro




\cmd{hbox}



\cmd{vbox}



\fwsecb{12.4}{More commands}

\fwsecc{12.4.1}{Tag creating commands}
\fwbeginmacro
\fwmacroname{Command Codes}{430}\fwplusequals \fwodef \fwbtx[CMD_TAG,
CMD_MSIHMODE,
CMD_MSIVMODE,
CMD_OPENTAG,
CMD_CLOSETAG,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Create symbols}{431}\fwplusequals \fwodef \fwbtx[NewPrimitive("msitag", CMD_TAG);
NewPrimitive("msihmode", CMD_MSIHMODE);
NewPrimitive("msivmode", CMD_MSIVMODE);
NewPrimitive("msiopentag", CMD_OPENTAG);
NewPrimitive("msiclosetag", CMD_CLOSETAG);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{TagStack}{432}\fwplusequals \fwodef \fwbtx[static std::list<std::string> s_tagStack;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 432.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Misc commands}{433}\fwplusequals \fwodef \fwbtx[case CMD_TAG : {
   TokenList* pTL = new TokenList;
   ScanTokenList(pTL, false);
   LOG("\n----Create tag " << *pTL);
   Typesetter::AppendTag(pTL);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{434}\fwplusequals \fwodef \fwbtx[case CMD_MSIHMODE : {
   LOG("\n----\\msihmode ");
   if (Typesetter::GetMode() == MODE_VERTICAL){
     Typesetter::GotoHMode();
     inp.Putback(Global::msieverypar);
     inp.Putback(Global::everypar);
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{435}\fwplusequals \fwodef \fwbtx[case CMD_MSIVMODE : {
   LOG("\n----\\msivmode ");
   Typesetter::GotoVMode();
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{Command Codes}{436}\fwplusequals \fwodef \fwbtx[CMD_ENDINPUT,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Create symbols}{437}\fwplusequals \fwodef \fwbtx[NewPrimitive("endinput",  CMD_ENDINPUT, 0, 1);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{438}\fwplusequals \fwodef \fwbtx[case CMD_ENDINPUT : {
   LOG("\n--- \\endinput");
   InputStack::EndInput();
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{439}\fwplusequals \fwodef \fwbtx[case CMD_OPENTAG : {
   TokenList* pTL = new TokenList;
   TokenList* pTLoutput = new TokenList;
   ScanTokenList(pTL, false);
   ScanTokenList(pTLoutput, false);
   LOG("\n----Create open tag " << *pTL << ", " << *pTLoutput);
   Typesetter::AppendTag(pTLoutput);

   StringUtils::AppendToks(*pTL);
   String str = StringBuilder::Create();
   std::string strTemp;
   int i = 0;
   while (i < str.Size()){
      strTemp += (char) str[i];
      ++i;
   }
   StringBuilder::Discard(str);
   s_tagStack.push_back(strTemp);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{440}\fwplusequals \fwodef \fwbtx[case CMD_CLOSETAG : {
   TokenList* pTL = new TokenList;
   TokenList* pTLoutput = new TokenList;

   ScanTokenList(pTL, false);
   ScanTokenList(pTLoutput, false);
   LOG("\n----Create close tag " << *pTL << ", " << *pTLoutput);

   StringUtils::AppendToks(*pTL);
   String str = StringBuilder::Create();
   std::string strTemp;
   int i = 0;
   while (i < str.Size()){
       strTemp += (char) str[i];
       ++i;
   }
   StringBuilder::Discard(str);
   // look for the matching open tag
   std::list<std::string>::reverse_iterator it = s_tagStack.rbegin();
   bool found = false;
   while (it != s_tagStack.rend()){
      if (*it == strTemp){
         found = true;
         break;
      } else {
         ++it;
      }
   }
   // don't let a </p> close anything except
   // an immediately surrounding <p>
   if (found && strTemp == "p"){
      if (it != s_tagStack.rbegin()){
         found = false;
      }
   }
   if (!found){
      LOG("\n----DISCARD Tag " << *pTL);
   } else {
      do {
        if (s_tagStack.back() == strTemp){
          Typesetter::AppendTag(pTLoutput);
          s_tagStack.pop_back();
          break;
        } else {
          LOG("\n----IMPLICIT CLOSING " << s_tagStack.back().c_str());
          std::string closetag = "</";
          closetag += s_tagStack.back();
          closetag += ">";
          Typesetter::AppendTag(closetag.c_str());
          s_tagStack.pop_back();
        }
      } while (true);
   }

   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwsecc{12.4.2}{Paragraph starting and ending}


\fwbeginmacro
\fwmacroname{Command Codes}{441}\fwplusequals \fwodef \fwbtx[CMD_END_PAR,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Create symbols}{442}\fwplusequals \fwodef \fwbtx[NewPrimitive("par", CMD_END_PAR);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{443}\fwplusequals \fwodef \fwbtx[case CMD_END_PAR : {
   LOG("\n----End Paragraph");
   Typesetter::GotoVMode();
   Typesetter::SetInner(false);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\cmda{Left brace}

This is generated by a catcode 1 character.
\fwbeginmacro
\fwmacroname{Command Codes}{444}\fwplusequals \fwodef \fwbtx[CMD_LEFT_BRACE,
CMD_RIGHT_BRACE,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Grouping commands}{445}\fwplusequals \fwodef \fwbtx[case CMD_LEFT_BRACE : {
   if (Typesetter::GetMode() == MODE_MATH){
      LOG("\n----Begin math group " << CurTok());
      InputStack::Putback(CurTok());
      Typesetter::StartNucleus();
      ScanMath();
      break;
      //Typesetter::StartSubformula();
      //NewLevel(MATH_GROUP);
   } else {
      LOG("\n----Begin simple group " << CurTok());
      NewLevel(SIMPLE_GROUP);
   }
   if (Global::msidobraces == 1){
      if (Typesetter::GetMode() == MODE_VERTICAL){
        // Goto HMODE, rescan token
        inp.Putback(CurTok());
        Typesetter::GotoHMode();
        Typesetter::SetInner(false);
        inp.Putback(Global::msieverypar);
        inp.Putback(Global::everypar);
      } else {
        TeXToken lbrace(TT_LETTER, '{', 0);
        TokenList* pTL = new TokenList;
        pTL->push_back(lbrace);
        Typesetter::AppendTag(pTL);
      }
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 445, 446 and 485.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Grouping commands}{446}\fwplusequals \fwodef \fwbtx[case CMD_RIGHT_BRACE : {
   if (Global::msidobraces == 1 || bCurrentLevelType(MATH_GROUP)){
      TeXToken rbrace(TT_LETTER, '}', 0);
      TokenList* pTL = new TokenList;
      pTL->push_back(rbrace);
      Typesetter::AppendTag(pTL);
   }
   EndLevel();
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 445, 446 and 485.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro




\fwsecc{12.4.3}{Show}


\fwbeginmacro
\fwmacroname{Command Codes}{447}\fwplusequals \fwodef \fwbtx[CMD_SHOW,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Create symbols}{448}\fwplusequals \fwodef \fwbtx[NewPrimitive("show", CMD_SHOW);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{449}\fwplusequals \fwodef \fwbtx[case CMD_SHOW : {
   GetRawToken();
   LOG("\nShow " << CurTok() << " ");
   if (CurTok().Type() == TT_SYMBOL){
      SymbolData* pData = CurData();
      const MacroDef* pMacDef = dynamic_cast<const MacroDef*>(pData);
      if (pMacDef != 0){
         LOG("macro " << pMacDef -> Toks());
      }
   }

   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro




\cmda{Superscript}


\cmd{unpenalty}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{450}\fwplusequals \fwodef \fwbtx[UNPENALTY,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro




\cmd{moveleft etc}

See TTP 1071...

\fwbeginmacro
\fwmacroname{Command Codes}{451}\fwplusequals \fwodef \fwbtx[CMD_MOVELEFT, CMD_MOVERIGHT, CMD_RAISE, CMD_LOWER,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro





\cmda{\char92indent and \char92noindent}

See TTP 1090.


\fwbeginmacro
\fwmacroname{Command Codes}{452}\fwplusequals \fwodef \fwbtx[CMD_START_PAR,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{453}\fwplusequals \fwodef \fwbtx[case CMD_START_PAR:{
   LOG("\n---Start paragraph");
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro







\fwsecb{12.5}{Message and errmessage}
\fwbeginmacro
\fwmacroname{Command Codes}{454}\fwplusequals \fwodef \fwbtx[CMD_MESSAGE,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{455}\fwplusequals \fwodef \fwbtx[NewPrimitive("message",  CMD_MESSAGE, 0, 1);
NewPrimitive("errmessage", CMD_MESSAGE, 0, 2);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Message commands}{456}\fwequals \fwodef \fwbtx[case CMD_MESSAGE: {
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   int type = prim -> Data();
   TokenList* pTL = new TokenList;
   ScanTokenList(pTL, false);
   if (type == 1) {
       LOG("\n\\message: ");
   } else {
       LOG("\n\\errmessage: ");
   }
   LOG(*pTL);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro




\fwsecb{12.6}{Logging modes}

\cmd{batchmode}

\cmd{nonstopmode}

\cmd{scrollmode}

\cmd{errorstopmode}



\fwsecb{12.7}{Reading files}
\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{457}\fwplusequals \fwodef \fwbtx[CMD_OPENIN,
CMD_READ,
CMD_CLOSEIN,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{458}\fwplusequals \fwodef \fwbtx[NewPrimitive("read", CMD_READ);
NewPrimitive("openin", CMD_OPENIN);
NewPrimitive("closein", CMD_CLOSEIN);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Misc commands}{459}\fwplusequals \fwodef \fwbtx[case CMD_READ: {
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{460}\fwplusequals \fwodef \fwbtx[   case CMD_READ : {
      int m;
      ScanInt(&m);
      ScanKeyword(Keywords::KW_TO);
      //ScanOptionalSpaces();
      TeXToken defining;
      ]fwetx=%
\fwmacroname{Scan definable symbol}{676}\fwbtx[
      LOG("\n----Read from " << m << " to " << defining);
      break;
   }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Misc commands}{461}\fwplusequals \fwodef \fwbtx[case CMD_OPENIN: {
   int m;
   ScanInt(&m);
   ScanOptionalEquals();

   Filename fn;
   ]fwetx=%
\fwmacroname{Scan filename}{318}\fwbtx[
   LOG("\n----Opening input "
          << m << " as " << fn.GetNameString());
   if (Global::g_readFile[m] != 0){
      LOG("\nDeleting already open read file");
      delete Global::g_readFile[m];
   }

   Global::g_readFile[m] = new InputByteFile;

   if (!Global::g_readFile[m] -> Open(fn)){
      LOG("\nFailed to open read file " << fn.GetNameString());
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{462}\fwplusequals \fwodef \fwbtx[case CMD_CLOSEIN: {
   int m;
   ScanInt(&m);
   LOG("\n----Closing input " << m);
   delete Global::g_readFile[m];
   Global::g_readFile[m] = 0;
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro






\fwsecb{12.8}{Writing files}
These are implemented as extensions.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{463}\fwplusequals \fwodef \fwbtx[CMD_EXTENSION,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Command subcodes}{464}\fwplusequals \fwodef \fwbtx[enum ExtCode{
   EXT_IMMED,
   EXT_WRITE,
   EXT_OPENOUT,
   EXT_CLOSEOUT,
   EXT_EXTPROC};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 464, 502, 507, 512, 569 and 756.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{465}\fwplusequals \fwodef \fwbtx[NewPrimitive("immediate",CMD_EXTENSION, false, EXT_IMMED);
NewPrimitive("write", CMD_EXTENSION, false, EXT_WRITE);
NewPrimitive("openout", CMD_EXTENSION, false, EXT_OPENOUT);
NewPrimitive("closeout", CMD_EXTENSION, false, EXT_CLOSEOUT);
NewPrimitive("msiextproc", CMD_EXTENSION, false, EXT_EXTPROC);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Extensions}{466}\fwplusequals \fwodef \fwbtx[case CMD_EXTENSION: {
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   ExtCode subtype = (ExtCode) prim -> Data();
   switch(subtype){
      case EXT_IMMED : {
         LOG("\n----Immediate");
         break;
      }
      case EXT_WRITE : {
         int m;
         TokenList* pTL = new TokenList;
         ScanInt(&m);
         ScanTokenList(pTL, true);
         LOG("\n----Write to " << m << " the tokens " << *pTL);

         StringUtils::AppendToks(*pTL);
         String str = StringBuilder::Create();
         if (m >= 0 && m <= 15){
            if (Global::g_writeFile[m] == 0){
               LOG("\nOutput file " << m << " is not open. ");
               LOG("Writing to log.");
               LOG("\n*** " << str);
            } else {
               Global::g_writeFile[m] -> Write(str);
            }
         } else {
            LOG("\n*** " << str);
         }
         StringBuilder::Discard(str);

         break;
      }
      case EXT_OPENOUT : {
         int m;
         ScanInt(&m);
         ScanOptionalEquals();

         Filename fn;
         ]fwetx=%
\fwmacroname{Scan filename}{318}\fwbtx[
         LOG("\n----Opening output "
                     << m << " as "
                     << fn.GetNameString());
         if (Global::g_writeFile[m] != 0){
            LOG("\nDeleting already open write file");
            delete Global::g_writeFile[m];
         }

         Global::g_writeFile[m] = new OutputByteFile;

         if (!Global::g_writeFile[m] -> Open(fn)){
            LOG("\nFailed to open write file " << fn.GetNameString());
         }

         break;
      }
      case EXT_CLOSEOUT : {
         int m;
         ScanInt(&m);
         LOG("\n----Closing output " << m);
         if (m >= 0 && m <= 15){
            delete Global::g_writeFile[m];
            Global::g_writeFile[m] = 0;
         }
         break;
      }
      case EXT_EXTPROC : {
         Filename fn;
         ]fwetx=%
\fwmacroname{Scan filename}{318}\fwbtx[
         LOG("\n----Starting processor " << fn.GetNameString());
         //ScanLeftBrace();
         Typesetter::StartProcess(fn.GetNameString());
         //NewLevel(PROCESS_GROUP);
         TokenList* tl = new TokenList;
         ScanTokenList(tl, false);
         Typesetter::AppendTag(tl);
         //EndLevel();
         Typesetter::EndProcess();
         break;
      };

      default: {
         LOG("ERROR --- unknown extension");
         ASSERT(false);
         break;
      }

   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 466.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro






\fwsecb{12.9}{$\backslash$char92font}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{467}\fwplusequals \fwodef \fwbtx[CMD_SET_FONT,
CMD_FONT_SWITCH,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{468}\fwplusequals \fwodef \fwbtx[NewPrimitive("font", CMD_SET_FONT);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Font commands}{469}\fwplusequals \fwodef \fwbtx[case CMD_SET_FONT:{
   TeXToken defining;
   ]fwetx=%
\fwmacroname{Scan definable symbol}{676}\fwbtx[
   ScanOptionalEquals();
   Filename fn;
   ]fwetx=%
\fwmacroname{Scan filename}{318}\fwbtx[
   if (ScanKeyword(Keywords::KW_SCALED)){
      int n;
      ScanInt(&n);
   } else if (ScanKeyword(Keywords::KW_AT)){
      int dim;
      ScanDim(false, false, false, &dim);
   }
   Primitive* cmd = new Primitive(CMD_FONT_SWITCH, false, 0);
   Symbols::SetDef(defining.Symbol(), cmd, false);
   LOG("\n----Set " << defining <<
      " = a font (todo: should this check global setting?)");
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 469, 470, 473, 476, 479 and 482.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Font commands}{470}\fwplusequals \fwodef \fwbtx[case CMD_FONT_SWITCH : {
   LOG("----switch to font " << CurTok());
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 469, 470, 473, 476, 479 and 482.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{471}\fwplusequals \fwodef \fwbtx[CMD_SET_SKEWCHAR,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{472}\fwplusequals \fwodef \fwbtx[NewPrimitive("skewchar", CMD_SET_SKEWCHAR);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Font commands}{473}\fwplusequals \fwodef \fwbtx[case CMD_SET_SKEWCHAR:{
   GetRawToken();
   TeXToken font = CurTok();
   ScanOptionalEquals();
   int n;
   ScanInt(&n);
   LOG("\nSet skewchar of " << font << " = " << n);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 469, 470, 473, 476, 479 and 482.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{474}\fwplusequals \fwodef \fwbtx[CMD_SET_TEXTFONT,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{475}\fwplusequals \fwodef \fwbtx[NewPrimitive("textfont", CMD_SET_TEXTFONT);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Font commands}{476}\fwplusequals \fwodef \fwbtx[case CMD_SET_TEXTFONT:{
   int n;
   ScanInt(&n);
   ScanOptionalEquals();
   GetRawToken();
   TeXToken font = CurTok();
   LOG("\nSet textfont of " << n << " = " << font);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 469, 470, 473, 476, 479 and 482.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{477}\fwplusequals \fwodef \fwbtx[CMD_SET_SCRIPTFONT,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{478}\fwplusequals \fwodef \fwbtx[NewPrimitive("scriptfont", CMD_SET_SCRIPTFONT);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Font commands}{479}\fwplusequals \fwodef \fwbtx[case CMD_SET_SCRIPTFONT:{
   int n;
   ScanInt(&n);
   ScanOptionalEquals();
   GetRawToken();
   TeXToken font = CurTok();
   LOG("\nSet scriptfont of " << n << " = " << font);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 469, 470, 473, 476, 479 and 482.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{480}\fwplusequals \fwodef \fwbtx[CMD_SET_SCRIPTSCRIPTFONT,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{481}\fwplusequals \fwodef \fwbtx[NewPrimitive("scriptscriptfont", CMD_SET_SCRIPTFONT);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Font commands}{482}\fwplusequals \fwodef \fwbtx[case CMD_SET_SCRIPTSCRIPTFONT:{
   int n;
   ScanInt(&n);
   ScanOptionalEquals();
   GetRawToken();
   TeXToken font = CurTok();
   LOG("\nSet scriptscriptfont of " << n << " = " << font);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 469, 470, 473, 476, 479 and 482.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwsecb{12.10}{$\backslash$begingroup and $\backslash$endgroup}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{483}\fwplusequals \fwodef \fwbtx[CMD_BEGINGROUP,
CMD_ENDGROUP,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{484}\fwplusequals \fwodef \fwbtx[NewPrimitive("begingroup", CMD_BEGINGROUP);
NewPrimitive("endgroup", CMD_ENDGROUP);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Grouping commands}{485}\fwplusequals \fwodef \fwbtx[case CMD_BEGINGROUP:{
   NewLevel(SEMISIMPLE_GROUP);
   LOG("\n----\\begingroup");
   break;
}

case CMD_ENDGROUP:{
   EndLevel();
   LOG("\n----\\endgroup");
   break;
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 445, 446 and 485.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro






\cmd{relax}

See TTP 1045.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{486}\fwplusequals \fwodef \fwbtx[CMD_RELAX,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro




\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{487}\fwplusequals \fwodef \fwbtx[NewPrimitive("relax", CMD_RELAX);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{488}\fwplusequals \fwodef \fwbtx[case CMD_RELAX: {
   LOG("\n----\\relax");
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro




\fwsecb{12.11}{$\backslash$ignorespaces}
\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{489}\fwplusequals \fwodef \fwbtx[CMD_IGNORESPACES,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Create symbols}{490}\fwplusequals \fwodef \fwbtx[NewPrimitive("ignorespaces", CMD_IGNORESPACES);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{491}\fwplusequals \fwodef \fwbtx[case CMD_IGNORESPACES: {
   GetNext_NonBlank_NonCall();
   InputStack::Putback(CurTok());
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwsecb{12.12}{$\backslash$aftergroup and $\backslash$afterassignment}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{492}\fwplusequals \fwodef \fwbtx[CMD_AFTERGROUP,
CMD_AFTERASSIGNMENT,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Create symbols}{493}\fwplusequals \fwodef \fwbtx[NewPrimitive("aftergroup", CMD_AFTERGROUP);
NewPrimitive("afterassignment", CMD_AFTERASSIGNMENT);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Misc commands}{494}\fwplusequals \fwodef \fwbtx[case CMD_AFTERGROUP: {
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Misc commands}{495}\fwplusequals \fwodef \fwbtx[case CMD_AFTERASSIGNMENT: {
   GetRawToken();
   s_afterAssignment = CurTok();
   LOG("\n----afterassignment insert " << CurTok());
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Assignments}{496}\fwplusequals \fwodef \fwbtx[case CMD_AFTERGROUP:{
   ASSERT(s_groupStackTop >= 0);
   TokenList* afterGroup = s_groupStack[s_groupStackTop].m_afterGroup;
   if (afterGroup == 0){
      afterGroup = new TokenList;
      s_groupStack[s_groupStackTop].m_afterGroup = afterGroup;
   }
   GetRawToken();
   afterGroup -> push_back(CurTok());
   LOG("\n----aftergroup insert " << CurTok());
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro




\fwsecb{12.13}{Physical layout}

\fwbeginmacro
\fwfilename{interpretter.h}{497}\fwequals \fwodef \fwbtx[#ifndef INTERPRETTER_H
#define INTERPRETTER_H
]fwetx=%
\fwmacroname{class Interpretter}{378}\fwbtx[
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{interpretter.cpp}{498}\fwequals \fwodef \fwbtx[#include "interpretter.h"
#include "symbols.h"
#include "restore.h"
#include "typesetter.h"
#include "scanutils.h"
#include "expandables.h"
#include "macros.h"
#include "scanutils.h"
#include <string>
#include <list>
#include <iostream>


static InputStack inp;
static TeXToken s_illegal(TT_PARAM, 11, 0); // an illegal token
static TeXToken s_afterAssignment(s_illegal);
Typesetter ts;
SymbolData* frozen_relax;

]fwetx=%
\fwmacroname{GroupStack}{384}\fwbtx[
]fwetx=%
\fwmacroname{TagStack}{432}\fwbtx[
]fwetx=%
\fwmacroname{Interpretter forward declarations}{348}\fwbtx[
]fwetx=%
\fwmacroname{Functions for inserting primitive hooks}{381}\fwbtx[
]fwetx=%
\fwmacroname{Some box scanning}{610}\fwbtx[
]fwetx=%
\fwmacroname{ScanMath}{751}\fwbtx[
]fwetx=%
\fwmacroname{Alignment implementation}{754}\fwbtx[
]fwetx=%
\fwmacroname{Declare MakeIntegerParameter}{517}\fwbtx[
]fwetx=%
\fwmacroname{Declare MakeDimenParam}{535}\fwbtx[
]fwetx=%
\fwmacroname{Declare MakeGlueParam}{555}\fwbtx[
]fwetx=%
\fwmacroname{Declare MakeToksParameter}{573}\fwbtx[
]fwetx=%
\fwmacroname{Declare interpretter global variables}{380}\fwbtx[
]fwetx=%
\fwmacroname{InitializeSymbolTable}{379}\fwbtx[

]fwetx=%
\fwmacroname{DoAssignments}{500}\fwbtx[
]fwetx=%
\fwmacroname{DoPrefixedCommand}{505}\fwbtx[
]fwetx=%
\fwmacroname{Main Loop}{382}\fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwfilename{interprt.t.cpp}{499}\fwequals \fwodef \fwbtx[#include <string>
#include "platform.h"
#include "textio.h"
#include "tokens.h"
#include "symbols.h"
#include "scanutils.h"
#include "interpretter.h"

]fwetx=%
\fwmacroname{CompareLog utility}{17}\fwbtx[
]fwetx=%
\fwmacroname{Input file utility}{630}\fwbtx[

]fwetx=%
\fwmacroname{Test jig}{8}\fwoparen \fwoquote\fwmacroname{Interprt tests}{532}\fwcquote\fwcomma \fwoquote\fwmacroname{Interprt TestTable}{531}\fwcquote\fwcparen \fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro




\fwseca{13}{Assignment commands}


In this section we'll cover the prefix and assignment commands
except for macro definitions (see section ...).

The assignment action is triggered either by a token representing
an assignment command (\fwlit{\char`\\def}, \fwlit{\char`\\advance}, \fwlit{\char`\\deadcycles}, etc)
or by a prefix (\fwlit{\char`\\global}, \fwlit{\char`\\long}, \fwlit{\char`\\outer}). In the latter
case we see if there are more prefixes and process them.

All assignments get routed to the \fwlit{DoAssignment} function
which handles the common work before and after an assignment.

\fwbeginmacro
\fwmacroname{DoAssignments}{500}\fwequals \fwodef \fwbtx[void DoAssignment(int prefixes)
{
   bool bGlobal = (bool) (prefixes & PREFIX_GLOBAL);
   bool bLong   = (bool) (prefixes & PREFIX_LONG);
   bool bOuter  = (bool) (prefixes & PREFIX_OUTER);

   if (Global::globaldefs != 0){
      bGlobal = Global::globaldefs > 0;
   }
   if (bGlobal) LOG(" global ");
   if (bLong)   LOG(" long");
   if (bOuter)  LOG(" outer");

   switch (CurCmdCode()){
      ]fwetx=%
\fwmacroname{Assignments}{460}\fwbtx[
      default:
         ASSERT(false); // can't use prefix ...
   }
   // insert the afterassignment token
   if (s_afterAssignment !=  s_illegal){
      InputStack::Putback(s_afterAssignment);
      s_afterAssignment = s_illegal;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwsecb{13.1}{Prefixes}

Assignments, including \fwlit{\char`\\def}, can be prefixed by things
like \fwlit{\char`\\global}, \fwlit{\char`\\long}, and \fwlit{\char`\\outer}.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{501}\fwplusequals \fwodef \fwbtx[CMD_PREFIX,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Command subcodes}{502}\fwplusequals \fwodef \fwbtx[enum PrefixType{PREFIX_LONG = 1, PREFIX_OUTER = 2, PREFIX_GLOBAL = 4};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 464, 502, 507, 512, 569 and 756.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{503}\fwplusequals \fwodef \fwbtx[NewPrimitive("long", CMD_PREFIX, false, PREFIX_LONG);
NewPrimitive("outer", CMD_PREFIX, false, PREFIX_OUTER);
NewPrimitive("global", CMD_PREFIX, false, PREFIX_GLOBAL);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Prefix commands}{504}\fwplusequals \fwodef \fwbtx[case CMD_PREFIX:{
   DoPrefixedCommand();
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 504.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{DoPrefixedCommand}{505}\fwequals \fwodef \fwbtx[void DoPrefixedCommand()
{
   int prefixes = 0;
   while (CurCmdCode() == CMD_PREFIX){
       Primitive* prim = dynamic_cast<Primitive*>(CurData());
       prefixes |= prim -> Data();
       GetNext_NonBlank_NonRelax_NonCall();
   }
   DoAssignment(prefixes);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwsecb{13.2}{Shorthand definitions}


For example, the \fwlit{\char`\\chardef} command creates a mapping between a
control sequence and a character code. E.g. \fwlit{\char`\\chardef\char`\\foo=`\char`\\\%}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{506}\fwplusequals \fwodef \fwbtx[CMD_SHORTHANDDEF,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Command subcodes}{507}\fwplusequals \fwodef \fwbtx[enum ShorthandType{CHARDEF, MATHCHARDEF,
                   SKIPDEF, MUSKIPDEF, TOKSDEF};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 464, 502, 507, 512, 569 and 756.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{508}\fwplusequals \fwodef \fwbtx[NewPrimitive("chardef", CMD_SHORTHANDDEF, false, CHARDEF);
NewPrimitive("mathchardef", CMD_SHORTHANDDEF, false, MATHCHARDEF);
NewPrimitive("muskipdef", CMD_SHORTHANDDEF, false, MUSKIPDEF);
//NewPrimitive("toksdef", CMD_SHORTHANDDEF, false, TOKSDEF);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Basic assignment commands}{509}\fwplusequals \fwodef \fwbtx[case CMD_SHORTHANDDEF: {
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{510}\fwplusequals \fwodef \fwbtx[case CMD_SHORTHANDDEF: {
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   ShorthandType subtype = (ShorthandType) prim -> Data();
   TeXToken defining;
   int n;

   ScanShorthand(&defining, &n);
   if (subtype == CHARDEF){
      Primitive* cmd =
         new Primitive(CMD_CHAR_GIVEN, true, n);
      Symbols::SetDef(defining.Symbol(), cmd, false /*non-global*/);
      LOG("\n----Set " << defining << " = shorthand for char " << n);
   } else if (subtype == MATHCHARDEF){
      Primitive* cmd =
         new Primitive(CMD_MATH_GIVEN, true, n);
      Symbols::SetDef(defining.Symbol(), cmd, false /*non-global*/);
      LOG("\n----Set " << defining << " = shorthand for mathchar " << n);
   } else {
      ASSERT(false);
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro




\fwsecb{13.3}{Assign catcodes, uccodes, etc}

\fwbeginmacro
\fwmacroname{Command Codes}{511}\fwplusequals \fwodef \fwbtx[CMD_DEFCODE,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Command subcodes}{512}\fwplusequals \fwodef \fwbtx[enum DefCode{CATCODE, MATHCODE, LCCODE, UCCODE, SFCODE, DELCODE};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 464, 502, 507, 512, 569 and 756.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{513}\fwplusequals \fwodef \fwbtx[NewPrimitive("catcode", CMD_DEFCODE, true, (int)CATCODE);
NewPrimitive("mathcode",CMD_DEFCODE, true, (int)MATHCODE);
NewPrimitive("lccode",  CMD_DEFCODE, true, (int)LCCODE);
NewPrimitive("uccode",  CMD_DEFCODE, true, (int)UCCODE);
NewPrimitive("sfcode",  CMD_DEFCODE, true, (int)SFCODE);
NewPrimitive("delcode", CMD_DEFCODE, true, (int)DELCODE);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Basic assignment commands}{514}\fwplusequals \fwodef \fwbtx[case CMD_DEFCODE:{
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{515}\fwplusequals \fwodef \fwbtx[case CMD_DEFCODE: {
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   DefCode subtype = (DefCode) prim -> Data();
   int n;
   int m;
   ScanInt(&n);
   ScanOptionalEquals();
   ScanInt(&m);
   TeXChar ch = n;
   if (subtype == CATCODE){
      LOG("\n----Set catcode[" << ch << "] = " << m);
      SaveRestoration(
         new IntRestoration(CatcodeLoc(ch), "a catcode"), bGlobal);
      SetCatcode(n, m);
   } else if (subtype == MATHCODE){
      LOG("\n----Set mathcode[" << ch << "] = " << m);
      SaveRestoration(
         new IntRestoration(MathcodeLoc(ch), "a mathcode"), bGlobal);
      SetMathcode(n, m);
   } else if (subtype == LCCODE){
      LOG("\n----Set lccode[" << ch << "] = " << m);
      SaveRestoration(
         new IntRestoration(LccodeLoc(ch), "an lccode"), bGlobal);
      SetLccode(n, m);
   } else if (subtype == UCCODE){
      SaveRestoration(
         new IntRestoration(UccodeLoc(ch), "a uccode"), bGlobal);
      SetUccode(n, m);
      LOG("\n----Set uccode[" << ch << "] = " << m);
   } else if (subtype == SFCODE){
      LOG("\n----Set sfcode[" << ch << "] = " << m);
   } else if (subtype == DELCODE){
      LOG("\n----Set delcode[" << ch << "] = " << m);
   }
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro




\fwsecb{13.4}{Integer parameter assignments}

The integer parameters are things like \fwlit{\char`\\tolerance}.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{516}\fwplusequals \fwodef \fwbtx[CMD_ASSIGN_INTEGER,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



Each integer parameter is associated with a memory location that
holds an integer.

\fwbeginmacro
\fwmacroname{Declare MakeIntegerParameter}{517}\fwequals \fwodef \fwbtx[void MakeIntegerParameter(const char* name, int* addr)
{
   Primitive* pc = new Primitive(CMD_ASSIGN_INTEGER, true, (int)addr);
   Symbols::CreateSymbol(name, pc);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{518}\fwplusequals \fwodef \fwbtx[MakeIntegerParameter("pretolerance",   &Global::pretolerance);
MakeIntegerParameter("tolerance",      &Global::tolerance);
MakeIntegerParameter("hbadness",       &Global::hbadness);
MakeIntegerParameter("vbadness",       &Global::vbadness);
MakeIntegerParameter("linepenalty",    &Global::linepenalty);
MakeIntegerParameter("hyphenpenalty",  &Global::hyphenpenalty);
MakeIntegerParameter("exhyphenpenalty",&Global::exhyphenpenalty);
MakeIntegerParameter("binoppenalty",   &Global::binoppenalty);
MakeIntegerParameter("relpenalty",     &Global::relpenalty);
MakeIntegerParameter("clubpenalty",    &Global::clubpenalty);
MakeIntegerParameter("widowpenalty",   &Global::widowpenalty);
MakeIntegerParameter("displaywidowpenalty", &Global::displaywidowpenalty);
MakeIntegerParameter("brokenpenalty",       &Global::brokenpenalty);
MakeIntegerParameter("predisplaypenalty",   &Global::predisplaypenalty);
MakeIntegerParameter("postdisplaypenalty",  &Global::postdisplaypenalty);
MakeIntegerParameter("interlinepenalty",    &Global::interlinepenalty);
MakeIntegerParameter("floatingpenalty",     &Global::floatingpenalty);
MakeIntegerParameter("outputpenalty",       &Global::outputpenalty);
MakeIntegerParameter("doublehyphendemerits",&Global::doublehyphendemerits);
MakeIntegerParameter("finalhyphendemerits", &Global::finalhyphendemerits);
MakeIntegerParameter("adjdemerits",         &Global::adjdemerits);
MakeIntegerParameter("looseness",           &Global::looseness);
MakeIntegerParameter("pausing",             &Global::pausing);
MakeIntegerParameter("holdinginserts",      &Global::holdinginserts);
MakeIntegerParameter("tracingonline",      &Global::tracingonline);
MakeIntegerParameter("tracingmacros",      &Global::tracingmacros);
MakeIntegerParameter("tracingstats",       &Global::tracingstats);
MakeIntegerParameter("tracingparagraphs",  &Global::tracingparagraphs);
MakeIntegerParameter("tracingpages",       &Global::tracingpages);
MakeIntegerParameter("tracingoutput",      &Global::tracingoutput);
MakeIntegerParameter("tracinglostchars",   &Global::tracinglostchars);
MakeIntegerParameter("tracingcommands",    &Global::tracingcommands);
MakeIntegerParameter("tracingrestores",    &Global::tracingrestores);
MakeIntegerParameter("language",          &Global::language);
MakeIntegerParameter("uchyph",            &Global::uchyph);
MakeIntegerParameter("lefthyphenmin",     &Global::lefthyphenmin);
MakeIntegerParameter("righthyphenmin",    &Global::righthyphenmin);
MakeIntegerParameter("globaldefs",        &Global::globaldefs);
MakeIntegerParameter("defaulthyphenchar", &Global::defaulthyphenchar);
MakeIntegerParameter("defaultskewchar",   &Global::defaultskewchar);
MakeIntegerParameter("escapechar",        &Global::escapechar);
MakeIntegerParameter("endlinechar",       &Global::endlinechar);
MakeIntegerParameter("newlinechar",       &Global::newlinechar);
MakeIntegerParameter("showboxbreadth",    &Global::showboxbreadth);
MakeIntegerParameter("showboxdepth",      &Global::showboxdepth);
MakeIntegerParameter("errorcontextlines", &Global::errorcontextlines);
MakeIntegerParameter("delimiterfactor",   &Global::delimiterfactor);
MakeIntegerParameter("fam",               &Global::fam);
MakeIntegerParameter("maxdeadcycles",     &Global::maxdeadcycles);
MakeIntegerParameter("hangafter",         &Global::hangafter);
MakeIntegerParameter("mag",               &Global::mag);
MakeIntegerParameter("time",              &Global::time);
MakeIntegerParameter("day",               &Global::day);
MakeIntegerParameter("month",             &Global::month);
MakeIntegerParameter("year",              &Global::year);
MakeIntegerParameter("inputlineno",       &Global::inputlineno);
MakeIntegerParameter("lastpenalty",       &Global::lastpenalty);
MakeIntegerParameter("deadcycles",        &Global::deadcycles);
MakeIntegerParameter("spacefactor",       &Global::spacefactor);
MakeIntegerParameter("msi@dobraces",     &Global::msidobraces);
MakeIntegerParameter("msi@dollar",       &Global::msidollar);
MakeIntegerParameter("msi@output",       &Global::msioutput);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Basic assignment commands}{519}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_INTEGER:{
   DoAssignment(0);
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{520}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_INTEGER: {
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   int* loc = (int*) prim -> Data();
   TeXToken defining = CurTok();
   int n;
   ScanOptionalEquals();
   ScanInt(&n);
   LOG("\n----Set " << defining << " = " << n);
   SaveRestoration(new IntRestoration(loc, "an integer"), bGlobal);
   *loc = n;
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro


These commands can also appear while doing \fwlit{ScanSomethingInternal}.

\fwbeginmacro
\fwmacroname{ScanSomethingInternal cases}{521}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_INTEGER: {
   res.m_type = SCAN_INT;
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   res.m_int = * (int*) prim -> Data();
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 521, 526, 539, 548, 553, 559, 577, 582 and 607.}
\fwusedin{This macro is invoked in definition 301.}
\fwendmacronotes
\fwendmacro



\fwsecb{13.5}{Integer register assignments}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{522}\fwplusequals \fwodef \fwbtx[CMD_COUNT,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{523}\fwplusequals \fwodef \fwbtx[NewPrimitive("count", CMD_COUNT, true, NULL);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


There are two main ways the \fwlit{\char`\\count} command can have
significance. First, it can be the beginning of a top-level
command, e.g. \fwlit{\char`\\count5=12}, and second, it can be the
start of an integer parameter, e.g. \fwlit{\char`\\tolerance=\char`\\count4}.
Recursion is allowed so we can have things like
\fwlit{\char`\\count\char`\\count3=10} and \fwlit{\char`\\tolerance=\char`\\count\char`\\count4}.

Here is the first case.

\fwbeginmacro
\fwmacroname{Basic assignment commands}{524}\fwplusequals \fwodef \fwbtx[case CMD_COUNT: {
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{525}\fwplusequals \fwodef \fwbtx[case CMD_COUNT: {
   int n,m;
   ScanInt(&n);
   ScanOptionalEquals();
   ScanInt(&m);
   int* loc = &Global::CountReg[n];
   SaveRestoration(
            new IntRestoration(loc, "an integer register"),
            false
          );
   *loc = m;
   LOG("\n----Set \\count" << n << " = " << m);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro


And here is the second case

\fwbeginmacro
\fwmacroname{ScanSomethingInternal cases}{526}\fwplusequals \fwodef \fwbtx[case CMD_COUNT: {
   int m;
   if (ScanInt(&m)){
      res.m_type = SCAN_INT;
      res.m_int =  Global::CountReg[m];
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 521, 526, 539, 548, 553, 559, 577, 582 and 607.}
\fwusedin{This macro is invoked in definition 301.}
\fwendmacronotes
\fwendmacro


\fwsecb{13.6}{Counter shorthand commands}
There is another kind of integer assignment. The \fwlit{\char`\\countdef}
command associates a command like \fwlit{\char`\\count12} with a control
sequence.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{527}\fwplusequals \fwodef \fwbtx[CMD_COUNTDEF,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{528}\fwplusequals \fwodef \fwbtx[NewPrimitive("countdef", CMD_COUNTDEF);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Basic assignment commands}{529}\fwplusequals \fwodef \fwbtx[case CMD_COUNTDEF:{
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{530}\fwplusequals \fwodef \fwbtx[case CMD_COUNTDEF:{
   TeXToken defining;
   int n;
   ScanShorthand(&defining, &n);
   void* addr = &Global::CountReg[n];
   Primitive* cmd = new Primitive(CMD_ASSIGN_INTEGER, true, (int)addr);
   Symbols::SetDef(defining.Symbol(), cmd, bGlobal);
   LOG("\n----Set " << defining << " = shorthand for \\count" << n);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro






\fwsecb{13.7}{Tests}

\fwbeginmacro
\fwmacroname{Interprt TestTable}{531}\fwplusequals \fwodef \fwbtx[{"int", TestIntCmds},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 531, 587 and 679.}
\fwusedin{This macro is invoked in definition 499.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Interprt tests}{532}\fwplusequals \fwodef \fwbtx[bool TestIntCmds()
{
   Interpretter::InitializeSymbolTable();
   InitializeKeywords();
   InputFile("intassign.tex");
   Interpretter::MainLoop();
   return CompareLog("intassign.log", "Interpretter int test 1");
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 532, 588 and 680.}
\fwusedin{This macro is invoked in definition 499.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{intassign.tex}{533}\fwequals \fwodef \fwbtx[\count12=22
\count10=\count12 % now \count10=22
{\count10=33 % now \count10=33
}
\count12=\count10 % should be back to 22
\countdef\chapno=28
\chapno=16
\count12\chapno
\end
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro




\fwsecb{13.8}{Dimension parameter assignment}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{534}\fwplusequals \fwodef \fwbtx[CMD_ASSIGN_DIM,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



Each dimension parameter is associated with a memory location that
holds a dimension.

\fwbeginmacro
\fwmacroname{Declare MakeDimenParam}{535}\fwequals \fwodef \fwbtx[void MakeDimParam(const char* name, Scaled* addr)
{
   Primitive* pc = new Primitive(CMD_ASSIGN_DIM, true, (int)addr);
   Symbols::CreateSymbol(name, pc);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{536}\fwplusequals \fwodef \fwbtx[MakeDimParam("hfuzz",              &Global::hfuzz);
MakeDimParam("vfuzz",              &Global::vfuzz);
MakeDimParam("boxmaxdepth",        &Global::boxmaxdepth);
MakeDimParam("splitmaxdepth",      &Global::splitmaxdepth);
MakeDimParam("delimitershortfall", &Global::delimitershortfall);
MakeDimParam("nulldelimiterspace", &Global::nulldelimiterspace);
MakeDimParam("scriptspace",        &Global::scriptspace);
MakeDimParam("parindent",          &Global::parindent);
MakeDimParam("overfullrule",       &Global::overfullrule);
MakeDimParam("emergencystretch",   &Global::emergencystretch);
MakeDimParam("hsize",              &Global::hsize);
MakeDimParam("vsize",              &Global::vsize);
MakeDimParam("maxdepth",           &Global::maxdepth);
MakeDimParam("lineskiplimit",      &Global::lineskiplimit);
MakeDimParam("mathsurround",       &Global::mathsurround);
MakeDimParam("predisplaysize",     &Global::predisplaysize);
MakeDimParam("displaywidth",       &Global::displaywidth);
MakeDimParam("displayindent",      &Global::displayindent);
MakeDimParam("hangindent",         &Global::hangindent);
MakeDimParam("hoffset",            &Global::hoffset);
MakeDimParam("voffset",            &Global::voffset);
MakeDimParam("lastkern",           &Global::lastkern);
MakeDimParam("prevdepth",          &Global::prevdepth);

MakeDimParam("pagegoal",           &Global::pagegoal);
MakeDimParam("pagetotal",          &Global::pagetotal);
MakeDimParam("pagestretch",        &Global::pagestretch);
MakeDimParam("pagefilstretch",     &Global::pagefilstretch);
MakeDimParam("pagefillstretch",    &Global::pagefillstretch);
MakeDimParam("pagefilllstretch",   &Global::pagefilllstretch);
MakeDimParam("pageshrink",         &Global::pageshrink);
MakeDimParam("pagedepth",          &Global::pagedepth);


]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Basic assignment commands}{537}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_DIM: {
   DoAssignment(0);
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{538}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_DIM:{
   TokenList* pList = new TokenList;
   pList -> push_back(CurTok());
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   int* loc = (int*) prim -> Data();
   TeXToken defining = CurTok();
   int n;
   ScanOptionalEquals(pList);
   ScanDim(false, false, false, &n, pList);
   LOG("\n----Set " << defining << " = "
                    << n << "  ((" << *pList << "))");
   SaveRestoration(new IntRestoration(loc, "a dimension"), bGlobal);
   *loc = n;
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{ScanSomethingInternal cases}{539}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_DIM:{
   res.m_type = SCAN_DIMEN;
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   res.m_int = * (int*) prim -> Data();
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 521, 526, 539, 548, 553, 559, 577, 582 and 607.}
\fwusedin{This macro is invoked in definition 301.}
\fwendmacronotes
\fwendmacro








\fwsecb{13.9}{Dimension register assignment}


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{540}\fwplusequals \fwodef \fwbtx[CMD_DIMEN,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{541}\fwplusequals \fwodef \fwbtx[NewPrimitive("dimen", CMD_DIMEN, true, NULL);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Basic assignment commands}{542}\fwplusequals \fwodef \fwbtx[case CMD_DIMEN: {
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Assignments}{543}\fwplusequals \fwodef \fwbtx[case CMD_DIMEN: {
   int n;
   int dim;
   ScanInt(&n);
   ScanOptionalEquals();
   ScanDim(false, false, false, &dim);
   LOG("\n----Set \\dimen" << n << " = " << dim);
   int* loc = &Global::DimenReg[n];
   SaveRestoration(new IntRestoration(loc, "a dimension"), bGlobal);
   *loc = n;
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro




\fwsecb{13.10}{Dimension shorthand}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{544}\fwplusequals \fwodef \fwbtx[CMD_DIMENDEF,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{545}\fwplusequals \fwodef \fwbtx[NewPrimitive("dimendef", CMD_DIMENDEF);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Basic assignment commands}{546}\fwplusequals \fwodef \fwbtx[case CMD_DIMENDEF:{
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{547}\fwplusequals \fwodef \fwbtx[case CMD_DIMENDEF:{
   TeXToken defining;
   int n;
   ScanShorthand(&defining, &n);
   void* addr = &Global::DimenReg[n];
   Primitive* cmd = new Primitive(CMD_ASSIGN_DIM, true, (int)addr);
   Symbols::SetDef(defining.Symbol(), cmd, false /*non-global*/);
   LOG("\n----Set " << defining << " = shorthand for \\dimen" << n);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{ScanSomethingInternal cases}{548}\fwplusequals \fwodef \fwbtx[case CMD_DIMEN: {
   int m;
   if (ScanInt(&m, pList)){
      res.m_type = SCAN_DIMEN;
      res.m_int =  Global::DimenReg[m];
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 521, 526, 539, 548, 553, 559, 577, 582 and 607.}
\fwusedin{This macro is invoked in definition 301.}
\fwendmacronotes
\fwendmacro



\fwsecb{13.11}{Font dimensions}


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{549}\fwplusequals \fwodef \fwbtx[CMD_ASSIGN_FONTDIMEN,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{550}\fwplusequals \fwodef \fwbtx[NewPrimitive("fontdimen", CMD_ASSIGN_FONTDIMEN);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Basic assignment commands}{551}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_FONTDIMEN: {
   DoAssignment(0);
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Assignments}{552}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_FONTDIMEN:{
   int n;
   ScanInt(&n);
   GetToken();
   // Should be a font identifier ...
   LOG("\nERROR -- unimplemented fontdimen");
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{ScanSomethingInternal cases}{553}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_FONTDIMEN:{
   int n;
   ScanInt(&n, pList);
   GetToken();
   // Should be a font identifier ...
   if (pList)
     pList -> push_back(CurTok());

   LOG("\nERROR -- unimplemented fontdimen");

   res.m_type = SCAN_DIMEN;
   //Primitive* prim = dynamic_cast<Primitive*>(CurData());
   //res.m_int = * (int*) prim -> Data();
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 521, 526, 539, 548, 553, 559, 577, 582 and 607.}
\fwusedin{This macro is invoked in definition 301.}
\fwendmacronotes
\fwendmacro









\fwsecb{13.12}{Glue parameter assignment}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{554}\fwplusequals \fwodef \fwbtx[CMD_ASSIGN_GLUE,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



Each glue parameter is associated with a memory location that
holds a glue.

\fwbeginmacro
\fwmacroname{Declare MakeGlueParam}{555}\fwequals \fwodef \fwbtx[void MakeGlueParam(const char* name, Glue* addr)
{
   Primitive* pc = new Primitive(CMD_ASSIGN_GLUE, true, (int)addr);
   Symbols::CreateSymbol(name, pc);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{556}\fwplusequals \fwodef \fwbtx[MakeGlueParam("baselineskip",          &Global::baselineskip);
MakeGlueParam("lineskip",              &Global::lineskip);
MakeGlueParam("parskip",               &Global::parskip);
MakeGlueParam("abovedisplayskip",      &Global::abovedisplayskip);
MakeGlueParam("belowdisplayskip",      &Global::belowdisplayskip);
MakeGlueParam("abovedisplayshortskip", &Global::abovedisplayshortskip);
MakeGlueParam("belowdisplayshortskip", &Global::belowdisplayshortskip);
MakeGlueParam("leftskip",              &Global::leftskip);
MakeGlueParam("rightskip",             &Global::rightskip);
MakeGlueParam("topskip",               &Global::topskip);
MakeGlueParam("splittopskip",          &Global::splittopskip);
MakeGlueParam("spaceskip",             &Global::spaceskip);
MakeGlueParam("xspaceskip",            &Global::xspaceskip);
MakeGlueParam("parfillskip",           &Global::parfillskip);
MakeGlueParam("thinmuskip",            &Global::thinmuskip);
MakeGlueParam("medmuskip",             &Global::medmuskip);
MakeGlueParam("thickmuskip",           &Global::thickmuskip);
MakeGlueParam("tabskip",               &Global::tabskip);
MakeGlueParam("lastskip",              &Global::lastskip);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Basic assignment commands}{557}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_GLUE: {
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{558}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_GLUE: {
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   int* loc = (int*) prim -> Data();
   TeXToken defining = CurTok();
   ScanOptionalEquals();
   ScanGlue();
   LOG("\n----Set " << defining << " = some glue todo: implement");

   //SaveRestoration(new GlueRestoration(loc, "a glue"), bGlobal);
   //*loc = n;
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro


These commands can also appear while doing \fwlit{ScanSomethingInternal}.

\fwbeginmacro
\fwmacroname{ScanSomethingInternal cases}{559}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_GLUE: {
   res.m_type = SCAN_GLUE;
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   res.m_int = * (int*) prim -> Data();
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 521, 526, 539, 548, 553, 559, 577, 582 and 607.}
\fwusedin{This macro is invoked in definition 301.}
\fwendmacronotes
\fwendmacro



\fwsecb{13.13}{Glue register assignment}


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{560}\fwplusequals \fwodef \fwbtx[CMD_SKIP,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{561}\fwplusequals \fwodef \fwbtx[NewPrimitive("skip", CMD_SKIP, true, NULL);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Basic assignment commands}{562}\fwplusequals \fwodef \fwbtx[case CMD_SKIP:{
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{563}\fwplusequals \fwodef \fwbtx[case CMD_SKIP: {
   int n;
   //int dim;
   ScanInt(&n);
   ScanOptionalEquals();
   ScanGlue();
   LOG("\\skip" << n << " = ... ");
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro



\fwsecb{13.14}{Skip shorthand}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{564}\fwplusequals \fwodef \fwbtx[CMD_SKIPDEF,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{565}\fwplusequals \fwodef \fwbtx[NewPrimitive("skipdef", CMD_SKIPDEF);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Basic assignment commands}{566}\fwplusequals \fwodef \fwbtx[case CMD_SKIPDEF:{
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{567}\fwplusequals \fwodef \fwbtx[case CMD_SKIPDEF:{
   TeXToken defining;
   int n;
   ScanShorthand(&defining, &n);
   void* addr = &Global::SkipReg[n];
   Primitive* cmd = new Primitive(CMD_ASSIGN_GLUE, true, (int)addr);
   Symbols::SetDef(defining.Symbol(), cmd, false /*non-global*/);
   LOG("\n----Set " << defining << " = shorthand for \\skip" << n);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro





\fwsecb{13.15}{Register assignment}
\fwbeginmacro
\fwmacroname{Command Codes}{568}\fwplusequals \fwodef \fwbtx[CMD_REGISTER,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Command subcodes}{569}\fwplusequals \fwodef \fwbtx[enum RegisterCode{DIMEN_REG, GLUE_REG, TOKS_REG};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 464, 502, 507, 512, 569 and 756.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{570}\fwplusequals \fwodef \fwbtx[NewPrimitive("skip", CMD_REGISTER, true, GLUE_REG);
NewPrimitive("toks", CMD_REGISTER, true, TOKS_REG);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Register commands}{571}\fwequals \fwodef \fwbtx[case CMD_REGISTER: {
   int n;
   int m;
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   int type = prim -> Data();
   ScanInt(&n);
   ScanOptionalEquals();
   if (type == GLUE_REG){
      ScanGlue();
      LOG("SET GLUE");
   } else if (type == TOKS_REG){
      TokenList* pTL = new TokenList;
      ScanTokenList(pTL, false);
      LOG("SET TOKS");
   } else {
      ASSERT(false);
   }
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro




\fwsecb{13.16}{Token list parameter assignment}

The token list parameters are things like \fwlit{\char`\\output}.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{572}\fwplusequals \fwodef \fwbtx[CMD_ASSIGN_TOKS,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


Each token list parameter is associated with a memory location that
holds a token list.

\fwbeginmacro
\fwmacroname{Declare MakeToksParameter}{573}\fwequals \fwodef \fwbtx[void MakeToksParameter(const char* name, TokenList* addr)
{
   Primitive* pc = new Primitive(CMD_ASSIGN_TOKS, true, (int)addr);
   Symbols::CreateSymbol(name, pc);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Create symbols}{574}\fwplusequals \fwodef \fwbtx[MakeToksParameter("output",              &Global::output);
MakeToksParameter("everypar",            &Global::everypar);
MakeToksParameter("everymath",           &Global::everymath);
MakeToksParameter("everydisplay",        &Global::everydisplay);
MakeToksParameter("everyhbox",           &Global::everyhbox);
MakeToksParameter("everyvbox",           &Global::everyvbox);
MakeToksParameter("everyjob",            &Global::everyjob);
MakeToksParameter("everycr",             &Global::everycr);
MakeToksParameter("errhelp",             &Global::errhelp);
MakeToksParameter("msi@everycellstart", &Global::msieverycellstart);
MakeToksParameter("msi@everycellend",   &Global::msieverycellend);
MakeToksParameter("msi@everyrowstart",  &Global::msieveryrowstart);
MakeToksParameter("msi@everyrowend",    &Global::msieveryrowend);

MakeToksParameter("msi@inline@proc",   &Global::msiinlinemathproc);
MakeToksParameter("msi@display@proc",  &Global::msidisplaymathproc);

MakeToksParameter("msi@everypar",       &Global::msieverypar);
MakeToksParameter("msi@everyhbox",      &Global::msieveryhbox);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Basic assignment commands}{575}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_TOKS:{
   DoAssignment(0);
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{576}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_TOKS: {
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   TokenList* loc = (TokenList*) prim -> Data();
   TeXToken defining = CurTok();
   TokenList* pTL = new TokenList;
   ScanOptionalEquals();
   ScanTokenList(pTL, false);
   LOG("\n----Set " << defining << " = " << *pTL);
   SaveRestoration(new ToksRestoration(loc, "a token list"), bGlobal);
   *loc = *pTL;
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro


These commands can also appear while doing \fwlit{ScanSomethingInternal}.

\fwbeginmacro
\fwmacroname{ScanSomethingInternal cases}{577}\fwplusequals \fwodef \fwbtx[case CMD_ASSIGN_TOKS: {
   res.m_type = SCAN_TOKS;
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   TokenList* loc = (TokenList*) prim -> Data();
   res.m_toks = loc;
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 521, 526, 539, 548, 553, 559, 577, 582 and 607.}
\fwusedin{This macro is invoked in definition 301.}
\fwendmacronotes
\fwendmacro



\fwsecb{13.17}{Token register assignment}


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{578}\fwplusequals \fwodef \fwbtx[CMD_TOKS,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Create symbols}{579}\fwplusequals \fwodef \fwbtx[NewPrimitive("toks", CMD_TOKS, true, NULL);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Basic assignment commands}{580}\fwplusequals \fwodef \fwbtx[case CMD_TOKS: {
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{581}\fwplusequals \fwodef \fwbtx[case CMD_TOKS: {
   int n;
   TokenList* pTL = new TokenList;
   ScanInt(&n);
   ScanOptionalEquals();
   ScanTokenList(pTL, false);
   TokenList* loc = &Global::ToksReg[n];
   // SaveRestoration(
   //          new IntRestoration(loc, "a token register"),
   //          false
   //        );
   *loc = *pTL;
   LOG("\n----Set \\toks" << n << " = " << *pTL);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro


And here is the second case

\fwbeginmacro
\fwmacroname{ScanSomethingInternal cases}{582}\fwplusequals \fwodef \fwbtx[case CMD_TOKS: {
   int m;
   if (ScanInt(&m)){
      res.m_type = SCAN_TOKS;
      res.m_toks =  &Global::ToksReg[m];
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 521, 526, 539, 548, 553, 559, 577, 582 and 607.}
\fwusedin{This macro is invoked in definition 301.}
\fwendmacronotes
\fwendmacro


\fwsecb{13.18}{Token register shorthand commands}
There is another kind of token list assignment. The \fwlit{\char`\\toksdef}
command associates a command like \fwlit{\char`\\toks12} with a control
sequence.

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{583}\fwplusequals \fwodef \fwbtx[CMD_TOKSDEF,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Create symbols}{584}\fwplusequals \fwodef \fwbtx[NewPrimitive("toksdef", CMD_TOKSDEF);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Basic assignment commands}{585}\fwplusequals \fwodef \fwbtx[case CMD_TOKSDEF:{
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{586}\fwplusequals \fwodef \fwbtx[case CMD_TOKSDEF:{
   TeXToken defining;
   int n;
   ScanShorthand(&defining, &n);
   void* addr = &Global::ToksReg[n];
   Primitive* cmd = new Primitive(CMD_ASSIGN_TOKS, true, (int)addr);
   Symbols::SetDef(defining.Symbol(), cmd, bGlobal);
   LOG(defining << " = shorthand for \\toks" << n);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro


\fwsecb{13.19}{Tests}

\fwbeginmacro
\fwmacroname{Interprt TestTable}{587}\fwplusequals \fwodef \fwbtx[{"toks", TestToksCmds},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 531, 587 and 679.}
\fwusedin{This macro is invoked in definition 499.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Interprt tests}{588}\fwplusequals \fwodef \fwbtx[bool TestToksCmds()
{
   Interpretter::InitializeSymbolTable();
   Interpretter::InitializeKeywords();
   InputFile("toksassign.tex");
   Interpretter::MainLoop();
   return CompareLog("toksassign.log", "Interpretter toks test 1");
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 532, 588 and 680.}
\fwusedin{This macro is invoked in definition 499.}
\fwendmacronotes
\fwendmacro



\fwsecb{13.20}{$\backslash$advance etc}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{589}\fwplusequals \fwodef \fwbtx[CMD_ADVANCE,
CMD_MULTIPLY,
CMD_DIVIDE,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Create symbols}{590}\fwplusequals \fwodef \fwbtx[NewPrimitive("advance", CMD_ADVANCE);
NewPrimitive("multiply", CMD_MULTIPLY);
NewPrimitive("divide", CMD_DIVIDE);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Basic assignment commands}{591}\fwplusequals \fwodef \fwbtx[case CMD_ADVANCE:
case CMD_MULTIPLY:
case CMD_DIVIDE:{
   DoAssignment(0);
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Assignments}{592}\fwplusequals \fwodef \fwbtx[case CMD_ADVANCE:
case CMD_MULTIPLY:
case CMD_DIVIDE: {
   CommandCode cc = CurCmdCode();
   GetToken();
   DetermineCommandCode();
   void* loc = 0;
   ScanType type;
   if (CurCmdCode() == CMD_ASSIGN_INTEGER){
      LOG("\n----" << CurTok());
      Primitive* prim = dynamic_cast<Primitive*>(CurData());
      loc = (void*) prim -> Data();
      type = SCAN_INT;
   } else if (CurCmdCode() == CMD_COUNT){
      int n;
      ScanInt(&n);
      LOG("\n----\\count" << n);
      loc = (void*) &Global::CountReg[n];
      type = SCAN_INT;
   } else if (CurCmdCode() == CMD_ASSIGN_DIM){
      LOG("\n----" << CurTok());
      Primitive* prim = dynamic_cast<Primitive*>(CurData());
      loc = (void*) prim -> Data();
      type = SCAN_DIMEN;
   } else if (CurCmdCode() == CMD_DIMEN){
      int n;
      ScanInt(&n);
      LOG("\n----\\dimen" << n);
      loc = (void*) &Global::DimenReg[n];
      type = SCAN_DIMEN;
   }  else if (CurCmdCode() == CMD_ASSIGN_GLUE){
      LOG("\n----" << CurTok());
      Primitive* prim = dynamic_cast<Primitive*>(CurData());
      loc = (void*) prim -> Data();
      type = SCAN_GLUE;
   } else if (CurCmdCode() == CMD_SKIP){
      int n;
      ScanInt(&n);
      LOG("\n----\\skip" << n);
      loc = (void*) &Global::SkipReg[n];
      type = SCAN_GLUE;
   } else {
      ASSERT(false);
   }
   if (ScanKeyword(Keywords::KW_BY)){
   }
   if (cc == CMD_ADVANCE){
      if (type == SCAN_INT){
         int a;
         ScanInt(&a);
         int* theint = (int*) loc;
         SaveRestoration(
            new IntRestoration(theint, "an integer"), bGlobal);
         LOG(" += " << a);
         *theint += a;
      } else if (type == SCAN_DIMEN){
         Scaled dim;
         ScanDim(false, false, false, &dim);
         LOG(dim);
         LOG("\n---(Unimplemented arithmetic with dimensions)");
      } else if (type == SCAN_GLUE){
         ScanGlue();
         LOG("\n---(Unimplemented arithmetic with glue)");
      }
   } else {
      int a;
      ScanInt(&a);
      int* theint = (int*) loc;
      SaveRestoration(
         new IntRestoration(theint, "an integer"), bGlobal);
      if (cc == CMD_DIVIDE){
         LOG(" /= " << a);
         *theint /= a;
      } else {
         LOG(" *= " << a);
         *theint *= a;
      }
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro




\fwsecb{13.21}{$\backslash$let etc.}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{593}\fwplusequals \fwodef \fwbtx[CMD_LET,
CMD_FUTURE_LET,
CMD_LET_TOK,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{594}\fwplusequals \fwodef \fwbtx[NewPrimitive("let", CMD_LET);
NewPrimitive("futurelet", CMD_FUTURE_LET);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Basic assignment commands}{595}\fwplusequals \fwodef \fwbtx[case CMD_LET:{
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{596}\fwplusequals \fwodef \fwbtx[case CMD_LET:{
   TeXToken defining;
   ]fwetx=%
\fwmacroname{Scan definable symbol}{676}\fwbtx[
   GetRawToken();
   if (CurTok() == TeXToken(TT_OTHER, '=', 0)){
      GetRawToken();
   }
   if (CurTok() == TeXToken(TT_SPACE, ' ', 0)){
      GetRawToken();
   }
   SymbolData* pDef;
   if (CurTok().Type() == TT_SYMBOL){
      LOG("\n----Set " << defining
                       << " = the defn of " << CurTok());
      Symbols::GetDef(CurTok().Symbol(), &pDef);
      void* pDefLoc;
      if (defining.Type() == TT_SYMBOL){
         Symbols::GetDefLoc(defining.Symbol(), &pDefLoc);
         DefRestoration* restore =
              new DefRestoration((SymbolData**)pDefLoc, "a def");
         SaveRestoration(restore, bGlobal);
         Symbols::SetDef(
                    defining.Symbol(),
                    pDef,
                    false /*non-global*/);
      } else if (defining.Type() == TT_ACTIVE){
         Symbols::GetActiveDefLoc(defining.ChrCode(), &pDefLoc);
         DefRestoration* restore =
              new DefRestoration((SymbolData**)pDefLoc, "a def");
         SaveRestoration(restore, bGlobal);
         Symbols::SetActiveDef(
                    defining.ChrCode(),
                    pDef,
                    false /*non-global*/);
      } else {
         ASSERT(false);
      }
   } else {
      LOG("\n----Set " << defining
                       << " = the defn of " << CurTok());
      TeXToken* pTok = new TeXToken(CurTok());
      pDef = new Primitive(CMD_LET_TOK, false, (int) pTok);
      LOG("\n----WARNING: fix memory leak here");
      void* pDefLoc;
      if (defining.Type() == TT_SYMBOL){
         Symbols::GetDefLoc(defining.Symbol(), &pDefLoc);
         DefRestoration* restore =
              new DefRestoration((SymbolData**)pDefLoc, "a def");
         SaveRestoration(restore, bGlobal);
         Symbols::SetDef(
                    defining.Symbol(),
                    pDef,
                    false /*non-global*/);
      } else if (defining.Type() == TT_ACTIVE){
         Symbols::GetActiveDefLoc(defining.ChrCode(), &pDefLoc);
         DefRestoration* restore =
              new DefRestoration((SymbolData**)pDefLoc, "a def");
         SaveRestoration(restore, bGlobal);
         Symbols::SetActiveDef(
                    defining.ChrCode(),
                    pDef,
                    false /*non-global*/);
      } else {
         ASSERT(false);
      }
   }


   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Basic assignment commands}{597}\fwplusequals \fwodef \fwbtx[case CMD_FUTURE_LET:{
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Assignments}{598}\fwplusequals \fwodef \fwbtx[case CMD_FUTURE_LET:{
   TeXToken defining;
   ]fwetx=%
\fwmacroname{Scan definable symbol}{676}\fwbtx[
   GetRawToken();
   TeXToken skipped = CurTok();
   GetRawToken();
   SymbolData* pDef;
   if (CurTok().Type() == TT_SYMBOL){
      LOG("\n----Set " << defining
                   << " = the defn of " << CurTok());
      Symbols::GetDef(CurTok().Symbol(), &pDef);
   } else {
      LOG("\n----Set " << defining
                       << " = the defn of " << CurTok());
      TeXToken* pTok = new TeXToken(CurTok());
      pDef = new Primitive(CMD_LET_TOK, false, (int) pTok);
      LOG("\n----WARNING: fix memory leak here");
   }

   void* pDefLoc;
   Symbols::GetDefLoc(defining.Symbol(), &pDefLoc);
   DefRestoration* restore =
        new DefRestoration((SymbolData**)pDefLoc, "a def");
   SaveRestoration(restore, bGlobal);

   Symbols::SetDef(
              defining.Symbol(),
              pDef,
              false /*non-global*/);
   InputStack::Putback(CurTok());
   InputStack::Putback(skipped);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro



\fwsecb{13.22}{Assign box register ($\backslash$setbox)}


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{599}\fwplusequals \fwodef \fwbtx[CMD_SETBOX,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{600}\fwplusequals \fwodef \fwbtx[NewPrimitive("setbox", CMD_SETBOX);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Basic assignment commands}{601}\fwplusequals \fwodef \fwbtx[case CMD_SETBOX: {
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 509, 514, 519, 524, 529, 537, 542, 546, 551, 557, 562, 566, 575, 580, 585, 591, 595, 597 and 601.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{602}\fwplusequals \fwodef \fwbtx[case CMD_SETBOX: {
   int m;
   ScanInt(&m);
   ScanOptionalEquals();
   ScanBox();
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro




\fwsecb{13.23}{Assign box dimensions ($\backslash$wd, $\backslash$ht, $\backslash$dp)}

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{603}\fwplusequals \fwodef \fwbtx[CMD_BOX_DIM,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{604}\fwplusequals \fwodef \fwbtx[NewPrimitive("wd", CMD_BOX_DIM, true, 1);
NewPrimitive("ht", CMD_BOX_DIM, true, 2);
NewPrimitive("dp", CMD_BOX_DIM, true, 3);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assign box dimension commands}{605}\fwplusequals \fwodef \fwbtx[case CMD_BOX_DIM:{
   DoAssignment(0);
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 605.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{606}\fwplusequals \fwodef \fwbtx[case CMD_BOX_DIM: {
   int n;
   ScanInt(&n);
   LOG("\nERROR -- todo: implement box dimension assignments");
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro



These commands can also appear while doing \fwlit{ScanSomethingInternal}.

\fwbeginmacro
\fwmacroname{ScanSomethingInternal cases}{607}\fwplusequals \fwodef \fwbtx[case CMD_BOX_DIM:
   int m;
   if (ScanInt(&m)){

   }
   LOG("\nERROR -- todo: implement box dimens in"
       "scan something internal");
   res.m_type = SCAN_DIMEN;
   res.m_int = 0;

   break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 521, 526, 539, 548, 553, 559, 577, 582 and 607.}
\fwusedin{This macro is invoked in definition 301.}
\fwendmacronotes
\fwendmacro










\fwseca{14}{Box commands}


\fwsecb{14.1}{Scan boxes}


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{608}\fwplusequals \fwodef \fwbtx[CMD_HBOX,
CMD_VBOX,
CMD_LASTBOX,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{609}\fwplusequals \fwodef \fwbtx[NewPrimitive("hbox", CMD_HBOX);
NewPrimitive("vbox", CMD_VBOX);
NewPrimitive("raise", CMD_RAISE);
NewPrimitive("lower", CMD_LOWER);
NewPrimitive("lastbox", CMD_LASTBOX);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Some box scanning}{610}\fwplusequals \fwodef \fwbtx[void ScanBoxSpec()
{
   Scaled dim;
   if (ScanKeyword(Keywords::KW_TO)){
      ScanDim(false, false, false, &dim);
   } else if (ScanKeyword(Keywords::KW_SPREAD)){
      ScanDim(false, false, false, &dim);
   }
   ScanLeftBrace();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 610 and 611.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Some box scanning}{611}\fwplusequals \fwodef \fwbtx[void ScanBox()
{
   GetToken();
   DetermineCommandCode();
   if (CurCmdCode() == CMD_VBOX){
      ScanBoxSpec();
      NewLevel(VBOX_GROUP);
      ts.StartBox();
      //ts.AppendTag("{");
      LOG("\nStart vbox");
   } else if (CurCmdCode() == CMD_HBOX){
      ScanBoxSpec();
      NewLevel(HBOX_GROUP);
      ts.StartBox();
      //ts.AppendTag("{");
      LOG("\nStart hbox");
   } else if (CurCmdCode() == CMD_LASTBOX){
      LOG("\nUnimplemented handling of \\lastbox assignment");
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 610 and 611.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Box building commands}{612}\fwplusequals \fwodef \fwbtx[case CMD_HBOX:
{
   ScanBoxSpec();
   NewLevel(HBOX_GROUP);
   SaveRestoration(
      new IntRestoration(&Global::msidollar, "msidollar"), false);
   Global::msidollar = '$';
   ts.StartBox();
   //ts.AppendTag("{");
   Typesetter::GotoHMode();
   Typesetter::SetInner(true);
   LOG("\nStart hbox");
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 612, 613, 614 and 615.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Box building commands}{613}\fwplusequals \fwodef \fwbtx[case CMD_VBOX:
{
   ScanBoxSpec();
   NewLevel(VBOX_GROUP);
   ts.StartBox();
   //ts.AppendTag("{");
   Typesetter::GotoVMode();
   Typesetter::SetInner(true);
   LOG("\nStart vbox");
   break;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 612, 613, 614 and 615.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Box building commands}{614}\fwplusequals \fwodef \fwbtx[case CMD_RAISE:
{
   Scaled dim;
   ScanDim(false, false, false, &dim);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 612, 613, 614 and 615.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Box building commands}{615}\fwplusequals \fwodef \fwbtx[case CMD_LOWER:
{
   Scaled dim;
   ScanDim(false, false, false, &dim);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 612, 613, 614 and 615.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{616}\fwplusequals \fwodef \fwbtx[CMD_UNHBOX,
CMD_UNHCOPY,
CMD_UNVBOX,
CMD_UNVCOPY,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{617}\fwplusequals \fwodef \fwbtx[NewPrimitive("unhbox",  CMD_UNHBOX);
NewPrimitive("unvbox",  CMD_UNVBOX);
NewPrimitive("unhcopy", CMD_UNHCOPY);
NewPrimitive("unvcopy", CMD_UNVCOPY);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Unboxing commands}{618}\fwplusequals \fwodef \fwbtx[case CMD_UNHBOX:{
   int m;
   ScanInt(&m);
   if (Typesetter::GetMode() == MODE_VERTICAL){
      Typesetter::GotoHMode();
      Typesetter::SetInner(true);
      inp.Putback(Global::msieverypar);
      inp.Putback(Global::everypar);
   }
   break;
}
case CMD_UNVBOX:{
}
case CMD_UNHCOPY:
case CMD_UNVCOPY:{
   int m;
   ScanInt(&m);
   ASSERT(false);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 618.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro




\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{619}\fwplusequals \fwodef \fwbtx[CMD_BOX,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{620}\fwplusequals \fwodef \fwbtx[NewPrimitive("box", CMD_BOX, true, NULL);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro
























\fwseca{15}{Commands to make macro definitions}


\fwsecb{15.1}{Macros}


When a symbol defined as a \fwlit{MacroDef} is encountered it must be
expanded. First any parameters are collected according to the tokens
before the \fwlit{TT\_END\_MATCH}. These are placed into a
\fwlit{MacroExpansion} \fwlit{TokenSource} which is placed into the
\fwlit{InputStack}.  The \fwlit{MacroExpansion} feeds the body and parameters.
There are two member variables: \fwlit{m\_list} which is a pointer to the
\fwlit{TokenList} found in the \fwlit{MacroDef} and an iterator that points
to the current location in the expansion.

It also has a pointer to its parameters. The parameters are saved on
a static stack.

It is a little difficult to tell whether a MacroExpansion is empty.
There may still be tokens in the list, e.g. \fwlit{\#1} and so you'd think
the token source is not empty. But \fwlit{\#1} refers to a parameter that
may be empty. In that case we'd like to say the \fwlit{MacroExpansion} is
empty. So I've implemented a one token lookahead to handle this
gracefully.

\fwbeginmacro
\fwmacroname{class MacroExpansion}{621}\fwequals \fwodef \fwbtx[class MacroExpansion : public TokenSource {
private:
   const TokenList*  m_pList;         // The body
   TokenList::const_iterator m_iter;  // The current position
   int m_nParamCount;   // number of parameters
   int m_paramStart;    // location of first param on s_paramStack:

public:
   MacroExpansion(const TokenList* ptr, TokenList::const_iterator);
   ~MacroExpansion();
   bool bEmpty() const;
   void GetToken(TeXToken*);

   void SetParam(TokenList* param);
   void NextPosition();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 681.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{The parameter stack}{622}\fwequals \fwodef \fwbtx[    std::vector<TokenList*> s_paramStack;
    int s_paramTop;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{MacroExpansion::MacroExpansion}{623}\fwequals \fwodef \fwbtx[MacroExpansion::MacroExpansion(
                   const TokenList* ptr,
                   TokenList::const_iterator bodystart
                )
  : m_pList(ptr),
    m_iter(bodystart),
    m_nParamCount(0)
{
   m_pList -> AddReference();
   m_paramStart = s_paramStack.size();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{MacroExpansion::\char`\~MacroExpansion}{624}\fwequals \fwodef \fwbtx[MacroExpansion::~MacroExpansion()
{
   m_pList -> RemoveReference();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{MacroExpansion::bEmpty}{625}\fwequals \fwodef \fwbtx[bool MacroExpansion::bEmpty() const
{
   return m_iter == m_pList -> end();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{MacroExpansion::SetParam}{626}\fwequals \fwodef \fwbtx[void MacroExpansion::SetParam(TokenList* param)
{
   ++m_nParamCount;
   s_paramStack.push_back(param);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{MacroExpansion::GetToken}{627}\fwequals \fwodef \fwbtx[void MacroExpansion::GetToken(TeXToken* tt)
{
   ASSERT(m_iter != m_pList -> end() && (*m_iter).Type() != TT_OUTPARAM);
   *tt = *m_iter++;
   NextPosition();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{MacroExpansion::NextPosition}{628}\fwequals \fwodef \fwbtx[void MacroExpansion::NextPosition()
{
   TokenList::const_iterator a = m_iter;
   TokenList::const_iterator b = m_iter;

   // Skip over output parameters.
   // Find the next "real" token

   while (b != m_pList -> end() && (*b).Type() == TT_OUTPARAM){
      ++b;
   }

   // Push (in reverse order) any parameters onto the input
   m_iter = b;
   while (b != a){
      --b;
      TokenList* param = s_paramStack[m_paramStart + (*b).ChrCode()];
      InputStack::Putback(*param);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro







\fwbeginmacro
\fwmacroname{Tokens generation utility}{629}\fwmany{}\fwequals \fwodef \fwbtx[   #define TOK_END_MATCH TeXToken(TT_END_MATCH, 0, 0)
   #define TOK_MATCH TeXToken(TT_MATCH, 0, 0)
   #define TOK_LET(c) TeXToken(TT_LETTER, c, 0)
   #define TOK_OTHER(c) TeXToken(TT_OTHER, c, 0)
   #define TOK_OUT TeXToken(TT_OUTPARAM, 0, 0)
   #define END_ARRAY  TeXToken(TT_OUTPARAM, 100, 0)

   TokenList* TokenArrayToList(TeXToken tokArray[])
   {
      int i = 0;
      TokenList* tl  = new TokenList;
      while (tokArray[i] != END_ARRAY) {
         tl -> push_back(tokArray[i]);
         ++i;
      }
      return tl;
   }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 685.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Input file utility}{630}\fwmany{}\fwequals \fwodef \fwbtx[void InputFile(const char* fname)
{
   Filename fn(fname);
   InputByteFile* pbf = new InputByteFile;
   pbf -> Open(fn);
   Latin_1_in*  platin1filt = new Latin_1_in(*pbf);
   LineSource* plineSource = new LineSource(*platin1filt);
   Tokenizer* ts = new Tokenizer(plineSource);
   InputStack::Push(ts);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 499 and 685.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Macrop TestTable}{631}\fwplusequals \fwodef \fwbtx[{"macexp", TestMacroExpansion},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 631, 652, 656 and 660.}
\fwusedin{This macro is invoked in definition 685.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Macrop tests}{632}\fwplusequals \fwodef \fwbtx[bool TestMacroExpansion()
{
   TeXToken macexp1[] = { TOK_LET('A'),
                          TOK_OUT,
                          TOK_OTHER('1'),
                          TOK_LET('B'),
                          TOK_OUT,
                          TOK_OTHER('2'),
                          END_ARRAY};

   TeXToken param1[] =  { TOK_LET('B'),
                          TOK_LET('B'),
                          TOK_LET('A'),
                          TOK_LET('A'),
                          END_ARRAY};

   TeXToken param2[] =  { END_ARRAY }; // an empty param


   TokenList* body = TokenArrayToList(macexp1);
   MacroExpansion* me = new MacroExpansion(body, body -> begin());
   me -> SetParam(TokenArrayToList(param1));
   me -> SetParam(TokenArrayToList(param2));

   me -> NextPosition();

   InputStack::Push(me);
   LogFile::Start();
   while (! InputStack::bEmpty()){
      GetToken();
      LOG(CurTok() << "\n");
   }
   return CompareLog("macexp.log", "InputStack.TestMacroExpansion");
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 632, 653, 657 and 661.}
\fwusedin{This macro is invoked in definition 685.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{macexp.log}{633}\fwequals \fwodef \fwbtx[(A   Letter)
(B   Letter)
(B   Letter)
(A   Letter)
(A   Letter)
(B   Letter)
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro





A \fwlit{MacroDef} is a form of \fwlit{Expandable} which is a kind of
\fwlit{SymbolData}. It contains a list of tokens that represent the
parameters to be matched and the body to be replaced.  These are
separated by a token of type \fwlit{TT\_END\_MATCH}.

\fwbeginmacro
\fwmacroname{struct Macro}{634}\fwequals \fwodef \fwbtx[struct MacroDef : public Expandable {
private:
   TokenList* m_pList;  // This is not a TokenListTokenSource
public:
   MacroDef(TokenList* ptr);
   MacroDef(const TokenList&);
   virtual ~MacroDef();

   bool Expand(TeXToken*, SymbolData** ) const;
   const TokenList& Toks() const;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 681.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{MacroDef::MacroDef}{635}\fwequals \fwodef \fwbtx[MacroDef::MacroDef(TokenList* ptr)
   : Expandable(0, 0),
     m_pList(ptr)
{
   m_pList -> AddReference();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{MacroDef::\char`\~MacroDef}{636}\fwequals \fwodef \fwbtx[MacroDef::~MacroDef()
{
   m_pList -> RemoveReference();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{MacroDef::Toks}{637}\fwequals \fwodef \fwbtx[const TokenList& MacroDef::Toks() const
{
   ASSERT(m_pList != 0);
   return *m_pList;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{The temporary parameter stack}{638}\fwequals \fwodef \fwbtx[   TokenList* s_pstack[10]; // at most 10 parameters
   int s_ptop;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{MacroDef::Expand imp}{639}\fwequals \fwodef \fwbtx[bool MacroDef::Expand(TeXToken*, SymbolData**) const
{
   TokenList::const_iterator r = m_pList -> begin();

   // match parameters
   if ((*r).Type() != TT_END_MATCH){
      ]fwetx=%
\fwmacroname{scan parameters}{640}\fwbtx[
   }

   ASSERT((*r).Type() == TT_END_MATCH);
   ++r;

   // Create a MacroExpansion
   MacroExpansion* me = new MacroExpansion(m_pList, r);

   // Copy parameters from the temp stack to the parameter stack
   LOG("\n--Parameters");
   for (int i = 0; i < s_ptop; ++i){
      // need code here to tidy up: remove surrounding braces
      me -> SetParam(s_pstack[i]);
      LOG("\n--    #" << (i+1) << " " << *s_pstack[i]);
      s_pstack[i] = 0;
   }
   s_ptop = 0;

   LOG("\n--Pushing back " << *m_pList);
   // Feed macro expansion to input stack
   InputStack::Push(me);
   me -> NextPosition();
   InputStack::Clean();

   return false; // we don't set the next token.
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{scan parameters}{640}\fwequals \fwodef \fwbtx[if ]fwetx=%
\fwmacroname{r doesn't point to a TT\_MATCH or a TT\_END\_MATCH}{644}\fwbtx[ {
   ]fwetx=%
\fwmacroname{scan obligatory tokens}{645}\fwbtx[
}
while ]fwetx=%
\fwmacroname{r points to a TT\_MATCH}{641}\fwbtx[ {
   s_pstack[s_ptop] = new TokenList;
   ++s_ptop;
   ++r;
   if ]fwetx=%
\fwmacroname{r points to a TT\_MATCH or a TT\_END\_MATCH}{643}\fwbtx[ {
      ]fwetx=%
\fwmacroname{scan undelimited parameter}{646}\fwbtx[
   } else {
      ]fwetx=%
\fwmacroname{scan delimited parameter}{650}\fwbtx[
   }
   ASSERT(]fwetx=%
\fwmacroname{r points to a TT\_MATCH or a TT\_END\_MATCH}{643}\fwbtx[);
   ]fwetx=%
\fwmacroname{Tidy up parameter}{651}\fwbtx[
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 639.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{r points to a TT\_MATCH}{641}\fwmany{}\fwequals \fwodef \fwbtx[((*r).Type() == TT_MATCH)]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 640 and 643.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{r points to a TT\_END\_MATCH}{642}\fwmany{}\fwequals \fwodef \fwbtx[((*r).Type() == TT_END_MATCH)]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 643.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{r points to a TT\_MATCH or a TT\_END\_MATCH}{643}\fwmany{}\fwequals \fwodef \fwbtx[(]fwetx=%
\fwmacroname{r points to a TT\_MATCH}{641}\fwbtx[||
 ]fwetx=%
\fwmacroname{r points to a TT\_END\_MATCH}{642}\fwbtx[)]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 640, 640 and 644.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{r doesn't point to a TT\_MATCH or a TT\_END\_MATCH}{644}\fwmany{}\fwequals \fwodef \fwbtx[(!]fwetx=%
\fwmacroname{r points to a TT\_MATCH or a TT\_END\_MATCH}{643}\fwbtx[)]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 640, 645 and 650.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{scan obligatory tokens}{645}\fwequals \fwodef \fwbtx[while (]fwetx=%
\fwmacroname{r doesn't point to a TT\_MATCH or a TT\_END\_MATCH}{644}\fwbtx[){
   GetRawToken();
   if (*r == CurTok()){
      ++r;
   } else {
      LOG("\nERROR: unmatched obligatory token " << *r);
      LOG("\nI see " << CurTok());
      break;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 640.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{scan undelimited parameter}{646}\fwequals \fwodef \fwbtx[do{
  GetRawToken();
} while (CurTok().Type() == TT_SPACE);

if (CurTok().Type() == TT_LEFT_BRACE){
   ]fwetx=%
\fwmacroname{Contribute balanced token list}{648}\fwbtx[
} else {
   ]fwetx=%
\fwmacroname{Contribute current token to current parameter}{647}\fwbtx[
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 640.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Contribute current token to current parameter}{647}\fwequals \fwodef \fwbtx[s_pstack[s_ptop-1] -> push_back(CurTok());
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 646.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Contribute balanced token list}{648}\fwmany{}\fwequals \fwodef \fwbtx[int balance = 1;
s_pstack[s_ptop-1] -> push_back(CurTok());
while (balance > 0){
   GetRawToken();

   s_pstack[s_ptop-1] -> push_back(CurTok());
   if (CurTok().Type() == TT_LEFT_BRACE) {
      ++balance;
   } else if (CurTok().Type()==TT_RIGHT_BRACE){
      --balance;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 646 and 650.}
\fwendmacronotes
\fwendmacro


At this point \fwlit{r} points to a regular token that needs to be matched
by the input stream to delimit the parameter.

We let \fwlit{s =} the start of the delimiter to be matched, \fwlit{u =} the
beginning of the uncontributed recent input, and \fwlit{r =} the end of the
recently matched input.

For the \fwlit{INPUT} macro, the paramter \fwlit{x} is an iterator into a
TokenList of tokens that are supposed to delimit a macro parameter.



\fwbeginmacro
\fwmacroname{Some defines}{649}\fwplusequals \fwodef \fwbtx[#define INPUT(x) ( (x == r) ? CurTok() : *x )
#define CURRENT_PARAM (s_pstack[s_ptop-1])
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 649.}
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{scan delimited parameter}{650}\fwequals \fwodef \fwbtx[// s is the start of the pattern, r is the current position
TokenList::const_iterator s = r;
while ]fwetx=%
\fwmacroname{r doesn't point to a TT\_MATCH or a TT\_END\_MATCH}{644}\fwbtx[ {
   GetRawToken();
   if (*r == CurTok()){
      ++r;
   } else {
      if (CurTok().Type() == TT_LEFT_BRACE){
         ]fwetx=%
\fwmacroname{Contribute balanced token list}{648}\fwbtx[
      } else {
         // Contribute recent input tokens to the current parameter
         // until a partial match is restored.
         // Tokens have been matched from s to r-1. Current token
         // doesn't match r.
         TokenList::const_iterator u = s;
         TokenList::const_iterator t = s;
         TokenList::const_iterator v = s;
         // Contribute an input token
         CURRENT_PARAM -> push_back(INPUT(u));
         while (u != r) {
             ++u;
             // See if there's a partial match:
             //   s+0, s+1, ..., with u+0, u+1, ..., curTok
             bool pm = false;
             t = s; v = u;
             TokenList::const_iterator next = r;
             ++next;
             while (v != next) {
                if (INPUT(v) != *t){
                   break;
                } else
                   pm = true;
                ++v; ++t;
             }
             if (! pm ){
               CURRENT_PARAM -> push_back(INPUT(u));
             }
         }
         r = t;
      }
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 640.}
\fwendmacronotes
\fwendmacro



Now we want to remove surrounding braces if the parameter consists
of a single group.

\fwbeginmacro
\fwmacroname{Tidy up parameter}{651}\fwequals \fwodef \fwbtx[if ((CURRENT_PARAM -> size() > 1) && 
    (CURRENT_PARAM -> front().Type() == TT_LEFT_BRACE) &&
    (CURRENT_PARAM -> back().Type() == TT_RIGHT_BRACE)){
   CURRENT_PARAM -> pop_front();
   CURRENT_PARAM -> pop_back();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 640.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Macrop TestTable}{652}\fwplusequals \fwodef \fwbtx[{"noparams", TestNoParams},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 631, 652, 656 and 660.}
\fwusedin{This macro is invoked in definition 685.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Macrop tests}{653}\fwplusequals \fwodef \fwbtx[bool TestNoParams()
{
   TeXToken macdef[] =  { TOK_END_MATCH,
                          TOK_LET('B'),
                          TOK_LET('A'),
                          TOK_LET('B'),
                          END_ARRAY};

   MacroDef* pMacroDef = new MacroDef(TokenArrayToList(macdef));
   Symbols::CreateSymbol("mymac", pMacroDef);
   InputFile("noparams.tex");
   LogFile::Start();
   while (! InputStack::bEmpty()) {
      GetToken();
      LOG("\n" << CurTok());
   }
   return CompareLog("noparams.log", "InputStack.NoParams");
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 632, 653, 657 and 661.}
\fwusedin{This macro is invoked in definition 685.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{noparams.tex}{654}\fwequals \fwodef \fwbtx[XXX\mymac YYY
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{noparams.log}{655}\fwequals \fwodef \fwbtx[
(X   Letter)
(X   Letter)
(X   Letter)
(B   Letter)
(A   Letter)
(B   Letter)
(Y   Letter)
(Y   Letter)
(Y   Letter)
(    Space)]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{Macrop TestTable}{656}\fwplusequals \fwodef \fwbtx[{"undelim", TestUndelimitedParams},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 631, 652, 656 and 660.}
\fwusedin{This macro is invoked in definition 685.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Macrop tests}{657}\fwplusequals \fwodef \fwbtx[bool TestUndelimitedParams()
{
   TeXToken macdef[] =  { TOK_MATCH,
                          TOK_MATCH,
                          TOK_MATCH,
                          TOK_END_MATCH,
                          TOK_LET('T'),
                          TOK_OUT,
                          TOK_OTHER('1'),
                          TOK_LET('A'),
                          TOK_OUT,
                          TOK_OTHER('2'),
                          TOK_LET('B'),
                          TOK_OUT,
                          TOK_OTHER('3'),
                          END_ARRAY};

   MacroDef* pMacroDef = new MacroDef(TokenArrayToList(macdef));
   Symbols::CreateSymbol("mymac", pMacroDef);
   InputFile("undelim.tex");
   LogFile::Start();
   while (! InputStack::bEmpty()) {
      GetToken();
      LOG("\n" << CurTok());
   }
   return CompareLog("undelim.log", "v.UndelimitedParams");
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 632, 653, 657 and 661.}
\fwusedin{This macro is invoked in definition 685.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{undelim.tex}{658}\fwequals \fwodef \fwbtx[XXX\mymac 1{234}5ZZZ
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{undelim.log}{659}\fwequals \fwodef \fwbtx[
(X   Letter)
(X   Letter)
(X   Letter)
(T   Letter)
(1   Other)
(A   Letter)
(2   Other)
(3   Other)
(4   Other)
(B   Letter)
(5   Other)
(Z   Letter)
(Z   Letter)
(Z   Letter)]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Macrop TestTable}{660}\fwplusequals \fwodef \fwbtx[{"delim", TestDelimitedParams},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 631, 652, 656 and 660.}
\fwusedin{This macro is invoked in definition 685.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Macrop tests}{661}\fwplusequals \fwodef \fwbtx[bool TestDelimitedParams()
{
   TeXToken macdef[] =  { TOK_MATCH,
                          TOK_OTHER('.'),
                          TOK_END_MATCH,
                          TOK_LET('T'),
                          TOK_LET('A'),
                          TOK_LET('B'),
                          TOK_OTHER(':'),
                          TOK_OUT,
                          TOK_OTHER('1'),
                          END_ARRAY};

   MacroDef* pMacroDef = new MacroDef(TokenArrayToList(macdef));
   Symbols::CreateSymbol("mymac", pMacroDef);
   InputFile("delim.tex");
   LogFile::Start();
   while (! InputStack::bEmpty()) {
      GetToken();
      LOG("\n" << CurTok());
   }
   return CompareLog("delim.log", "InputStack.DelimitedParams");
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 632, 653, 657 and 661.}
\fwusedin{This macro is invoked in definition 685.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwfilename{delim.tex}{662}\fwequals \fwodef \fwbtx[XXX \mymac delimited parameter. YYY
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{delim.log}{663}\fwequals \fwodef \fwbtx[
(X   Letter)
(X   Letter)
(X   Letter)
(    Space)
(T   Letter)
(A   Letter)
(B   Letter)
(:   Other)
(d   Letter)
(e   Letter)
(l   Letter)
(i   Letter)
(m   Letter)
(i   Letter)
(t   Letter)
(e   Letter)
(d   Letter)
(    Space)
(p   Letter)
(a   Letter)
(r   Letter)
(a   Letter)
(m   Letter)
(e   Letter)
(t   Letter)
(e   Letter)
(r   Letter)
(    Space)
(Y   Letter)
(Y   Letter)
(Y   Letter)]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



In this section we'll implement commands to make macro
definitions. These are the \fwlit{\char`\\def}, \fwlit{\char`\\gdef}, , \fwlit{\char`\\edef},
\fwlit{\char`\\xdef}, \fwlit{\char`\\global}, and \fwlit{\char`\\long} commands.

First we add command codes for these things:

\noseealso
\fwbeginmacro
\fwmacroname{Command Codes}{664}\fwplusequals \fwodef \fwbtx[CMD_DEF,
CMD_GDEF,
CMD_EDEF,
CMD_XDEF,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


And then we add symbols to the symbol table:

\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{665}\fwplusequals \fwodef \fwbtx[NewPrimitive("def",  CMD_DEF);
NewPrimitive("gdef", CMD_GDEF);
NewPrimitive("edef", CMD_EDEF);
NewPrimitive("xdef", CMD_XDEF);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro



\cmd{def}

\fwbeginmacro
\fwmacroname{Macro definition commands}{666}\fwplusequals \fwodef \fwbtx[case CMD_DEF: {
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 666, 667, 668 and 669.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Macro definition commands}{667}\fwplusequals \fwodef \fwbtx[case CMD_GDEF: {
   DoAssignment(PREFIX_GLOBAL);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 666, 667, 668 and 669.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Macro definition commands}{668}\fwplusequals \fwodef \fwbtx[case CMD_EDEF: {
   DoAssignment(0);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 666, 667, 668 and 669.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Macro definition commands}{669}\fwplusequals \fwodef \fwbtx[case CMD_XDEF: {
   DoAssignment(PREFIX_GLOBAL);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 666, 667, 668 and 669.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Assignments}{670}\fwplusequals \fwodef \fwbtx[case CMD_DEF:{
   DefAssignment(CurCmdCode(), prefixes);
   break;
}
case CMD_GDEF:{
   DefAssignment(CurCmdCode(), prefixes | PREFIX_GLOBAL);
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Macro function delcarations}{671}\fwequals \fwodef \fwbtx[enum CommandCode;
void DefAssignment(CommandCode, int prefixes);
void EdefAssignment(CommandCode, int prefixes);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 681.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Function to print macro defs into an auxiliary file}{672}\fwmany{}\fwequals \fwodef \fwbtx[

extern std::ofstream s_tapfile;
extern std::string   s_tapfilename;
extern bool s_bTapped;


void PrintDefn(TokenList& tl)
{
   if (!s_bTapped){
      Typesetter::AppendTag("\n\\input ");
      Typesetter::AppendTag(s_tapfilename.c_str());
      s_bTapped = true;
   }

   s_tapfile << "\n";
   TokenList::const_iterator it;

   for (it = tl.begin(); it != tl.end(); ++it){
     TeXToken tt = *it;
     switch (tt.Type()){
      case TT_SYMBOL:
         if (tt.Symbol() == Symbols::NullCS()){

         }else{
            s_tapfile << "\\";

            String s = Symbols::GetName(tt.Symbol());
            for (int i = 0; i < s.Size(); ++i){
               if (s[i] >= 32 && s[i] <= 126){
                  s_tapfile  << (char)s[i];
               } else {
                  s_tapfile  << "[chr " << (int) s[i] << "]";
               }

            }
            if ((s.Size() > 1) || GetCatcode(s[0] == CC_LETTER)){
               s_tapfile << " ";
            }
         }
         break;

      case TT_PAR:
            s_tapfile << "\\par ";
            break;
      case TT_MATCH:
           ++s_paramno;
           s_tapfile << "#" << s_paramno;
           break;
      case TT_OUTPARAM:
           s_tapfile << "#";
           s_tapfile << 1+(int)tt.ChrCode()
           ;break;
      default:
         s_tapfile << (char) tt.ChrCode();
         break;
      }
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Def Assignments}{673}\fwplusequals \fwodef \fwbtx[


void DefAssignment(CommandCode curcmd, int prefixes){
   TeXToken defining;
   CommandCode thecmd = curcmd;
   bool bGlobal = prefixes & PREFIX_GLOBAL;
   bool bLong   = prefixes & PREFIX_LONG;
   TokenList* pTL = 0;
   MacroDef* pMD = 0;
   TokenList* pTap = new TokenList();
   bool tapping = (Global::msioutput == 0) &&
                  InputStack::StartTap(pTap);
   if (tapping){
     if (bGlobal){
       // push back \global
       pTap -> AppendSymbol("global");
     }
     if (bLong){
       // push back \long
       pTap -> AppendSymbol("long");
     }
     pTap -> push_back(CurTok());
   }
   ]fwetx=%
\fwmacroname{Scan definable symbol}{676}\fwbtx[
   pTL = new TokenList();
   ]fwetx=%
\fwmacroname{Scan parameter specification}{677}\fwbtx[
   bool bExpand = false;
   ]fwetx=%
\fwmacroname{Scan body}{678}\fwbtx[
   if (tapping){
      InputStack::StopTap();
      LOG("\nTapped tokens = " << *pTap);
      PrintDefn(*pTap);
   }
   delete pTap;

   if (bHashBrace){
      pTL -> push_back(TeXToken(TT_LEFT_BRACE, '{', 0));
   }
   LOG("\n----Set " << defining << " = " << *pTL);
   pMD = new MacroDef(pTL);
   void* pDefLoc;
   if (defining.Type() == TT_SYMBOL){
      Symbols::GetDefLoc(defining.Symbol(), &pDefLoc);
   } else {
      Symbols::GetActiveDefLoc(defining.ChrCode(), &pDefLoc);
   }
   DefRestoration* restore =
        new DefRestoration((SymbolData**)pDefLoc, "a def");
   SaveRestoration(restore, bGlobal);

   if (defining.Type() == TT_SYMBOL){
      Symbols::SetDef(defining.Symbol(), pMD,
                       bGlobal || thecmd == CMD_GDEF);
   } else {
      Symbols::SetActiveDef(defining.ChrCode(), pMD,
                       bGlobal || thecmd == CMD_GDEF);
   }

}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 673 and 674.}
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Def Assignments}{674}\fwplusequals \fwodef \fwbtx[void EdefAssignment(CommandCode curcmd, int prefixes)
{
   CommandCode thecmd = curcmd;
   TeXToken defining;
   bool bGlobal = prefixes & PREFIX_GLOBAL;
   bool bLong = prefixes & PREFIX_LONG;
   TokenList* pTL = 0;
   MacroDef* pMD = 0;

   TokenList* pTap = new TokenList();
   bool tapping = (Global::msioutput == 0) &&
                  InputStack::StartTap(pTap);
   if (tapping){
     if (bGlobal){
       // push back \global
       pTap -> AppendSymbol("global");
     }
     if (bLong){
       // push back \long
       pTap -> AppendSymbol("long");
     }
     pTap -> push_back(CurTok());
   }

   ]fwetx=%
\fwmacroname{Scan definable symbol}{676}\fwbtx[
   pTL = new TokenList();
   ]fwetx=%
\fwmacroname{Scan parameter specification}{677}\fwbtx[
   bool bExpand = true;
   ]fwetx=%
\fwmacroname{Scan body}{678}\fwbtx[
   InputStack::Clean();
   if (tapping){
      InputStack::StopTap();
      LOG("\nTapped tokens = " << *pTap);
      PrintDefn(*pTap);
   }
   delete pTap;

   if (bHashBrace){
      pTL -> push_back(TeXToken(TT_LEFT_BRACE, '{', 0));
   }

   LOG("\n----Set " << defining << " = " << *pTL);
   pMD = new MacroDef(pTL);
   void* pDefLoc;
   Symbols::GetDefLoc(defining.Symbol(), &pDefLoc);
   DefRestoration* restore =
        new DefRestoration((SymbolData**)pDefLoc, "a def");
   SaveRestoration(restore, bGlobal);

   Symbols::SetDef(defining.Symbol(), pMD, bGlobal || thecmd == CMD_XDEF);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 673 and 674.}
\fwusedin{This macro is invoked in definition 682.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Assignments}{675}\fwplusequals \fwodef \fwbtx[case CMD_EDEF:
   EdefAssignment(CurCmdCode(), prefixes);
   break;
case CMD_XDEF:
   EdefAssignment(CurCmdCode(), prefixes | PREFIX_GLOBAL);
   break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 460, 496, 510, 515, 520, 525, 530, 538, 543, 547, 552, 558, 563, 567, 576, 581, 586, 592, 596, 598, 602, 606, 670 and 675.}
\fwusedin{This macro is invoked in definition 500.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Scan definable symbol}{676}\fwmany{}\fwequals \fwodef \fwbtx[do{
  GetRawToken();
} while (CurTok().Type() == TT_SPACE);
if ( CurTok().Type() == TT_SYMBOL ||
     CurTok().Type() == TT_ACTIVE){
   defining = CurTok();
} else {
   LOG("ERROR -- can't define" << CurTok());
   InputStack::Putback(CurTok());
   return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 460, 469, 596, 598, 673 and 674.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Scan parameter specification}{677}\fwmany{}\fwequals \fwodef \fwbtx[bool bHashBrace = false;
if (!InputStack::bEmpty()){
   GetRawToken();
   int expectedparam = 1;
   while (CurTok().Type() != TT_LEFT_BRACE) {
      if (CurTok().Type() == TT_PARAM){
         GetRawToken();
         if (CurTok().Type() == TT_OTHER)
         {
            if (CurTok().ChrCode() >= '0' &&
                CurTok().ChrCode() <= '9')
            {
               int thisnum = CurTok().ChrCode() - '0';
               if (thisnum == expectedparam){
                  pTL -> push_back(TeXToken(TT_MATCH, '#', 0));
                  ++expectedparam;
               }
            }
         } else if (CurTok().Type() == TT_LEFT_BRACE){
            LOG("\n-- i see  #{");
            bHashBrace = true;
            pTL -> push_back(CurTok());
            InputStack::Putback(CurTok());
            if (InputStack::bEmpty())
              break;
         } else {
            ASSERT(false);
         }
      } else {
         pTL -> push_back(CurTok());
         if (InputStack::bEmpty())
           break;
      }
      GetRawToken();
   }
   pTL -> push_back(TeXToken(TT_END_MATCH, 0, 0));
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 673 and 674.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Scan body}{678}\fwmany{}\fwequals \fwodef \fwbtx[if (CurTok().Type() != TT_LEFT_BRACE){
   LOG("Missing left brace");
   return;
}else{
   bool scanning_body = true;
   int balance = 1;
   while (scanning_body) {
      if (InputStack::bEmpty()){
         scanning_body = false;
      }else{
         if (!bExpand){
            GetRawToken();
         } else {
            // During an edef we expand tokens, but the result
            // of \the is not expanded again.
            // Also, a parameter to \msitag should not be expanded.
            GetRawToken();
            const Expandable* exp =
                dynamic_cast<const Expandable*>( CurData() );

            if (exp != 0){
              EXPFUNC fcn = exp -> m_fcnExpand;
              if (fcn == xfcnThe){
                 TokenListTokenSource* ts = xfcnThe_nopush(0, 0, 0);
                 while(!ts -> bEmpty()){
                    TeXToken tt;
                    ts -> GetToken(&tt);
                    pTL -> push_back(tt);
                 }
                 delete ts;
                 continue;
              } else {
                 // Put it back and do GetToken
                 InputStack::Putback(CurTok());
                 GetToken();
              }
            }
            // Watch for \msitag
            DetermineCommandCode();
            if (CurCmdCode() == CMD_TAG){
               std::cout << "\n\\msitag in body of \\edef";
               LOG("\n\\msitag in body of \\edef");
               pTL -> push_back(CurTok());
               GetRawToken();
               if (CurTok().Type() != TT_LEFT_BRACE){
                  LOG("\nError -- Expected left brace");
                  ASSERT(false);
               }
               pTL -> push_back(CurTok());
               int msitagbal = 1;
               while (msitagbal > 0){
                 GetRawToken();
                 pTL -> push_back(CurTok());
                 if (CurTok().Type() == TT_LEFT_BRACE) {
                    ++msitagbal;
                 } else if (CurTok().Type()==TT_RIGHT_BRACE){
                    --msitagbal;
                 }
               }
               GetRawToken();
            }
         }
      }
      if (CurTok().Type() == TT_LEFT_BRACE){
         balance += 1;
      } else if (CurTok().Type() == TT_RIGHT_BRACE){
         balance -= 1;
         if (balance == 0){
           scanning_body = false;
           break;
         }
      } else if (CurTok().Type() == TT_PARAM){
         GetRawToken();
         //Now we should either see a parameter number or another #
         if (CurTok().Type() == TT_OTHER &&
             CurTok().ChrCode() >= '1' &&
             CurTok().ChrCode() <= '9')
         {
            CurTok().SetType(TT_OUTPARAM);
            int n = CurTok().ChrCode() - '0' - 1;
            CurTok().SetChrCode(n);
         } else if (CurTok().Type() == TT_PARAM){
         } else {
            ASSERT(false);
         }
      }
      pTL -> push_back(CurTok());
   }
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 673 and 674.}
\fwendmacronotes
\fwendmacro








And here is a test to see if they work:

\fwbeginmacro
\fwmacroname{Interprt TestTable}{679}\fwplusequals \fwodef \fwbtx[{"defs1", TestDefs1},
{"defs2", TestDefs2},
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 531, 587 and 679.}
\fwusedin{This macro is invoked in definition 499.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Interprt tests}{680}\fwplusequals \fwodef \fwbtx[bool TestDefs1()
{
   Interpretter::InitializeSymbolTable();
   InitializeKeywords();
   InputFile("deftest1.tex");
   Interpretter::MainLoop();
   return CompareLog("deftest1.log", "Interpretter Def test 1");
}

bool TestDefs2()
{
   Interpretter::InitializeSymbolTable();
   InitializeKeywords();
   InputFile("deftest2.tex");
   Interpretter::MainLoop();
   return CompareLog("deftest2.log", "Interpretter Def test 2");
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 532, 588 and 680.}
\fwusedin{This macro is invoked in definition 499.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwfilename{macros.h}{681}\fwequals \fwodef \fwbtx[#ifndef MACROS_H
#define MACROS_H
#include "tokens.h"
#include "scanutils.h"
#include "typesetter.h"
#include <iostream>

]fwetx=%
\fwmacroname{struct Macro}{634}\fwbtx[
]fwetx=%
\fwmacroname{class MacroExpansion}{621}\fwbtx[
]fwetx=%
\fwmacroname{Macro function delcarations}{671}\fwbtx[
#endif

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{macros.cpp}{682}\fwequals \fwodef \fwbtx[#include "macros.h"
#include "scanutils.h"
#include "restore.h"
#include <fstream>

// external decl
bool xfcnThe(int /* ignored */, TeXToken*, SymbolData**);
TokenListTokenSource* xfcnThe_nopush(
                          int /* ignored */,
                          TeXToken*,
                          SymbolData**);



// static data. The preferred way to introduce is to
// use an anonymous namespace - see Stroustrup
namespace{
   ]fwetx=%
\fwmacroname{The parameter stack}{622}\fwbtx[
   ]fwetx=%
\fwmacroname{The temporary parameter stack}{638}\fwbtx[
}

]fwetx=%
\fwmacroname{Some defines}{649}\fwbtx[

]fwetx=%
\fwmacroname{Function to print macro defs into an auxiliary file}{672}\fwbtx[

]fwetx=%
\fwmacroname{MacroExpansion::MacroExpansion}{623}\fwbtx[
]fwetx=%
\fwmacroname{MacroExpansion::\char`\~MacroExpansion}{624}\fwbtx[
]fwetx=%
\fwmacroname{MacroExpansion::SetParam}{626}\fwbtx[
]fwetx=%
\fwmacroname{MacroExpansion::bEmpty}{625}\fwbtx[
]fwetx=%
\fwmacroname{MacroExpansion::NextPosition}{628}\fwbtx[
]fwetx=%
\fwmacroname{MacroExpansion::GetToken}{627}\fwbtx[

]fwetx=%
\fwmacroname{MacroDef::MacroDef}{635}\fwbtx[
]fwetx=%
\fwmacroname{MacroDef::\char`\~MacroDef}{636}\fwbtx[
]fwetx=%
\fwmacroname{MacroDef::Toks}{637}\fwbtx[
]fwetx=%
\fwmacroname{MacroDef::Expand imp}{639}\fwbtx[


]fwetx=%
\fwmacroname{Def Assignments}{673}\fwbtx[

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwfilename{deftest1.tex}{683}\fwequals \fwodef \fwbtx[ABC\def\bazoo #1{A#1B} XYZ\bazoo{x} etc.]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{deftest1.log}{684}\fwequals \fwodef \fwbtx[
(A   Letter)  ERROR -- no command code.
(B   Letter)  ERROR -- no command code.
(C   Letter)  ERROR -- no command code.
(\def,Symbol[704])
   Defining... (\bazoo,Symbol[1388])
(    Space)  ERROR -- no command code.
(X   Letter)  ERROR -- no command code.
(Y   Letter)  ERROR -- no command code.
(Z   Letter)  ERROR -- no command code.
(A   Letter)  ERROR -- no command code.
(x   Letter)  ERROR -- no command code.
(B   Letter)  ERROR -- no command code.
(    Space)  ERROR -- no command code.
(e   Letter)  ERROR -- no command code.
(t   Letter)  ERROR -- no command code.
(c   Letter)  ERROR -- no command code.
(.   Other)  ERROR -- no command code.]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwfilename{macros.t.cpp}{685}\fwequals \fwodef \fwbtx[#include <string>
#include "platform.h"
#include "textio.h"
#include "tokens.h"
]fwetx=%
\fwmacroname{CompareLog utility}{17}\fwbtx[
]fwetx=%
\fwmacroname{Input file utility}{630}\fwbtx[
]fwetx=%
\fwmacroname{Tokens generation utility}{629}\fwbtx[
]fwetx=%
\fwmacroname{Test jig}{8}\fwoparen \fwoquote\fwmacroname{Macrop tests}{632}\fwcquote\fwcomma \fwoquote\fwmacroname{Macrop TestTable}{631}\fwcquote\fwcparen \fwbtx[

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwseca{16}{The node data structures}

Most of the time \TeX{} is building lists of boxes, glue, and other
kinds of things. Here are the main abstract types:

\fwbeginmacro
\fwmacroname{TeXNode declaration}{686}\fwplusequals \fwodef \fwbtx[#include <iostream>
class OutputStream {
public:
  std::ostream& m_stream;
  std::string m_str;

  OutputStream(std::ostream& os)
     : m_stream(os)
  {}
  //void Print(const char*);
  OutputStream& operator<<(const char*);
  OutputStream& operator<<(const char);
  void Space();
  void Flush();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 686, 688 and 689.}
\fwusedin{This macro is invoked in definition 775.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{687}\fwplusequals \fwodef \fwbtx[OutputStream& OutputStream::operator<<(const char* str)
{
   const char* p = str;
   if (strlen(p) == 1 && *p == '\n'){
      if (m_str.size() > 0){
         m_stream << m_str.c_str() << "\n";
         m_str = "";
      }
   } else if (strlen(p) == 2 && *p == '\n' && *(p+1) == '\n'){
      if (m_str.size() > 0){
         m_stream << m_str.c_str() << "\n\n";
         m_str = "";
      } else {
         m_stream << m_str.c_str() << "\n";
         m_str = "";
      }
   } else {
      while (*p != 0){
         if (*p != '\n'){
            m_str += *p;
         } else {
            m_stream << m_str.c_str() << "\n";
            m_str = "";
         }
         ++p;
      }
   }
   return *this;
}

OutputStream& OutputStream::operator<<(const char ch)
{
   m_str += ch;
   return *this;
}

void OutputStream::Space()
{
   if (m_str.size() > 70){
      m_stream << m_str.c_str() << "\n";
      m_str = "";
   } else {
      m_str += " ";
   }
}

void OutputStream::Flush()
{
   m_stream << m_str.c_str();
   m_stream.flush();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{TeXNode declaration}{688}\fwplusequals \fwodef \fwbtx[class TeXNode {
public:
   virtual ~TeXNode(){}
   virtual void Print(OutputStream&) {}
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 686, 688 and 689.}
\fwusedin{This macro is invoked in definition 775.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{TeXNode declaration}{689}\fwplusequals \fwodef \fwbtx[class TeXNodeList : public std::list<TeXNode*> {
public:
    void Print(OutputStream&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 686, 688 and 689.}
\fwusedin{This macro is invoked in definition 775.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{690}\fwplusequals \fwodef \fwbtx[void TeXNodeList::Print(OutputStream& out)
{
   TeXNodeList::const_iterator it;
   for (it = begin(); it != end(); ++it){
      (*it) -> Print(out);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{691}\fwplusequals \fwodef \fwbtx[class TagNode : public TeXNode {
private:
   char* m_str;
public:
   TagNode(const String& str);
   TagNode(const char* str);
   void Print(OutputStream&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{692}\fwplusequals \fwodef \fwbtx[TagNode::TagNode(const String& str)
{
   m_str = new char[str.Size()+1];
   for (int k = 0; k < str.Size(); ++k)
   {
      m_str[k] = str[k];
   }
   m_str[str.Size()] = '\0';
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{693}\fwplusequals \fwodef \fwbtx[TagNode::TagNode(const char* str)
{
   m_str = new char[strlen(str)+1];
   if (m_str == 0){
      throw;
   }
   strcpy(m_str,str);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{694}\fwplusequals \fwodef \fwbtx[void TagNode::Print(OutputStream& out)
{
   out << m_str;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{695}\fwplusequals \fwodef \fwbtx[class CharNode : public TeXNode {
private:
   FontCode m_font;
   TeXChar  m_char;
public:
   CharNode(FontCode f, TeXChar c)
     : m_font(f),
       m_char(c)
   {}

   ~CharNode()
   {}

   void Print(OutputStream&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{696}\fwplusequals \fwodef \fwbtx[void CharNode::Print(OutputStream& out)
{
  if (0 < m_char && m_char <= 126)
     out << (char) m_char;
  else {
     //out << "\\u(" << m_char << ")";
     out << (char) (m_char / 256) << (char)(m_char % 256);
  }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{697}\fwplusequals \fwodef \fwbtx[class GlueNode : public TeXNode {
public:
   void Print(OutputStream&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{698}\fwplusequals \fwodef \fwbtx[void GlueNode::Print(OutputStream& out)
{
   out.Space();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro

\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{699}\fwplusequals \fwodef \fwbtx[class HListNode : public TeXNode {
private:
   Scaled m_width;
   Scaled m_height;
   Scaled m_depth;
   Scaled m_shift;
   //GlueOrder m_glueOrder;
   //GlueSign  m_glueSign;
   //GlueRatio m_glueSet;
   TeXNodeList* m_pList;
public:
   HListNode(TeXNodeList* list)
      : m_pList(list)
   {}

   void Print(OutputStream&);

};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{700}\fwplusequals \fwodef \fwbtx[void HListNode::Print(OutputStream& out)
{
   m_pList -> Print(out);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro




\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{701}\fwplusequals \fwodef \fwbtx[class VListNode : public TeXNode {
private:
   Scaled m_width;
   Scaled m_height;
   Scaled m_depth;
   Scaled m_shift;
   //GlueOrder m_glueOrder;
   //GlueSign  m_glueSign;
   //GlueRatio m_glueSet;

   TeXNodeList* m_pList;
public:
   VListNode(TeXNodeList* list)
      : m_pList(list)
   {}

   void Print(OutputStream&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{702}\fwplusequals \fwodef \fwbtx[void VListNode::Print(OutputStream& out)
{
   m_pList -> Print(out);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{703}\fwplusequals \fwodef \fwbtx[class RuleNode : public TeXNode {
private:
   Scaled m_width;
   Scaled m_height;
   Scaled m_depth;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Node declarations}{704}\fwplusequals \fwodef \fwbtx[class AlignCellNode : public TeXNode {
private:
public:
   TeXNodeList* m_pList;
   void Print(OutputStream&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{705}\fwplusequals \fwodef \fwbtx[void AlignCellNode::Print(OutputStream& out)
{
   m_pList -> Print(out);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Node declarations}{706}\fwplusequals \fwodef \fwbtx[class AlignRowNode : public TeXNode {
private:
public:
   void Print(OutputStream&);
   TeXNodeList* m_pList;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{707}\fwplusequals \fwodef \fwbtx[void AlignRowNode::Print(OutputStream& out)
{
   TeXNodeList::const_iterator it = m_pList -> begin();
   while (true){
      (*it)->Print(out);
      ++it;
      if (it == m_pList -> end())
         break;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Node declarations}{708}\fwplusequals \fwodef \fwbtx[class AlignmentNode : public TeXNode {
private:
public:
   void Print(OutputStream&);
   TeXNodeList* m_pList;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{709}\fwplusequals \fwodef \fwbtx[void AlignmentNode::Print(OutputStream& out)
{
   //out << "<table>";
   m_pList -> Print(out);
   //out << "</table>";
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro




\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{710}\fwplusequals \fwodef \fwbtx[class InsertNode : public TeXNode {
private:
   int m_boxNumber;
   Scaled m_width; // I don't know if this is actually used
   Scaled m_depthPlusHeight; // of vertical material beinbg inserted
   Scaled  m_splitMaxDepth;
   // Glue    m_splitTopSkip; // see TTP140
   int     m_floatPenalty;
   TeXNodeList m_list;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{711}\fwplusequals \fwodef \fwbtx[class TokenList;

class MarkNode : public TeXNode {
private:
  TokenList& m_tokList;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{712}\fwplusequals \fwodef \fwbtx[class AdjustNode : public TeXNode {
private:
   TeXNodeList m_list;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{713}\fwplusequals \fwodef \fwbtx[class LigNode : public TeXNode {
private:
   //CharCode m_ligChar;
   //CharList m_charList;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro

\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{714}\fwplusequals \fwodef \fwbtx[class DiscNode : public TeXNode {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{715}\fwplusequals \fwodef \fwbtx[class WhatsitNode : public TeXNode {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro




\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{716}\fwplusequals \fwodef \fwbtx[class MListNode : public TeXNode {
public:
   void Print(OutputStream& out);
   TeXNodeList* m_pList;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Typesetter implementation}{717}\fwplusequals \fwodef \fwbtx[const int NUM_UPREF_STRS = 20;
const int FIX_IE_BUG = 18;

char *upref_zstrs[] = {
  "200",                           // U8* mml_version
  "<mml:math class=\"displayedmathml\" mode=\"display\" display=\"block\">" ,
  "<mml:math class=\"inlinemathml\" display=\"inline\">",
  "mml:",                         //  U8* namespace_prefix;
  "fontfamily=\"Times New Roman\" fontsize=\"120%\"",   //  U8* mstyle_attrs;
  "msimathname=\"true\"",         //  U8* mathname_attrs;
  "mathcolor=\"green\"",          //  U8* unitname_attrs;
  "mathcolor=\"black\"",          //  U8* text_in_math_attrs;
  "mathcolor=\"green\"",          //  U8* link_attrs;
  "true",                         //  U8* renderer_baselines;
  "false",                        //  U8* eqn_tags_to_mlabeledtr;
  "false",                        //  U8* eqn_nums_to_mlabeledtr;
  "0",                            //  U8* entity_mode;
  "1",                            //  U8* lr_spacing_mode;
  "1",                            //  U8* lr_spacing_mode_in_scripts;
  "(%theequation%)",              //  U8* eqn_nums_format;
  "false",                        //  U8* long_arrows_are_stretched;
  "2",                            //  U8* indent_increment;
  "true",                         //  U8* adjust_output_for_IE_spacing_bug;
  "<mml:mtext class=\"fix-IE-bug\">&ZeroWidthSpace;</mml:mtext></mml:math>",
  ""
};



bool fix_IE_space_bug =  true;

HINSTANCE s_hApp;
HINSTANCE s_hDLL;

std::string s_mathml;
extern char* s_mmldirname;

bool SetupMathMLDLL()
{
    // const MAXPATH = 500;
    // char path[MAXPATH];
    // s_hApp = GetModuleHandle(0);
    // GetModuleFileName( s_hApp, path, MAXPATH );
    // FileSpec fsPath(path);
    // std::string strPath = fsPath.GetDir();
    std::string strPath = s_mmldirname;
    strPath += "\\mmldll.dll";
    s_hDLL = ::LoadLibrary( strPath.c_str() );
    if (s_hDLL == NULL) {
      std::cout << "Load library failed for " << strPath.c_str() << "\n";
      return false;
    }

    // int i = 0;
    // while ( i < NUM_UPREF_STRS ) {
    //   upref_zstrs[i]  =  NULL;
    //   i++;
    // }

    //TCIString mathmlSettings;
    //GetCfgSection("MATHML SETTINGS", mathmlSettings);
    // i = 0;
    // int uprefcnt = 0;
    // while (i < mathmlSettings.GetLength())
    // {
    //   TCIString setting;
    //   while ((i < mathmlSettings.GetLength()) &&
    //          (mathmlSettings[i] != '\n') &&
    //          (mathmlSettings[i] != '='))
    //   {
    //      ++i;
    //   }
    //   TCI_ASSERT(mathmlSettings[i] == '=');
    //   ++i;
    //   while ((i < mathmlSettings.GetLength()) && (mathmlSettings[i] != '\n'))
    //   {
    //      if (mathmlSettings[i] != '\r'){
    //         setting += mathmlSettings[i];
    //      }
    //      ++i;
    //   }
    //   int len = setting.GetLength();
    //   char* tar = TCI_NEW(char[len+1]);
    //   char* src = setting.GetBuffer(0);
    //   strcpy(tar, src);
    //   setting.ReleaseBuffer();
    //   upref_zstrs[uprefcnt] = tar;
    //   ++uprefcnt;
    //   ++i;
    // }
  for (int j = 0; j < NUM_UPREF_STRS; j++ )
  {
    if (upref_zstrs[j] == NULL)
    {
      char* temp = new char[1];
      temp[0] = 0;
      upref_zstrs[j] = temp;
    }
  }
  fix_IE_space_bug = (strcmp(upref_zstrs[FIX_IE_BUG], "true") == 0);
  LPINITIALIZE Initialize = (LPINITIALIZE)GetProcAddress(s_hDLL,"Initialize");
  if (!Initialize)
  {
    // TCI_ASSERT(FALSE);
    return false;
  }
  HRESULT hr = (*Initialize)( (const char*) s_mmldirname,
                                (const char*)"mml:",
                                (const char**)upref_zstrs );
  if (hr != S_OK) {
    // TCI_ASSERT(FALSE);
    return false;
  }
  return true;
}


void CloseMathML()
{
  int i =  0;
  while ( i < 20 ) {
    char* str = upref_zstrs[i];
    if ( str )
       delete[] str;
    i++;
  }
  if (s_hDLL != 0){
     FreeLibrary(s_hDLL);
  }
}

BOOL CALLBACK mathmlHandler(DWORD type, const char* data)
{
  if ( type < 1000 ) {
    s_mathml += "\n";
    s_mathml += data;
  } // else
    // TCI_ASSERT(0);

  return true;
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro

\fwbeginmacro
\fwmacroname{Typesetter implementation}{718}\fwplusequals \fwodef \fwbtx[void MListNode::Print(OutputStream& out)
{
   m_pList -> Print(out);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro




\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{719}\fwplusequals \fwodef \fwbtx[class KernNode : public TeXNode {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{720}\fwplusequals \fwodef \fwbtx[class PenaltyNode : public TeXNode {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{721}\fwplusequals \fwodef \fwbtx[class UnsetNode : public TeXNode {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{722}\fwplusequals \fwodef \fwbtx[class StyleNode : public TeXNode {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{723}\fwplusequals \fwodef \fwbtx[class ChoiceNode : public TeXNode {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{724}\fwplusequals \fwodef \fwbtx[
class NoadField{
public:
  virtual ~NoadField() {};
  virtual void Print(OutputStream&) {};
};

class MathCharData : public NoadField{
public:
   MathCharData(TeXChar ch) : m_ch(ch) {}
   void Print(OutputStream&);
private:
   //family;
   TeXChar m_ch;
};

class MathTextChar : public NoadField{
public:
   //family;
   //character;
};

class SubBox : public NoadField{
   TeXNode* m_listNode; // An hlist node or a vlist node
};

class SubMList : public NoadField{
public:
   void Print(OutputStream&);
   TeXNodeList* m_pList;
};

void SubMList::Print(OutputStream& out)
{
   if (s_bMathml){
      //out << "{";
      m_pList -> Print(out);
      //out << "}";
   } else{
      out << "<mrow>";
      m_pList -> Print(out);
      out << "</mrow>";
   }
}

class Noad : public TeXNode{
public:
   Noad() : m_nucleus(0), m_subscript(0), m_superscript(0){}
   void Print(OutputStream&);
   virtual bool ScriptsAllowed(){ return true;}
   NoadField* m_nucleus;
   NoadField* m_subscript;
   NoadField* m_superscript;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{725}\fwplusequals \fwodef \fwbtx[void Noad::Print(OutputStream& out){
   if (m_subscript == 0 && m_superscript == 0){
      m_nucleus -> Print(out);
      return;
   }
   if (m_subscript != 0){
      if (m_superscript == 0){
         if (s_bMathml){
            m_nucleus -> Print(out);
            out << "_";
            m_subscript -> Print(out);
         }else{
            out << "<sub>";
            m_nucleus -> Print(out);
            m_subscript -> Print(out);
            out << "</sub>";
         }
      } else {
         if (s_bMathml){
            m_nucleus -> Print(out);
            out << "_";
            m_subscript -> Print(out);
            out << "^";
            m_superscript -> Print(out);
         } else {
            out << "<subsup>";
            m_nucleus -> Print(out);
            m_subscript -> Print(out);
            m_superscript -> Print(out);
            out << "</subsup>";
         }
      }
   } else {
      if (s_bMathml){
         m_nucleus -> Print(out);
         out << "^";
         m_superscript -> Print(out);
      } else{
         out << "<sup>";
         m_nucleus -> Print(out);
         m_superscript -> Print(out);
         out << "</sup>";
      }
   }

}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{726}\fwplusequals \fwodef \fwbtx[void MathCharData::Print(OutputStream& out)
{
  if (s_bMathml){
     if (m_ch != 0)
        out << (char) m_ch;
  } else {
     if ((char)m_ch == '<')
        out << "&lt;";
     else if (m_ch == '>')
        out << "&gt;";
     else if (0 < m_ch && m_ch <= 126)
        out << "<mi>" << (char) m_ch << "</mi>";
     else
        out << "\\u(" << m_ch << ")";
  }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{727}\fwplusequals \fwodef \fwbtx[class MathList {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{728}\fwplusequals \fwodef \fwbtx[class OrdNoad : public Noad {
public:
   OrdNoad(TeXChar ch);
   //void Print(std::ostream&);
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{729}\fwplusequals \fwodef \fwbtx[OrdNoad::OrdNoad(TeXChar ch)
{
   m_nucleus = new MathCharData(ch);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{730}\fwplusequals \fwodef \fwbtx[// void OrdNoad::Print(std::ostream& out)
// {
//    m_nucleus -> Print(out);
// }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{731}\fwplusequals \fwodef \fwbtx[class OpNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{732}\fwplusequals \fwodef \fwbtx[class BinNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{733}\fwplusequals \fwodef \fwbtx[class RelNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{734}\fwplusequals \fwodef \fwbtx[class OpenNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{735}\fwplusequals \fwodef \fwbtx[class CloseNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{736}\fwplusequals \fwodef \fwbtx[class PunctNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{737}\fwplusequals \fwodef \fwbtx[class InnerNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{738}\fwplusequals \fwodef \fwbtx[class RadicalNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{739}\fwplusequals \fwodef \fwbtx[class FunctionNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


Under and over noads are created by the \fwlit{\char`\\overline}
and \fwlit{\char`\\underline} commands.

\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{740}\fwplusequals \fwodef \fwbtx[class UnderNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{741}\fwplusequals \fwodef \fwbtx[class OverNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{742}\fwplusequals \fwodef \fwbtx[class AccentNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{743}\fwplusequals \fwodef \fwbtx[class VCenterNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{744}\fwplusequals \fwodef \fwbtx[class LeftNoad : public Noad {
private:
   // delimiter;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\noseealso
\fwbeginmacro
\fwmacroname{Node declarations}{745}\fwplusequals \fwodef \fwbtx[class RightNoad : public Noad {
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 691, 695, 697, 699, 701, 703, 704, 706, 708, 710, 711, 712, 713, 714, 715, 716, 719, 720, 721, 722, 723, 724, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744 and 745.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro






\fwseca{17}{Mathematics}

This is part of the interpretter that builds math lists.

\fwsecb{17.1}{Getting into and leaving math mode}

First, here's how we get into math mode ...

This is generated by a catcode 3 character, usually a `\$'.

\fwbeginmacro
\fwmacroname{Command Codes}{746}\fwplusequals \fwodef \fwbtx[CMD_MATH_SHIFT,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{747}\fwplusequals \fwodef \fwbtx[case CMD_MATH_SHIFT : {
   if (Typesetter::GetMode() == MODE_VERTICAL){
      LOG("\n---- math shift in vertical mode.");
      LOG("\n     Leave vmode and rescan $.");
      // Goto HMODE, rescan token
      inp.Putback(CurTok());
      Typesetter::GotoHMode();
      Typesetter::SetInner(false);
      inp.Putback(Global::msieverypar);
      inp.Putback(Global::everypar);
      break;
   }
   LOG("\n---- math shift");
   GetRawToken();
   DetermineCommandCode();
   bool bInline = false;
   if (CurCmdCode() == CMD_MATH_SHIFT){
      LOG("\n---- double $");
   } else {
      LOG("\n---- single $, put back token");
      InputStack::Putback(CurTok());
      bInline = true;
   }
   if (Typesetter::GetMode() == MODE_MATH){
      EndLevel();
      //Typesetter::PopMode();
   } else {
      //Typesetter::GotoMMode();
      if (bInline){
         Typesetter::StartInline();
         Typesetter::SetInner(true);
         NewLevel(INLINE_GROUP);
         inp.Putback(Global::everymath);
      } else {
         Typesetter::StartDisplay();
         Typesetter::SetInner(false);
         NewLevel(DISPLAY_GROUP);
         inp.Putback(Global::everydisplay);
      }
   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwsecb{17.2}{Equation numbers}

\fwbeginmacro
\fwmacroname{Command Codes}{748}\fwplusequals \fwodef \fwbtx[CMD_EQNO,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Create symbols}{749}\fwplusequals \fwodef \fwbtx[NewPrimitive("eqno",  CMD_EQNO, 0, 0);
NewPrimitive("leqno", CMD_EQNO, 0, 1);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Math commands}{750}\fwplusequals \fwodef \fwbtx[case CMD_EQNO:
   if (Typesetter::GetMode() == MODE_MATH){
      if (Typesetter::Priveledged()){
         Typesetter::SetPriveledged(false);
      }
   } else {
      LOG("\nERROR -- eqno");
   }
   break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 750 and 753.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro


\fwsecb{17.3}{ScanMath}

This function is called after \_ or {\tt \char`\^}. ScanMath
may also be used to scan the nucleus of a noad. We expect either
a single math character, or a left brace. If we see a single
character that character is `attached' to the last noad of the
current list. The last noad has one of its fields set to the mathchardata.
Otherwise we wait until the right brace is found and attach the
resulting list as a SubMList.

\fwbeginmacro
\fwmacroname{ScanMath}{751}\fwequals \fwodef \fwbtx[void ScanMath()
{
 bool running = true;
 while (running && !inp.bEmpty()) {
   LOG("\n----ScanMath cycle");
   GetToken();
   DetermineCommandCode();
   switch (CurCmdCode()) {
      case CMD_LETTER:
      case CMD_OTHER:
         if (CurTok().ChrCode() < 128){
            Typesetter::AttachMathChar(CurTok().ChrCode());
         } else {
            Typesetter::AttachMathChar(CurTok().ChrCode());
         }
         LOG("\n----Character " << CurTok().ChrCode());

         return;
         break;

      // Need cases for \mathchar, etc

      case CMD_NONE:{
        LOG("\n----" << CurTok()
                     << " ERROR -- no command code.");

        std::cout << "\n-- Undefined " ;
        String s = Symbols::GetName(CurTok().Symbol());
        std::cout << "\\";
        for (int i = 0; i < s.Size(); ++i){
          if (s[i] >= 32 && s[i] <= 126){
             std::cout << (char) s[i];
          } else {
             std::cout << "[chr " << (int) s[i] << "]";
          }
        }

        // Let's just append the token to the
        // output stream
        TokenList* pTL = new TokenList;
        pTL->push_back(CurTok());
        Typesetter::AppendTag(pTL);

        break;
      }

      case CMD_LEFT_BRACE : {
         LOG("\n----Begin math group " << CurTok());
         Typesetter::StartSubformula();
         NewLevel(MATH_GROUP);
         TeXToken lbrace(TT_LETTER, '{', 0);
         TokenList* pTL = new TokenList;
         pTL->push_back(lbrace);
         Typesetter::AppendTag(pTL);

         return;
         break;
      }
   }
 }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwsecb{17.4}{Subscripts and superscripts}

\fwbeginmacro
\fwmacroname{Command Codes}{752}\fwplusequals \fwodef \fwbtx[CMD_SUBSCRIPT,
CMD_SUPERSCRIPT,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Math commands}{753}\fwplusequals \fwodef \fwbtx[case CMD_SUBSCRIPT:
   if (Typesetter::StartScript(true)){
     ScanMath();
   }
   break;

case CMD_SUPERSCRIPT:
   if (Typesetter::StartScript(false)){
     ScanMath();
   }
   break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 750 and 753.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro










\fwseca{18}{Alignment}


The alignment stack:

\fwbeginmacro
\fwmacroname{Alignment implementation}{754}\fwplusequals \fwodef \fwbtx[

struct PreambleEntry {
   TokenList m_upart;
   TokenList m_vpart;
};


struct AlignStruct {
  AlignStruct()
  {
     m_curpreamble = m_preamble.begin();
     m_iCurPreamble = 0;
  }
  std::list<PreambleEntry> m_preamble;
  std::list<PreambleEntry> m_loop;
  std::list<PreambleEntry>::iterator m_curpreamble;
  int m_iCurPreamble;
};


const int MAX_ALIGNS = 20;
static AlignStruct s_alignStack[MAX_ALIGNS];
static int s_alignTop = -1;

static AlignStruct s_alignment;

enum AlignState{AS_NORMAL, AS_PEEKING};
static AlignState  s_alignState = AS_NORMAL;

void InitRow();
void InitCol();
void PushAlignment()
{
   ASSERT(s_alignTop < MAX_ALIGNS);
   ++s_alignTop;
   // Compute iterator offset
   std::list<PreambleEntry>::iterator it;
   it = s_alignment.m_preamble.begin();
   s_alignment.m_iCurPreamble = 0;
   while (it != s_alignment.m_curpreamble){
     ++s_alignment.m_iCurPreamble;
     ++it;
   }
   s_alignStack[s_alignTop] = s_alignment;
   s_alignment.m_preamble.clear();
   s_alignment.m_loop.clear();
}

void PopAlignment()
{
   ASSERT(s_alignTop >= 0);
   s_alignment = s_alignStack[s_alignTop];
   s_alignment.m_curpreamble = s_alignment.m_preamble.begin();
   for (int i = 0; i < s_alignment.m_iCurPreamble; ++i){
     ++s_alignment.m_curpreamble;
   }
   --s_alignTop;
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Command Codes}{755}\fwplusequals \fwodef \fwbtx[CMD_HALIGN,
CMD_VALIGN,
CMD_ALIGN_TAB,
CMD_SPAN,
CMD_OMIT,
CMD_NOALIGN,
CMD_ENDV,
CMD_ENDR,
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 390, 393, 400, 402, 404, 407, 411, 414, 417, 420, 423, 426, 429, 430, 436, 441, 444, 447, 450, 451, 452, 454, 457, 463, 467, 471, 474, 477, 480, 483, 486, 489, 492, 501, 506, 511, 516, 522, 527, 534, 540, 544, 549, 554, 560, 564, 568, 572, 578, 583, 589, 593, 599, 603, 608, 616, 619, 664, 746, 748, 752 and 755.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Command subcodes}{756}\fwplusequals \fwodef \fwbtx[enum CarRetCode{CR_CR, CR_CRCR};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 464, 502, 507, 512, 569 and 756.}
\fwusedin{This macro is invoked in definition 314.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{757}\fwplusequals \fwodef \fwbtx[NewPrimitive("halign", CMD_HALIGN);
NewPrimitive("valign", CMD_VALIGN);
NewPrimitive("span", CMD_SPAN);
NewPrimitive("omit", CMD_OMIT);
NewPrimitive("noalign", CMD_NOALIGN);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro


The alignment tab is an expandable token.  It has to insert the
correct V-template followed by an ENDV token.

\fwbeginmacro
\fwmacroname{Alignment implementation}{758}\fwplusequals \fwodef \fwbtx[bool xfcnTab(int, TeXToken*, SymbolData**)
{
   LOG("\nAlignment --- found Tab");
   if (s_alignState == AS_PEEKING){
      //InputStack::Putback(CurTok());
      s_alignState = AS_NORMAL;
      return true;
   }

   TeXToken endv(TT_ENDV, 0, 0);
   InputStack::Putback(endv);
   InputStack::Putback(Global::msieverycellend);
   // <Insert v-part>
   InputStack::Putback(s_alignment.m_curpreamble -> m_vpart);
   return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



Here {\tt which} is zero if it's a {\tt cr} and one if it's
a {\tt crcr}.

\fwbeginmacro
\fwmacroname{Alignment implementation}{759}\fwplusequals \fwodef \fwbtx[bool xfcnCR(int which, TeXToken*, SymbolData**)
{
   if (which == 0){
      LOG("\nAlignment --- found \\cr");
   }else if (which == 1){
      LOG("\nAlignment --- found \\crcr");
   } else {
      LOG("\nERROR -- bad \\cr type");
   }
   if (s_alignState == AS_PEEKING){
      if (which == 0){
         InputStack::Putback(CurTok());
         InitRow();
         InputStack::Putback(Global::msieveryrowstart);
         s_alignState = AS_NORMAL;
      }
      return false;
   } else {
      TeXToken endr(TT_ENDR, which, 0);
      InputStack::Putback(endr);
      InputStack::Putback(Global::msieveryrowend);
      InputStack::Putback(Global::msieverycellend);
      // <Insert v-part>
      InputStack::Putback(s_alignment.m_curpreamble -> m_vpart);
      return false;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\noseealso
\fwbeginmacro
\fwmacroname{Create symbols}{760}\fwplusequals \fwodef \fwbtx[// a phony name, used in scanning
NewExpandable("]&[", xfcnTab, 0);
NewExpandable("cr", xfcnCR, 0);
NewExpandable("crcr", xfcnCR, 1);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 316, 320, 323, 326, 329, 333, 335, 391, 394, 405, 408, 412, 415, 418, 421, 424, 427, 431, 437, 442, 448, 455, 458, 465, 468, 472, 475, 478, 481, 484, 487, 490, 493, 503, 508, 513, 518, 523, 528, 536, 541, 545, 550, 556, 561, 565, 570, 574, 579, 584, 590, 594, 600, 604, 609, 617, 620, 665, 749, 757 and 760.}
\fwusedin{This macro is invoked in definition 379.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{Alignment implementation}{761}\fwplusequals \fwodef \fwbtx[void GetPreambleToken()
{
   String cr = StringBuilder::Create("cr");
   int crid;
   Symbols::GetId(cr, &crid, Symbols::NO_CREATE);

   while (true) {
      GetRawToken();
      // We have to check for \cr. Normally this would be expanded
      // but not in a preamble
      if (CurTok().Type() == TT_SYMBOL &&  CurTok().Symbol() == crid){
         SetCmdCode(CMD_ENDR);
         break;
      }

      DetermineCommandCode();
      while (CurCmdCode() == CMD_SPAN){
         GetRawToken();
         if (TT_SYMBOL == CurTok().Type()){
            SymbolData* pDef = 0;
            Symbols::GetDef(CurTok().Symbol(), &pDef);
            const Expandable* exp = dynamic_cast<const Expandable*>(pDef);
            if (exp != 0){
               LOG("Unimplemented case : expandable after \\span in preamble");
               ASSERT(false);
            }
         }
      }
      if (CurCmdCode() == CMD_ASSIGN_GLUE){
         LOG("Unimplemented case: glue assignment in preamble");
         ASSERT(false);
      }
      break;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Alignment implementation}{762}\fwplusequals \fwodef \fwbtx[void ScanAlignmentPreamble()
{
   bool bLoop = false;
   std::list<PreambleEntry>::const_iterator loopbegin;

   GetPreambleToken(); // skip the left brace

   // Skip spaces
   while (CurTok().Type() == TT_SPACE){
      GetPreambleToken();
   }

   while (true) {
      PreambleEntry entry;
      s_alignment.m_preamble.push_back(entry);
      ]fwetx=%
\fwmacroname{Scan U template into holdHead}{763}\fwbtx[
      ]fwetx=%
\fwmacroname{Scan V template into holdHead}{764}\fwbtx[
      LOG("\n----Preamble entry created");
      LOG("\n       u = " << s_alignment.m_preamble.back().m_upart);
      LOG("\n       v = " << s_alignment.m_preamble.back().m_vpart);
      if (CurCmdCode() == CMD_ENDR){
         // InputStack::Putback(CurTok()); // so AlignPeek finds it
         break;
      }
      if (CurCmdCode() == CMD_ALIGN_TAB){
         GetPreambleToken();
      }
   }
   s_alignment.m_curpreamble = s_alignment.m_preamble.begin();
   if (bLoop){
      std::list<PreambleEntry>::const_iterator it;
      for ( it = loopbegin; it != s_alignment.m_preamble.end(); ++it){
         s_alignment.m_loop.push_back(*it);
      }
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Scan U template into holdHead}{763}\fwequals \fwodef \fwbtx[while (true) {
   if (CurTok().Type() == TT_TAB){
      LOG("\nAlignment -- setting loop point");
      // Set the current loop point
      bLoop = true;
      loopbegin = s_alignment.m_preamble.end();
      --loopbegin;
      GetPreambleToken();
      continue;
   }
   if (CurTok().Type() == TT_PARAM){
      GetPreambleToken();
      break; // continue to v-part scanning
   }
   s_alignment.m_preamble.back().m_upart.push_back(CurTok());
   GetPreambleToken();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 762.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Scan V template into holdHead}{764}\fwequals \fwodef \fwbtx[while(true){
   if (CurTok().Type() == TT_TAB || CurCmdCode() == CMD_ENDR){
      break;
   }
   s_alignment.m_preamble.back().m_vpart.push_back(CurTok());
   GetPreambleToken();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 762.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Alignment implementation}{765}\fwplusequals \fwodef \fwbtx[void ExtendPreamble()
{
   LOG("\nAlignment --- extending preamble");
   // curpreamble pointer is passed the end. First back up
   --s_alignment.m_curpreamble;

   // then append the loop
   std::list<PreambleEntry>::const_iterator it;
   for (it = s_alignment.m_loop.begin(); it != s_alignment.m_loop.end(); ++it)
   {
      s_alignment.m_preamble.push_back(*it);
   }

   // the advance the preamble pointer

   ++s_alignment.m_curpreamble;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Alignment implementation}{766}\fwplusequals \fwodef \fwbtx[void InitRow()
{
   LOG("\nAlignment -- InitRow");
   Typesetter::StartRow();
   s_alignment.m_curpreamble = s_alignment.m_preamble.begin();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Alignment implementation}{767}\fwplusequals \fwodef \fwbtx[
void AlignPeek();


void FinRow()
{
   LOG("\nAlignment -- FinRow");
   Typesetter::EndRow();
   AlignPeek();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Alignment implementation}{768}\fwplusequals \fwodef \fwbtx[void InitCol()
{
   LOG("\nAlignment -- InitCol");
   Typesetter::StartCol();
   InputStack::Putback(s_alignment.m_curpreamble -> m_upart);
   InputStack::Putback(Global::msieverycellstart);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Alignment implementation}{769}\fwplusequals \fwodef \fwbtx[bool FinCol()
{
   LOG("\nAlignment -- FinishCol");
   Typesetter::EndCol();
   bool rv = false;
   ++s_alignment.m_curpreamble;
   if ( s_alignment.m_curpreamble == s_alignment.m_preamble.end()){
      //GetNext_NonBlank_NonCall();
      rv = true;
   }
   return rv;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Alignment implementation}{770}\fwplusequals \fwodef \fwbtx[
void FinishAlignment();

void AlignPeek()
{
   LOG("\nAlignment -- AlignPeek");
   while (true) {
      s_alignState = AS_PEEKING;
      GetNext_NonBlank_NonCall();
      s_alignState = AS_NORMAL;
      DetermineCommandCode();
      if (CurCmdCode() == CMD_NOALIGN){
         LOG("\nERROR -- Unimplemented --- \noalign");
         ASSERT(false);
      } else if (CurCmdCode() == CMD_RIGHT_BRACE){
         LOG("\n--- See right brace");
         FinishAlignment();
         break;
      } else if (CurCmdCode() == CMD_ENDR){
         LOG("\n--- See ENDR");
         if (CurTok().ChrCode() == 1){
            continue; // go on to next token -- ignore \crcr
         } else {
            FinRow();
            InitRow();
            InitCol();
            InputStack::Putback(Global::msieveryrowstart);
            break;
         }
      } else {
         LOG("\n--- Saw nothing interesting");
         InputStack::Putback(CurTok());
         InitRow();
         InitCol();
         InputStack::Putback(Global::msieveryrowstart);
         break;
      }
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Alignment implementation}{771}\fwplusequals \fwodef \fwbtx[void InitAlign()
{
   PushAlignment();
   Typesetter::StartAlignment();
   ScanBoxSpec();
   ScanAlignmentPreamble();
   NewLevel(ALIGN_GROUP);
   Typesetter::GotoHMode();
   Typesetter::SetInner(true);
   AlignPeek();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Alignment implementation}{772}\fwplusequals \fwodef \fwbtx[void FinishAlignment()
{
   LOG("\nAlignment -- FinishAlignment");
   EndLevel();
   Typesetter::EndAlignment();
   PopAlignment();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 754, 758, 759, 761, 762, 765, 766, 767, 768, 769, 770, 771 and 772.}
\fwusedin{This macro is invoked in definition 498.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Misc commands}{773}\fwplusequals \fwodef \fwbtx[case CMD_HALIGN:
  LOG("\n----Start halign");
  InitAlign();
break;

case CMD_VALIGN:
  LOG("\n----Start valign");
  InitAlign();
break;

case CMD_ENDV:
   LOG("\n---ENDV");
   if (FinCol()) {
      // if we see a final column in this case we extend
      // the preamble rather than end the row
      if (s_alignment.m_loop.size() != 0){
         ExtendPreamble();
         InitCol();
      } else {
         LOG("\nERROR -- column too long");
         FinRow();
     }
   } else {
      InitCol();
   }
   break;

case CMD_ENDR:
   LOG("\n---ENDR");
   FinCol();
   FinRow();
   break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Misc commands}{774}\fwplusequals \fwodef \fwbtx[case CMD_ALIGN_TAB:
  LOG("\nERROR----Align tab");
  break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 392, 433, 434, 435, 438, 439, 440, 443, 449, 453, 459, 461, 462, 488, 491, 494, 495, 747, 773 and 774.}
\fwusedin{This macro is invoked in definition 383.}
\fwendmacronotes
\fwendmacro



\fwseca{19}{The Typesetter}

The typesetter builds lists of boxes and then breaks them into
lines, formulas, pages, footnotes, and so on.

\fwsecb{19.1}{The Interface}

\fwbeginmacro
\fwfilename{typesetter.h}{775}\fwequals \fwodef \fwbtx[#ifndef TYPESETTER_H
#define TYPESETTER_H
#include "platform.h"
#include <list>
#include "basicdata.h"
]fwetx=%
\fwmacroname{TeXNode declaration}{686}\fwbtx[
]fwetx=%
\fwmacroname{Typesetter Interface}{777}\fwbtx[
#endif
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{typesetter.cpp}{776}\fwequals \fwodef \fwbtx[#include "typesetter.h"
#include <iostream>
#include <strstream>
#include <windows.h>
//#include <filespec.h>
//#include <tcistrin.h>
//#include <dataman.h>
//#include <bytearry.h>
#include "mmldll.h"

enum FieldTarget{TARG_NUCLEUS, TARG_SUBSCRIPT, TARG_SUPERSCRIPT};

static Mode s_mode;
static bool s_bInner;
static bool s_priveledged;
static FieldTarget s_target;
static TeXNodeList* s_pList = new TeXNodeList;
static char* s_processor;

static const bool s_bMathml = true;

]fwetx=%
\fwmacroname{Node declarations}{691}\fwbtx[
]fwetx=%
\fwmacroname{Semantic nest}{778}\fwbtx[
]fwetx=%
\fwmacroname{Typesetter implementation}{687}\fwbtx[
]fwetx=%
\fwmacroname{AdjustSpaceFactor}{792}\fwbtx[
]fwetx=%
\fwmacroname{SetRule}{814}\fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter Interface}{777}\fwequals \fwodef \fwbtx[
enum Mode {MODE_VERTICAL, MODE_HORIZONTAL, MODE_MATH};

class Typesetter {
public:

   static void PrintMainList(std::ostream&);
   static void AppendTag(const TokenList* pTL);
   static void AppendTag(const char* cstr);
   static Mode GetMode();
   static bool GetInner();
   static void SetInner(bool);
   static bool Priveledged();
   static void SetPriveledged(bool);

   static void GotoHMode();
   static void GotoVMode();
   static void GotoMMode();

   static void PopMode();

   static void SetChar(CharCode c);
   static void SetSpace(); // checks space_factor
   static void SetExplicitSpace(); // does not check space_factor
   static void StartBox();
   static void EndBox();

   static void SetMathChar(CharCode c);
   static void AttachMathChar(CharCode c);

   static bool StartNucleus();

   static bool StartScript(bool bSub);
   static void EndScript();

   static void StartInline();
   static void EndInline();

   static void StartDisplay();
   static void EndDisplay();

   static void StartSubformula();
   static void EndSubformula();

   static void StartProcess(const char*);
   static void EndProcess();

   static void StartAlignment();
   static void EndAlignment();
   static void StartCol();
   static void EndCol();
   static void StartRow();
   static void EndRow();
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 775.}
\fwendmacronotes
\fwendmacro



The typesetter is always in one of six modes. Here is a stack to maintain
state info for modes.

\fwbeginmacro
\fwmacroname{Semantic nest}{778}\fwplusequals \fwodef \fwbtx[class SemanticLevel {
public:
   Mode        m_mode;
   bool        m_bInner;
   TeXNodeList* m_pList;
   char* m_processor;
   FieldTarget m_target;
   int      m_prevGraf;
   int      m_aux;
   int      m_sourceLineNumber;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 778, 779, 780 and 781.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Semantic nest}{779}\fwplusequals \fwodef \fwbtx[std::list<SemanticLevel*> semanticNest;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 778, 779, 780 and 781.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Semantic nest}{780}\fwplusequals \fwodef \fwbtx[void PushSemanticLevel()
{
   LOG("\n----Pushing semantic level: ");
   if (s_mode == MODE_HORIZONTAL){
      LOG("horizontal");
   } else if (s_mode == MODE_VERTICAL){
      LOG("vertical");
   } else if (s_mode == MODE_MATH){
      LOG("math");
   } else {
      LOG("ERROR -- unknown mode");
      ASSERT(false);
   }

   SemanticLevel* lev = new SemanticLevel;
   lev -> m_pList = s_pList;
   s_pList = new TeXNodeList;;

   lev -> m_mode = s_mode;
   lev -> m_bInner = s_bInner;
   lev -> m_target = s_target;
   lev -> m_processor = s_processor;
   semanticNest.push_back(lev);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 778, 779, 780 and 781.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Semantic nest}{781}\fwplusequals \fwodef \fwbtx[void PopSemanticLevel()
{
   LOG("\n----Popping semantic level. ");
   SemanticLevel* lev = 0;
   if (semanticNest.size() == 0){
     LOG("\nERROR -- semantic nest underflow!");
     ASSERT(false);
     lev = 0;
   } else {
     lev = semanticNest.back();
   }
   if (lev != 0){
     s_pList = lev -> m_pList;
     s_processor = lev -> m_processor;
     s_mode = lev -> m_mode;
     s_bInner = lev -> m_bInner;
     s_target = lev -> m_target;
     semanticNest.pop_back();
   }

   LOG("Return to " << (s_bInner ? "inner " : ""));

   if (s_mode == MODE_HORIZONTAL){
      LOG("horizontal mode");
   } else if (s_mode == MODE_VERTICAL){
      LOG("vertical mode");
   } else if (s_mode == MODE_MATH){
      LOG("math mode");
   } else {
      LOG("ERROR -- unknown mode");
      ASSERT(false);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 778, 779, 780 and 781.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{782}\fwplusequals \fwodef \fwbtx[void Typesetter::PopMode()
{
   if (s_mode == MODE_MATH){
      // Create an mnode list
      MListNode* pMListNode = new MListNode;
      pMListNode -> m_pList = s_pList;
      PopSemanticLevel();
      s_pList -> push_back(pMListNode);
   } else if (s_mode == MODE_HORIZONTAL){
      // create an hlist
      HListNode* pHListNode = new HListNode(s_pList);
      PopSemanticLevel();
      s_pList -> push_back(pHListNode);
   } else {
      // create a vlist
      VListNode* pVListNode = new VListNode(s_pList);
      PopSemanticLevel();
      s_pList -> push_back(pVListNode);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{783}\fwplusequals \fwodef \fwbtx[void Typesetter::AppendTag(const TokenList* pTL)
{
  if (Global::msioutput == 0){
    StringUtils::AppendToks(*pTL);
    String str = StringBuilder::Create();
    TeXNode* tag = new TagNode(str);
    StringBuilder::Discard(str);
    s_pList -> push_back(tag);
  }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{784}\fwplusequals \fwodef \fwbtx[void Typesetter::AppendTag(const char* cstr)
{
  if (Global::msioutput == 0){
    TeXNode* tag = new TagNode(cstr);
    s_pList -> push_back(tag);
  }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro





\fwbeginmacro
\fwmacroname{Typesetter implementation}{785}\fwplusequals \fwodef \fwbtx[Mode Typesetter::GetMode()
{
   return s_mode;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{786}\fwplusequals \fwodef \fwbtx[bool Typesetter::GetInner()
{
   return s_bInner;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{787}\fwplusequals \fwodef \fwbtx[void Typesetter::SetInner(bool b)
{
   s_bInner = b;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{788}\fwplusequals \fwodef \fwbtx[bool Typesetter::Priveledged()
{
   return s_priveledged;
}
void Typesetter::SetPriveledged(bool b)
{
   s_priveledged = b;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{789}\fwplusequals \fwodef \fwbtx[void Typesetter::GotoHMode()
{
//   // TTP 1091
//   prev_graf = 0;
//   if (mode ==  VMODE || head != tail){
//
//   }
//   // etc

   s_mode = MODE_HORIZONTAL;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{790}\fwplusequals \fwodef \fwbtx[void Typesetter::GotoVMode()
{
   if (s_mode == MODE_HORIZONTAL){

   }
   s_mode = MODE_VERTICAL;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{791}\fwplusequals \fwodef \fwbtx[void Typesetter::GotoMMode()
{
   //PushSemanticLevel();
   s_mode = MODE_MATH;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{AdjustSpaceFactor}{792}\fwequals \fwodef \fwbtx[//    // TTP: 1034. Adjust the space factor
//    int s = SpaceFactor(c);
//    if (s == 1000) {
//       if (s > 0) {
//          space_factor = 1000;
//       }
//    } else {
//       if (space_factor < 1000) {
//          space_factor = 1000;
//       } else {
//          space_factor = s;
//       }
//    }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{793}\fwplusequals \fwodef \fwbtx[void Typesetter::StartBox()
{
   PushSemanticLevel();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{794}\fwplusequals \fwodef \fwbtx[void Typesetter::EndBox()
{
   TeXNode* pNode = 0;
   if (s_mode == MODE_HORIZONTAL){
      pNode = new HListNode(s_pList);
   } else if (s_mode == MODE_VERTICAL){
      pNode = new VListNode(s_pList);
   }

   PopSemanticLevel();

   s_pList -> push_back(pNode);

}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{795}\fwplusequals \fwodef \fwbtx[void Typesetter::StartProcess(const char* name)
{
   PushSemanticLevel();
   s_processor = new char[strlen(name)+1];
   strcpy(s_processor, name);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{796}\fwplusequals \fwodef \fwbtx[void Typesetter::EndProcess()
{
   TeXNodeList* plist = s_pList;
   char* proc = s_processor;
   PopSemanticLevel();

   std::strstream strout;
   OutputStream out(strout);
   plist -> Print(out);
   out.Flush();
   strout.put(0);
   const char* theCStr = strout.str();
   LOG("\nSending to processor " << proc << ": " << theCStr);

   if (strcmp(proc, "jbm") == 0){
      if (strlen(theCStr) != 2) { // i.e. more than $$
         LOG("\nSending to mathmldll: " << theCStr);
         if (s_hDLL == 0){
            SetupMathMLDLL();
         }
         LPCONVERT convertfunc;
         convertfunc  = (LPCONVERT)GetProcAddress(s_hDLL,"ConvertInline");
         convertfunc( theCStr, mathmlHandler, 2 );
         LOG("\nGot back " << s_mathml.c_str());
         std::string str;
         str +=  "<mml:math>";
         str +=  s_mathml;
         str +=  "</mml:math>";
         AppendTag(str.c_str());
         s_mathml = "";
      }
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Typesetter implementation}{797}\fwplusequals \fwodef \fwbtx[void Typesetter::SetChar(CharCode c)
{
  if (Global::msioutput == 0){
    ASSERT(s_mode == MODE_HORIZONTAL || s_mode == MODE_MATH);
    CharNode* ch = new CharNode(NULL, c);
    s_pList -> push_back(ch);
  }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{798}\fwplusequals \fwodef \fwbtx[void Typesetter::SetMathChar(CharCode c)
{
   if (c > 32768){
      //<Treat c as an active character>
      ASSERT(false);
   } else {
      int fam = (c / 256) % 16;
      int mathkind = c / 4096;

      TeXNode* node = new OrdNoad(c);
      s_pList -> push_back(node);
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



This function is used when constructing a sub/superscript
and the mathchar needs to be placed into the correct NoadField.

\fwbeginmacro
\fwmacroname{Typesetter implementation}{799}\fwplusequals \fwodef \fwbtx[void Typesetter::AttachMathChar(CharCode c)
{
   MathCharData* pMCD = new MathCharData(c);
   TeXNode* node = s_pList -> back();
   Noad* noad = dynamic_cast<Noad*>(node);
   ASSERT(noad != 0);
   switch (s_target){
      case TARG_NUCLEUS:
        noad -> m_nucleus = pMCD;
        break;

      case TARG_SUBSCRIPT:
        noad -> m_subscript = pMCD;
        break;

      case TARG_SUPERSCRIPT:
        noad -> m_superscript = pMCD;
        break;

   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{800}\fwplusequals \fwodef \fwbtx[bool Typesetter::StartScript(bool bSub)
{
   if (s_pList -> size() == 0){
      ]fwetx=%
\fwmacroname{Insert dummy noad for script}{802}\fwbtx[
   }
   Noad* noad = dynamic_cast<Noad*>(s_pList -> back());
   if (noad == 0){
      ]fwetx=%
\fwmacroname{Insert dummy noad for script}{802}\fwbtx[
      noad = dynamic_cast<Noad*>(s_pList -> back());
   }
   if (noad != 0){
      if (!noad -> ScriptsAllowed()){
         ]fwetx=%
\fwmacroname{Insert dummy noad for script}{802}\fwbtx[
      }
      noad = dynamic_cast<Noad*>(s_pList -> back());
   }
   if (noad == 0){
      LOG("ERROR -- no noad at end of list");
   }
   s_target = bSub ?  TARG_SUBSCRIPT : TARG_SUPERSCRIPT;
   return (noad != 0);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{801}\fwplusequals \fwodef \fwbtx[bool Typesetter::StartNucleus()
{
   Noad* dummy = new OrdNoad((TeXChar)0);
   s_pList -> push_back(dummy);
   s_target = TARG_NUCLEUS;
   return (true);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Insert dummy noad for script}{802}\fwmany{}\fwequals \fwodef \fwbtx[Noad* dummy = new OrdNoad((TeXChar)0);
s_pList -> push_back(dummy);
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definitions 800, 800 and 800.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{803}\fwplusequals \fwodef \fwbtx[void Typesetter::StartInline()
{
   PushSemanticLevel();
   GotoMMode();
   SetInner(true);
   StringUtils::AppendToks(Global::msiinlinemathproc);
   String str = StringBuilder::Create();
   char* dllname = new char[str.Size() + 1];
   for (int i = 0; i < str.Size(); ++i){
      dllname[i] = str[i];
   }
   dllname[str.Size()] = '\0';
   StringBuilder::Discard(str);
   s_processor = dllname;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{804}\fwplusequals \fwodef \fwbtx[void Typesetter::EndInline()
{
   TeXNodeList* plist = s_pList;
   char* proc = s_processor;
   PopSemanticLevel();

   if (strcmp(proc,"pass") == 0){
      //std::strstream strout;
      //OutputStream out(strout);
      if (Global::msidollar != 0){
         s_pList -> push_back(
            new CharNode(NULL, (char) Global::msidollar)
         );
         //out << (char) Global::msidollar;
      }
      TeXNode* pNode = new HListNode(plist);
      s_pList -> push_back(pNode);
      //plist -> Print(out);
      if (Global::msidollar != 0){
         s_pList -> push_back(
            new CharNode(NULL, (char) Global::msidollar)
         );
         //out << (char) Global::msidollar;
      }
      //out.Flush();
      //strout.put(0);
      //AppendTag(strout.str());
   } else if (strcmp(proc, "jbm") == 0){
      std::strstream strout;
      OutputStream out(strout);
      if (Global::msidollar != 0){
         out << (char) Global::msidollar;
      }
      plist -> Print(out);
      if (Global::msidollar != 0){
         out << (char) Global::msidollar;
      }
      out.Flush();
      strout.put(0);
      const char* theCStr = strout.str();

      if (strlen(theCStr) != 2) { // i.e. more than $$
         LOG("\nSending to jbm processor : " << theCStr);
         if (s_hDLL == 0){
            SetupMathMLDLL();
         }
         LPCONVERT convertfunc;
         convertfunc  = (LPCONVERT)GetProcAddress(s_hDLL,"ConvertInline");
         convertfunc( theCStr, mathmlHandler, 2 );
         LOG("\nGot back " << s_mathml.c_str());
         std::string str;
         str +=  "<mml:math>";
         str +=  s_mathml;
         str +=  "</mml:math>";
         AppendTag(str.c_str());
         s_mathml = "";
      }
   }

}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{805}\fwplusequals \fwodef \fwbtx[void Typesetter::StartDisplay()
{
   PushSemanticLevel();
   GotoMMode();
   SetInner(false);
   StringUtils::AppendToks(Global::msiinlinemathproc);
   String str = StringBuilder::Create();
   char* dllname = new char[str.Size() + 1];
   for (int i = 0; i < str.Size(); ++i){
      dllname[i] = str[i];
   }
   dllname[str.Size()] = '\0';
   StringBuilder::Discard(str);
   s_processor = dllname;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro

\fwbeginmacro
\fwmacroname{Typesetter implementation}{806}\fwplusequals \fwodef \fwbtx[void Typesetter::EndDisplay()
{
   TeXNodeList* plist = s_pList;
   char* proc = s_processor;
   PopSemanticLevel();

   if (strcmp(proc, "pass") == 0){
      std::strstream strout;
      OutputStream out(strout);
      if (Global::msidollar != 0){
         out << (char) Global::msidollar  << (char) Global::msidollar;
      }
      plist -> Print(out);
      if (Global::msidollar != 0){
         out << (char) Global::msidollar  << (char) Global::msidollar;
      }
      out.Flush();
      strout.put(0);
      AppendTag(strout.str());
   } else if (strcmp(proc, "jbm") == 0){
      std::strstream strout;
      OutputStream out(strout);
      if (Global::msidollar != 0){
         out << (char) Global::msidollar  << (char) Global::msidollar;
      }
      plist -> Print(out);
      if (Global::msidollar != 0){
         out << (char) Global::msidollar  << (char) Global::msidollar;
      }
      out.Flush();
      strout.put(0);
      const char* theCStr = strout.str();

      if (strlen(theCStr) != 2) { // i.e. more than $$
         LOG("\nSending to jbm processor : " << theCStr);
         if (s_hDLL == 0){
            SetupMathMLDLL();
         }
         LPCONVERT convertfunc;
         convertfunc  = (LPCONVERT)GetProcAddress(s_hDLL,"ConvertDisplay");
         convertfunc( theCStr, mathmlHandler, 2 );
         LOG("\nGot back " << s_mathml.c_str());
         std::string str;
         str +=  "<mml:math class=\"displayedmathml\" "
                 "mode=\"display\" display=\"block\">";
         str +=  s_mathml;
         str +=  "</mml:math>";
         AppendTag(str.c_str());
         s_mathml = "";
      }
   }

}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Typesetter implementation}{807}\fwplusequals \fwodef \fwbtx[void Typesetter::StartSubformula()
{
   PushSemanticLevel();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{808}\fwplusequals \fwodef \fwbtx[void Typesetter::EndSubformula()
{
   SubMList* subform = new SubMList;
   subform -> m_pList = s_pList;

   PopSemanticLevel();
   if (s_pList -> size() == 0){
      Noad* pNoad = new Noad;
      pNoad -> m_nucleus = subform;
      s_pList -> push_back(pNoad);
      return;
   }
   TeXNode* node = s_pList -> back();
   Noad* noad = dynamic_cast<Noad*>(node);
   if (noad == 0){
      Noad* pNoad = new Noad;
      pNoad -> m_nucleus = subform;
      s_pList -> push_back(pNoad);
      return;
   }
   if (noad != 0){
      switch (s_target){
         case TARG_NUCLEUS :
            noad -> m_nucleus = subform;
            break;
         case TARG_SUBSCRIPT:
            noad -> m_subscript = subform;
            break;
         case TARG_SUPERSCRIPT:
            noad -> m_superscript = subform;
            break;
      }
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro




\fwbeginmacro
\fwmacroname{Typesetter implementation}{809}\fwplusequals \fwodef \fwbtx[void Typesetter::SetSpace()
{
  if (Global::msioutput == 0){
     ASSERT(s_mode = MODE_HORIZONTAL);
     GlueNode* ch = new GlueNode();
     s_pList -> push_back(ch);
  }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{810}\fwplusequals \fwodef \fwbtx[
void Typesetter::PrintMainList(std::ostream& outs)
{
   // This may be called after a crash so we'll have
   // to print the lists saved on the stack.
   OutputStream out(outs);
   std::list<SemanticLevel*>::const_iterator it;
   it = semanticNest.begin();
   while (it != semanticNest.end()){
      (*it) -> m_pList -> Print(out);
      ++it;
   }
   s_pList -> Print(out);
   out.Flush();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Typesetter implementation}{811}\fwplusequals \fwodef \fwbtx[void Typesetter::StartAlignment()
{
   LOG("\n----Typesetter::StartAlignment");
   PushSemanticLevel();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{812}\fwplusequals \fwodef \fwbtx[void Typesetter::EndAlignment()
{
   LOG("\n----Typesetter::EndAlignment");
   AlignmentNode* pNode = new AlignmentNode;
   pNode -> m_pList = s_pList;
   PopSemanticLevel();
   s_pList -> push_back(pNode);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Typesetter implementation}{813}\fwplusequals \fwodef \fwbtx[void Typesetter::StartCol()
{
   PushSemanticLevel();
}

void Typesetter::EndCol()
{
   AlignCellNode* cell = new AlignCellNode;
   cell -> m_pList = s_pList;
   PopSemanticLevel();
   s_pList -> push_back(cell);
}

void Typesetter::StartRow()
{
   PushSemanticLevel();
}

void Typesetter::EndRow()
{
   AlignRowNode* pRow = new AlignRowNode;
   pRow -> m_pList = s_pList;
   PopSemanticLevel();
   s_pList -> push_back(pRow);
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 687, 690, 692, 693, 694, 696, 698, 700, 702, 705, 707, 709, 717, 718, 725, 726, 729, 730, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 793, 794, 795, 796, 797, 798, 799, 800, 801, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812 and 813.}
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{SetRule}{814}\fwequals \fwodef \fwbtx[//void Typesetter::SetRule(RuleSpec* pSpec)
//{
//    // TTP 1056
//    append(pSpec);
//    if (mode == VMODE){
//       prev_depth = ignore_depth;
//    else if (mode == HMODE){
//       space_factor = 1000;
//    }
//}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 776.}
\fwendmacronotes
\fwendmacro





\fwseca{20}{The main program}


\fwbeginmacro
\fwfilename{tex.cpp}{815}\fwequals \fwodef \fwbtx[#include "platform.h"
#include "textio.h"
#include "symbols.h"
#include "tokens.h"
#include "basicdata.h"
#include "scanutils.h"
#include "expandables.h"
#include "conditionals.h"
#include "typesetter.h"
#include "interpretter.h"

#include <iostream>
#include <fstream>

extern void SetupExpandables();
std::string s_tapfilename;
std::ofstream s_tapfile;
bool s_bTapped;
extern Typesetter ts;

const char* s_inputfilename;
char* s_mmldirname = ".";

void usage()
{
  std::cout <<
    "usage: pretex [-i <dir>] [-f <format file>] [-h] "
        "[-c<codepage>] "
        "<input file> <output file>\n"
    "   -h        Print this text.\n"
    "   -i <dir>   The directory where the pretex formats"
    " and style files are (defaults to MSITEXINPUT evironment variable.\n"
    "   -f <file>  The format file to use (defaults to msilatex.tex).\n"
    "   -o <dir>   The directory in which to put auxiliary files,"
                " such as .css.\n"
    "   -m <dir>   The directory containing mmldll.dll "
    "and its auxiliary .gmr files.\n"
    "   -c<multibyte codepage> e.g. -cp932.\n";
  exit(1);
}


int main(int argc, char* argv[])
{
   // Check for -h, /h
   for (int k = 0; k < argc; ++k){
      if (argv[k][0] == '-' || argv[k][0] == '/'){
         if (strlen(argv[k]) > 1 && argv[k][1]=='h')usage();
      }
   }

   if (argc <= 3){
      std::cout << "\nMissing argument\n";
      usage();
   }

   int argn = 1;
   InitData();
   InitTokens();
   Interpretter::InitializeSymbolTable();
   InitializeKeywords();
   SetupExpandables();
   InitConditionalSymbols();
   SetCWD();

   // Set up tex input directory
   char envInput[_MAX_PATH+12];
   char envOutput[_MAX_PATH+12];
   strcpy(envInput, "MSITEXINPUT=");
   strcpy(envOutput, "MSIOUTPUT=");
   for (int j = 0; j < argc; ++j)
   {
      if (argv[j][0] == '-')
      {
        if (argv[j][1]=='i')
        {
         char* inputdir = strdup(argv[j+1]);
         // check for double quotes around the path
         if (inputdir[0]=='"') inputdir++;
         if (inputdir[strlen(inputdir)-1]=='"')
            inputdir[strlen(inputdir)-1] = '\0';
         strcat(envInput, inputdir);
         _putenv(envInput);
         std::cout << "Set input environment " << envInput << "\n";
         delete inputdir;
        }
        else if (argv[j][1]=='o')
        {
          char* outputdir = strdup(argv[j+1]);
          // check for double quotes around the path
          if (outputdir[0]=='"') outputdir++;
          if (outputdir[strlen(outputdir)-1]=='"')
           outputdir[strlen(outputdir)-1] = '\0';
          strcat(envOutput, outputdir);
          _putenv(envOutput);
          std::cout << "Set output environment " << envOutput << "\n";
          delete outputdir;
        }
        else if (argv[j][1]=='m')
        {
          s_mmldirname = strdup(argv[j+1]);
          std::cout << "Set mmldirname to " << s_mmldirname << "\n";
        }
      }
   }

   // Read a "format" file
   const char* format = "msilatex.tex";
   for (int i = 0; i < argc; ++i){
      if (argv[i][0] == '-'){
         if (strlen(argv[i]) > 1 && argv[i][1]=='f'){
           format = argv[i+1];
         }
      }
   }
   LOG("\nReading format file " << format);
   Filename fn0(format, true);
   InputByteFile* pbf0 = new InputByteFile;
   if (!pbf0 -> Open(fn0)){
      std::cout << "\nFailed to open format file: " << format<<"\n";
      usage();
   }
   Latin_1_in*  platin1filt0 = new Latin_1_in(*pbf0);
   LineSource* plineSource0 = new LineSource(*platin1filt0);

   Tokenizer* toks0 = new Tokenizer(plineSource0);
   InputStack::Push(toks0);

   Interpretter::MainLoop();

   try{
      s_inputfilename = argv[argc-2];
      LOG("\nReading input file " << s_inputfilename);
      Filename fn(s_inputfilename, true);
      InputByteFile* pbf = new InputByteFile;
      pbf -> Open(fn);

      // // Open a tap file for holding defs
      // std::string tappath = fn.GetAreaString();
      // s_tapfilename = fn.GetNameString();
      // s_tapfilename += "-defs.tex";
      // tappath += s_tapfilename;
      // s_tapfile.open(tappath.c_str());

      s_bTapped = false;
      const char* filter = "latin1";
      for (int i = 0; i < argc; ++i){
         if (argv[i][0] == '-'){
            if (strlen(argv[i]) > 2 && argv[i][1]=='c'){
              filter = &argv[i][2];
            }
         }
      }
      LineSource* plineSource;
      if (strcmp(filter, "p932")==0){
         Codepage932_in*  pcp932filt = new Codepage932_in(*pbf);
         plineSource = new LineSource(*pcp932filt);
      }else if (strcmp(filter, "p936")==0){
         Codepage936_in*  pcp936filt = new Codepage936_in(*pbf);
         plineSource = new LineSource(*pcp936filt);
      }else if (strcmp(filter, "p949")==0){
         Codepage949_in*  pcp949filt = new Codepage949_in(*pbf);
         plineSource = new LineSource(*pcp949filt);
      }else if (strcmp(filter, "p950")==0){
         Codepage950_in*  pcp950filt = new Codepage950_in(*pbf);
         plineSource = new LineSource(*pcp950filt);
      }else{
         Latin_1_in* platin1filt = new Latin_1_in(*pbf);
         plineSource = new LineSource(*platin1filt);
      }

      Tokenizer* toks = new Tokenizer(plineSource);
      InputStack::Push(toks);
      Interpretter::MainLoop();
   }
   catch(...){
      LOG("\n!!! FILTER CRASHED !!! -- will attempt output");
      std::cout << "\n!!! FILTER CRASHED !!! -- will attempt output";
   }
   LOG("\nWriting output file " << argv[argc-1]);
   const char* outfilename = argv[argc-1];
   std::ofstream outfile(outfilename);
   Typesetter::PrintMainList(outfile);
   return 0;
}

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro

\fwseca{21}{Line breaking}

\fwsecb{21.1}{Interface}


\fwsecb{21.2}{Physical layout}
\fwbeginmacro
\fwfilename{linebreak.h}{816}\fwequals \fwodef \fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwfilename{linebreak.cpp}{817}\fwequals \fwodef \fwmacroname{class ActiveNode}{818}\fwbtx[
]fwetx=%
\fwmacroname{class PassiveNode}{819}\fwbtx[
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{class ActiveNode}{818}\fwequals \fwodef \fwbtx[class ActiveNode {
   PassiveNode* m_breakPoint;
   int          m_lineNuber;
   int          m_fitness;
   int          m_hyphenType;
   int          m_totalDemerits;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 817.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{class PassiveNode}{819}\fwequals \fwodef \fwbtx[class PassiveNode {
   TeXNode* m_breakPoint; // Pointer into the hlist
   CurrBreak;
   PrevBreak;
   Serial;
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 817.}
\fwendmacronotes
\fwendmacro

\fwseca{22}{Tables and alignment}

\fwseca{23}{User Interface}

The user interface lets you control and monitor the operation of \TeX.
It provides the usual debugging facilities.



\def\nt#1{{\tt <#1>}}



\nt{space token} is a token resulting from a category 10 character,
or a control sequence that has been \fwlit{\char`\\let} or \fwlit{\char`\\futerlet} to such a token.

\nt{plus} = $+_{12}$ (a plus sign with category code 12)

\nt{minus} = $-_{12}$ (a minus sign with category code 12)

\nt{apostrophe} = '$_{12}$

\nt{double quote} = "$_{12}$

\nt{quote} = `$_{12}$


\nt{optional spaces} -> \nt{empty} | \nt{space token} \nt{optional spaces}





\bye


%*******************************************************************************
%*                    END OF AUTOMATICALLY GENERATED TEX FILE                  *
%*******************************************************************************

