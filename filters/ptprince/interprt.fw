@p maximum_input_line_length = 150
@p maximum_output_line_length = 150


@A@<The Command Interpreter@>

The Command Interpreter contains the main loop of \TeX{}. It gets
unexpandable tokens from the macro processor and parses tokens until
a command is recognized. The command is executed immediately.
Most commands will be addressed to the Typesetter, but not all.
Some, e.g. @{\catcode@} are addresed to the text io subsystem.
Some change the state of the command interpreter itself.

@$@<class Interpreter@>==@{@-
class Interpretter {
public:
   static void InitializeSymbolTable();
   static void MainLoop();
};
@}


@$@<InitializeSymbolTable@>==@{@-
void Interpretter::InitializeSymbolTable()
{
   @<Create symbols@>
}
@}



Here are some variables global to the interpreter
@$@<Declare interpreter global variables@>+=@{@-
//static CommandCode curcmd;
//static Primitive* curcmddata;
extern const char* s_outputdir;
extern const char* s_docdir;
extern std::string s_preambleExtra;
@}

@$@<A string function that should go elsewhere@>==@{@-
void find_and_replace(std::string& str, const char* srch, const char*repl)
{
   int p = str.find(srch);
   while (p != -1){
     str.replace(p, strlen(srch), repl);
     p = str.find(srch);
   }
}

void strip_quotes(std::string& str){
  if (str[0] == '\"' || str[0] == '\''){
     str = str.substr(1,str.size()-2);
  }
}

std::string get_number(std::string s)
{
    int unitPos = s.find_first_not_of("0123456789.");
    if (unitPos != -1){
       return s.substr(0,unitPos);
    } else 
       return s;
}

std::string get_units(std::string s)
{
   std::string unit = "in";
   int unitPos = s.find_first_not_of("0123456789.");
   if (unitPos != -1){
      unit = s.substr(unitPos);
   }
   return unit;
}



std::string simple_math_to_mathml(std::string str){
      std::string mml;
      SetupMathML();
      std::string s_mathml;
      std::string s_anom;
      std::string tex = "$";
      tex += str;
      tex += "$";
      ProcessMathML(tex.c_str(), s_mathml, s_anom);
      mml = s_mathml;
      s_mathml = "";
      TakeDownMathML();
      return mml;
}

std::string makexml(std::string str){
  std::string::iterator it = str.begin();
  std::string rv;

  while (it != str.end()){
    if (*it == '&'){
      rv += "&amp;";
    } else if (*it == '<'){
      rv += "&lt;";
    } else if (*it == '>'){
      rv += "&gt;";
    } else {
      rv += *it;
    }
    ++it;
  }
  return rv;
}

@}

@$@<Graphic file utility@>+=@{
std::string NormalizeSlashes(const char* str)
{
   char* strcopy = new char[strlen(str) + 1];
   for (int i = 0; i < strlen(str) + 1; ++i)
   {
      if (str[i] == '\\' || str[i] == '/'){
        strcopy[i] = SEP;
      } else {
        strcopy[i] = str[i];
      }
   }
   return std::string(strcopy);
}
@}

@$@<Graphic file utility@>+=@{
std::string MaybeCopyGraphicFile(const char* fullname)
{
   // 1. Get the search paths
   StringUtils::AppendToks(Global::msigraphicspath);
   String str = StringBuilder::Create();
   std::string paths;
   int i = 0;
   while (i < str.Size()){
       paths += (char) str[i];
       ++i;
   }

   StringBuilder::Discard(str);

   Filename fn(fullname, true);
   std::string graphic;
   std::string extn = fn.GetExtString();
   if (extn != "") {
        // assume everything relative for now
        // relative path?
        graphic = s_docdir;
        graphic += SEP;
        graphic += fullname;
   } else {
          // No extension.
          const char* exts[] = {".png", ".jpg", ".pdf", NULL};
          int i = 0;

          while (exts[i] != NULL){
            std::string name = fullname;
            name += exts[i];

            char buf[_MAX_PATH];

            SearchEnv(name.c_str(), paths.c_str(), false, buf);
            if (strlen(buf) != 0) {
               // found it
               graphic = buf;
               break;
            }
            ++i;
          }

      }

      // Copy the graphic to <docdir>/graphics
      LOG("\n---- Copy " << graphic.c_str());

      std::string targetdir;
      if (s_outputdir != 0)
        targetdir = s_outputdir;

      if (extn == "xvz") {
         targetdir += SEP;
         targetdir += "plots";
         targetdir += SEP;
      } else {
         targetdir += SEP;
         targetdir += "graphics";
         targetdir += SEP;
      }

      std::string target = targetdir;
      target += fn.GetNameString();
      target += ".";
      target += fn.GetExtString();

      LOG("\n---- To " << target.c_str());

      // Copy the file

      FILE* graphfile = fopen(graphic.c_str(), "rb");
      FILE* targetfile = fopen(target.c_str(), "wb");

      if (graphfile && targetfile){
          LOG("\n---- Files Open");
          int ch = fgetc(graphfile);
          while (ch != EOF){
             fputc(ch, targetfile);
             ch = fgetc(graphfile);
          }
      }

      if (graphfile) fclose(graphfile);
      if (targetfile) fclose(targetfile);


      std::string reltarget;
      if (extn == "xvz") {
         reltarget += "plots";
         reltarget += SEP;
      } else {
         reltarget += "graphics";
         reltarget += SEP;
      }

      reltarget += fn.GetNameString();
      reltarget += ".";
      reltarget += fn.GetExtString();
      std::string::iterator it;
      for (it = reltarget.begin(); it != reltarget.end(); ++it){
         if (*it == '\\') 
           *it = '/';
      }
      return reltarget;
  }
@}

@$@<Functions for inserting primitive hooks@>+=@{
void hookA(const char* cmd)
{
   std::string idstr;
   idstr = "msi@@hook@@";
   idstr += cmd;

   TeXToken tt;
   String str = StringBuilder::Create(idstr.c_str());
   // lookup cs in symbols table
   Symbols::SymId id;
   Symbols::GetId(str, &id, Symbols::CREATE);
   tt.SetType(TT_SYMBOL);
   tt.SetSymbol(id);
   inp.Putback(tt);
}
@}


@B@<Main Loop@>
Here is the main loop. It fetches a token and jumps to a case in a
big switch statement. The case depends also on the current mode.
The case will parse the rest of the command and execute it.
The action will likely include more parsing to get the arguments
for the command.


@$@<Main Loop@>==@{@-
void Interpretter::MainLoop()
{
 frozen_relax->AddRef();
 bool running = true;
 while (running && !inp.bEmpty()) {
   LOG("\n----Start cycle");
   GetToken();
   DetermineCommandCode();
   @<Execute the command@>
 }
}
@}

Each command processed by the command interpreter has a code
that is listed in the enumerated type @{CommandCode@}.



@$@<Execute the command@>==@{@-
   switch (CurCmdCode()) {
      @<Node creation commands@>
      @<Prefix commands@>
      @<Basic assignment commands@>
      @<Macro definition commands@>
      @<Assign box dimension commands@>
      @<Register commands@>
      @<Box building commands@>
      @<Unboxing commands@>
      @<Message commands@>
      @<Stop commands@>
      @<Grouping commands@>
      @<Font commands@>
      @<Math commands@>
      @<Misc commands@>
      @<Extensions@>
      case CMD_NONE:{
        if (CurTok().Type() == TT_PARAM){
           // a stray #, just copy it 
           Typesetter::AppendTag("#");
        } else {
           LOG("\n----" << CurTok()
                        << " ERROR -- no command code.");

           std::cout << "\n-- Passing through: " ;
           String s = Symbols::GetName(CurTok().Symbol());
           std::cout << "\\";
           for (int i = 0; i < s.Size(); ++i){
             if (s[i] >= 32 && s[i] <= 126){
                std::cout << (char) s[i];
             } else {
                std::cout << "[chr " << (int) s[i] << "]";
             }
           }
           // Give it a default definition and put back the token
           TokenList* pTokenList = new TokenList;
           pTokenList -> push_back(TeXToken(TT_END_MATCH,0,0));

           pTokenList -> AppendSymbol("msidefault");
           pTokenList -> push_back(TeXToken(TT_LEFT_BRACE,'{',0));
           pTokenList -> push_back(TeXToken(CurTok()));
           pTokenList -> push_back(TeXToken(TT_RIGHT_BRACE,'}',0));
           MacroDef* pMacroDef = new MacroDef(pTokenList);

           Symbols::SetDef(CurTok().Symbol(), pMacroDef, false);
           // Now rescan the newly defined token
           inp.Putback(CurTok());

           //  // Let's just append the token to the
           //  // output stream, and assume we go to hmode
           //  if (Typesetter::GetMode() == MODE_VERTICAL){
           //     Typesetter::GotoHMode();
           //     Typesetter::SetInner(false);
           //     inp.Putback(Global::msieverypar);
           //     inp.Putback(Global::everypar);
           //  }
        }
        break;
      }
      default:
        LOG("\n----" << CurTok()
                     << " ERROR -- can't happen");
        break;
   }
@}



The command interpreter must maintain a stack that records the current
level and type of level.

@$@<GroupStack@>+=@{@-
enum GroupType {
       SIMPLE_GROUP,
       SEMISIMPLE_GROUP,
       ALIGN_GROUP,
       HBOX_GROUP,
       VBOX_GROUP,
       INLINE_GROUP,  // for $...$
       DISPLAY_GROUP, // for $$...$$
       MATH_GROUP,    // for {...} inside math
       PROCESS_GROUP
     };
@}

@$@<GroupStack@>+=@{@-
struct GroupRecord {
   GroupType  m_groupType;
   TokenList* m_afterGroup;
   Mode m_mode;
};

const int MAX_GROUPS = 400;
static GroupRecord s_groupStack[MAX_GROUPS];
static int s_groupStackTop = -1;
@}

@$@<GroupStack@>+=@{@-
void ShowGroupStack()
{
   LOG("\nGroups: ");
   int lev = s_groupStackTop;
   while (lev >= 0){
      GroupType type = s_groupStack[lev].m_groupType;
      if (type == HBOX_GROUP){
         LOG("hbox ");
      } else if (type == VBOX_GROUP){
         LOG("vbox ");
      } else if (type == SIMPLE_GROUP){
         LOG("simple ");
      } else if (type == SEMISIMPLE_GROUP){
         LOG(" semi-simple ");
      }  else if (type == INLINE_GROUP){
         LOG("inline ");
      }  else if (type == DISPLAY_GROUP){
         LOG("display ");
      }  else if (type == MATH_GROUP){
         LOG("subformula ");
      }  else if (type == ALIGN_GROUP){
         LOG("align ");
      } else if (type == PROCESS_GROUP){
         LOG("process ");
      } else {
         LOG("ERROR");
      }
      --lev;
   }
}
@}

@$@<GroupStack@>+=@{@-
void NewLevel(GroupType type)
{
   if (s_groupStackTop < MAX_GROUPS){
      ++s_groupStackTop;
      s_groupStack[s_groupStackTop].m_groupType = type;
      s_groupStack[s_groupStackTop].m_afterGroup = 0;
      s_groupStack[s_groupStackTop].m_mode = Typesetter::GetMode();
      NewSaveLevel();
      if (type == HBOX_GROUP){
         LOG("\n----Begin group: hbox ");
      } else if (type == VBOX_GROUP){
         LOG("\n----Begin group: vbox");
      } else if (type == SIMPLE_GROUP){
         LOG("\n----Begin group: simple");
      } else if (type == SEMISIMPLE_GROUP){
         LOG("\n----Begin group: semi-simple");
      }  else if (type == INLINE_GROUP){
         LOG("\n----Begin group: inline math");
      }  else if (type == DISPLAY_GROUP){
         LOG("\n----Begin group: display math");
      }  else if (type == MATH_GROUP){
         LOG("\n----Begin group: math subformula");
      }  else if (type == ALIGN_GROUP){
         LOG("\n----Begin group: align");
      } else if (type == PROCESS_GROUP){
         LOG("\n----Begin group: process");
      } else {
         LOG("\nERROR -- begin unknown group type");
      }
      ShowGroupStack();

   } else {
      ASSERT(false);
   }
}
@}


@$@<GroupStack@>+=@{@-
bool bCurrentLevelType(GroupType type){
   return s_groupStack[s_groupStackTop].m_groupType == type;
}
@}


@$@<GroupStack@>+=@{@-
void EndLevel()
{
   if (s_groupStackTop < 0){
      ASSERT(false);
   } else {
      if (bCurrentLevelType(HBOX_GROUP)){
         LOG("\n----End group: hbox");
         Typesetter::EndBox();
      } else if (bCurrentLevelType(VBOX_GROUP)){
         LOG("\n----End group: vbox");
         Typesetter::EndBox();
      } else if (bCurrentLevelType(SIMPLE_GROUP)){
         LOG("\n----End group: simple");
      } else if (bCurrentLevelType(SEMISIMPLE_GROUP)){
         LOG("\n----End group: semi-simple");
      } else if (bCurrentLevelType(INLINE_GROUP)){
         LOG("\n----End group: inline");
         Typesetter::EndInline();
      } else if (bCurrentLevelType(DISPLAY_GROUP)){
         LOG("\n----End group: dispaly");
         Typesetter::EndDisplay();
      } else if (bCurrentLevelType(MATH_GROUP)){
         Typesetter::EndSubformula();
         LOG("\n----End group: math subformula");
      } else if (bCurrentLevelType(ALIGN_GROUP)){
         LOG("\n----End group: align");
      } else if (bCurrentLevelType(PROCESS_GROUP)){
         Typesetter::EndProcess();
         LOG("\n----End group: process");
      } else {
         LOG("\n----End unknown group type");
         ASSERT(false);
      }
      EndSaveLevel();
      // Push the aftergroup tokens.
      TokenList* afterGroup = s_groupStack[s_groupStackTop].m_afterGroup;
      if (afterGroup != 0){
         InputStack::Putback(*afterGroup);
      }
      --s_groupStackTop;
      Typesetter::SetMode(s_groupStack[s_groupStackTop].m_mode);
      ShowGroupStack();
   }
}
@}


@$@<GroupStack@>+=@{@-
void ClearLevels()
{
  while (s_groupStackTop >= 0){
    EndLevel();
  }
}
@}


@B@<Some debugging aids@>

\noseealso

@$@<Command Codes@>+=@{@-
CMD_BREAKPOINT,
CMD_CHECKOUTER,
CMD_MSITRACEON,
CMD_MSITRACEOFF,
CMD_MSIPREAMBLEEXTRA,
CMD_MSITOPREAMBLEEXTRA,
CMD_MSISPECIAL,
CMD_MSISPECIALVALUE,
CMD_MSIPREAMBLE,
@}


\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("msibreak", CMD_BREAKPOINT);
NewPrimitive("msicheckouter", CMD_CHECKOUTER);
NewPrimitive("msitraceon", CMD_MSITRACEON);
NewPrimitive("msitraceoff", CMD_MSITRACEOFF);
NewPrimitive("msipreambleextra", CMD_MSIPREAMBLEEXTRA);
NewPrimitive("msitopreambleextra", CMD_MSITOPREAMBLEEXTRA);
NewPrimitive("msispecial", CMD_MSISPECIAL);
NewPrimitive("msispecialvalue", CMD_MSISPECIALVALUE);
NewPrimitive("msipreamble", CMD_MSIPREAMBLE);
@}


@$@<Misc commands@>+=@{@-
case CMD_BREAKPOINT : {
   LOG("\nSet breakpoint here");
   break;
}

case CMD_CHECKOUTER: {
   if (s_groupStackTop != -1){
     LOG("\nERROR -- Check outer failed.");
     ShowGroupStack();
     ASSERT(false);
   }
   break;
}

case CMD_MSITRACEON:{
  #ifdef LOGGING
     LogFile::TheLog().TurnOn();
  #endif
  break;
}

case CMD_MSITRACEOFF:{
  #ifdef LOGGING
     LogFile::TheLog().TurnOff();
  #endif
  break;
}

case CMD_MSIPREAMBLEEXTRA:{
  Typesetter::AppendTag(s_preambleExtra.c_str());
  break;
}

case CMD_MSITOPREAMBLEEXTRA:{
  TokenList* tl = new TokenList;
  ScanTokenList(tl, false);
  StringUtils::AppendToks(*tl);
  String str = StringBuilder::Create();

  int i = 0;
  while (i < str.Size()){
     s_preambleExtra += (char) str[i];
     ++i;
  }

  StringBuilder::Discard(str);

  delete tl;
  break;
}

case CMD_MSIPREAMBLE: {
  TokenList* tl = new TokenList;
  ScanTokenList(tl, false);
  StringUtils::AppendToks(*tl);
  String str = StringBuilder::Create();
  std::string preamble;
  int i = 0;
  while (i < str.Size()){
     preamble += (char) str[i];
     ++i;
  }
  StringBuilder::Discard(str);
  delete tl;
  
  std::string usepackages;
  std::string rest;

  size_t q = 0;
  size_t p = preamble.find("\\usepackage");
  
  while (p != std::string::npos){
    q = p+11;
    p = preamble.find("\\usepackage", p+11);
  }
  // now q points at last usepackage
  // look for next command
  q = preamble.find("\\", q);
  if (q == std::string::npos){
     usepackages = preamble.substr(0);
     rest = "";
  } else {
     usepackages = preamble.substr(0, q);
     rest = preamble.substr(q);
  }
 

  // Convert <usepackage>
  q = std::string::npos;
  p = usepackages.find("\\usepackage");
  while (p != std::string::npos){
    q = p+11;
    p = usepackages.find("\\usepackage", p+11);
    std::string opt;
    std::string req;
    if (usepackages[q] == ' ')
      q++;
    if (usepackages[q] == '[') {
      q++;
      while (usepackages[q] != ']'){
        opt += usepackages[q];
        ++q;
      }
      ++q;
    }
    if (usepackages[q] == ' ')
      q++;
    if (usepackages[q] == '{') {
      q++;
      while (usepackages[q] != '}'){
        req += usepackages[q];
        ++q;
      }
      ++q;
     
    }
    std::string up = "<usepackage req=\"";
    up += req;
    up += "\"";
    if (opt != ""){
      up += " opt=\"";
      up += opt;
      up += "\"";
    }
    up += "/>";
    Typesetter::AppendTag(up.c_str());
    req += ".sty";
    Filename fn(req.c_str());
    ProcessFile(fn);
  }

  std::string preambletex =
     "<preambleTeX><![CDATA[\n";
  preambletex += rest;
  preambletex +="]]></preambleTeX>\n";
  Typesetter::AppendTag(preambletex.c_str());
  break;

}

case CMD_MSISPECIAL: {
  std::map<std::string,std::string> kvmap;
  TokenList* tlpos = new TokenList;
  TokenList* tl = new TokenList;
  ScanTokenList(tl, false);
  ScanTokenList(tlpos, false);
  StringUtils::AppendToks(*tl);
  String str = StringBuilder::Create();
  std::string strTemp;
  int i = 0;
  while (i < str.Size()){
      strTemp += (char) str[i];
      ++i;
  }
  StringBuilder::Discard(str);

  StringUtils::AppendToks(*tlpos);
  str = StringBuilder::Create();
  std::string strTemppos;
  i = 0;
  while (i < str.Size()){
      strTemppos += (char) str[i];
      ++i;
  }
  StringBuilder::Discard(str);
  

  // Break the content of special into name, value pairs
  i=0;
  while (i < strTemp.size()){
    int nameBegin = strTemp.find_first_not_of(" \r\n\t", i);
    int nameEnd = strTemp.find_first_of(" \r\n\t", nameBegin);
    std::string name = strTemp.substr(nameBegin, nameEnd - nameBegin);
    std::string value;
    int valueBegin = strTemp.find_first_not_of(" \r\n\t", nameEnd);
    int valueEnd = 0;
    if (strTemp[valueBegin] != '\\'){
      valueEnd = strTemp.find_first_of(";", valueBegin);
      value = strTemp.substr(valueBegin, valueEnd - valueBegin);
    } else {
      // A \TEXUX...; value
      valueBegin = strTemp.find_first_of("{", valueBegin);
      if (strTemp[valueBegin+1] == '$'){
         valueBegin = valueBegin+1;
         valueEnd = strTemp.find_first_of("$", valueBegin+1);
         value = strTemp.substr(valueBegin, valueEnd - valueBegin + 1);
         valueEnd = strTemp.find_first_of(";", valueEnd);
         SetupMathML();
         std::string s_mathml;
         std::string s_anom;
         ProcessMathML(value.c_str(), s_mathml, s_anom);
         value = s_mathml;
         s_mathml = "";
         TakeDownMathML();

      } else {
         valueBegin = 1 + strTemp.find_first_of("{", valueBegin);
         valueEnd  = -1 + strTemp.find_first_of("}", valueBegin+1);
         value = strTemp.substr(valueBegin, valueEnd - valueBegin + 1);
         valueEnd = strTemp.find_first_of(";", valueEnd);
      }
    }
    kvmap[name] = value;
    i = valueEnd+1;
  }

  std::string result;
  if ((kvmap["type"] == "\"PLOT\"") || (kvmap["type"] == "\"MAPLEPLOT\"")) {
     result =
"<graph>\
   <graphSpec ImageFile=\"%ImageFile%\" \
 XAxisLabel=%xaxislabel%\
 YAxisLabel=%yaxislabel%\
 ZAxisLabel=%zaxislabel%\
 Width=\"%width%\" \
 Height=\"%height%\"\
 Units=\"%unit%\" \
 XTickCount=\"0\" YTickCount=\"0\" ZTickCount=\"0\"\
 BGColor=\"#FFFFFF\" Dimension=\"2\" \
 AxisFontFamily=\"sans-serif\" AxisFontSize=\"10\" \
 AxisFontColor=\"#000000\"  AxisFontItalic=\"false\" \
 AxisFontBold=\"false\" TicksFontFamily=\"sans-serif\" \
 TicksFontSize=\"8\" TicksFontColor=\"#000000\"\
 TicksFontItalic=\"false\"\
 TicksFontBold=\"false\" errStr=\"\" \
 ViewingBoxXMin=\"-6.000000001e0\"\
 ViewingBoxXMax=\"6.000000001e0\" ViewingBoxYMin=\"-9.998181315e-1\"\
 ViewingBoxYMax=\"9.998181315e-1\"\
 CaptionPlace=\"labelabove\" \
 EqualScaling=\"false\" AxesTips=\"false\" GridLines=\"false\" \
 OrthogonalProjection=\"false\" KeepUp=\"false\">\
 <plot xmlns=%mathmlns% \
 PlotType=\"rectangular\" LineStyle=\"Solid\" PointStyle=\"Dot\" \
 LineThickness=\"thin\" LineColor=\"#000000ff\" DiscAdjust=\"true\"\
 BaseColor=\"#ff0000ff\" SecondaryColor=\"#0000ffff\" \
 PointSymbol=\"FilledCircles\" Animate=\"false\" PlotStatus=\"undefined\">\
 <Expression><math xmlns=%mathmlns%>%function%</math></Expression>\
 <XMax><math xmlns=%mathmlns%>%xmax%</math></XMax>\
 <XMin><math xmlns=%mathmlns%>%xmin%</math></XMin>\
 <XVar><math xmlns=%mathmlns%>%xvar%</math></XVar>\
 <XPts><math xmlns=%mathmlns%><mn>30</mn></math></XPts>\
 </plot></graphSpec>\
 <msiframe pos=\"display,,I\" sidemargin=\"0.3\" topmargin=\"0.15\"\
 placeLocation=\"h\" textalignment=\"\" width=\"3.46\" height=\"4.96\"\
 units=\"cm\" style=\"margin: 5.66929px 11.3386px; width: 130.772px; \
 height: 187.465px;\">\
 <object data=\"%ImageFileFull%\"\
   type=\"application/x-mupad-graphics+xml\" alt=\"Generated Plot\" \
   msigraph=\"true\" style=\"width: 113.386px; height: 170.079px;\"/>\
 </msiframe></graph>";
    
        // search and replace
        find_and_replace(result, "%mathmlns%",
                                 "\"http://www.w3.org/1998/Math/MathML\"");

        find_and_replace(result, "%mozns%",
        "\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"");

        std::string name = kvmap["VCamFile"];
        strip_quotes(name);
        std::string newname = MaybeCopyGraphicFile(name.c_str());
        find_and_replace(result, "%ImageFile%", NormalizeSlashes(makexml(newname).c_str()).c_str());

        std::string fullname = newname;
        find_and_replace(result, "%ImageFileFull%", NormalizeSlashes(makexml(fullname).c_str()).c_str());

        find_and_replace(result, "%function%", kvmap["function"].c_str());

        strip_quotes(kvmap["xmin"]);
        std::string xmin = simple_math_to_mathml(kvmap["xmin"]);
        find_and_replace(result, "%xmin%", xmin.c_str());

        strip_quotes(kvmap["xmax"]);
        std::string xmax = simple_math_to_mathml(kvmap["xmax"]);
        find_and_replace(result, "%xmax%", xmax.c_str());

        find_and_replace(result, "%xvar%", kvmap["var1name"].c_str());

        if (kvmap.find("x-label") != kvmap.end()){
           find_and_replace(result, "%xaxislabel%", kvmap["x-label"].c_str());
        } else {
           find_and_replace(result, "%xaxislabel%", "\"x\"");
        }
        if (kvmap.find("y-label") != kvmap.end()){
           find_and_replace(result, "%yaxislabel%", kvmap["y-label"].c_str());
        } else {
           find_and_replace(result, "%yaxislabel%", "\"y\"");
        }
        if (kvmap.find("z-label") != kvmap.end()){
           find_and_replace(result, "%zaxislabel%", kvmap["z-label"].c_str());
        } else {
           find_and_replace(result, "%zaxislabel%", "\"z\"");
        }
        std::string unit = "in";
        if (kvmap.find("width") != kvmap.end()){
           std::string dim = kvmap["width"];
           int unitPos = dim.find_first_not_of("0123456789.");
           unit = dim.substr(unitPos);
           std::string width = dim.substr(0,unitPos);
           find_and_replace(result, "%unit%", unit.c_str());
           find_and_replace(result, "%width%", width.c_str());
        } else {
           find_and_replace(result, "%width%", "3");
        }

        if (kvmap.find("height") != kvmap.end()){
           std::string dim = kvmap["height"];
           int unitPos = dim.find_first_not_of("0123456789.");
           unit = dim.substr(unitPos);
           std::string height = dim.substr(0,unitPos);
           find_and_replace(result, "%unit%", unit.c_str());
           find_and_replace(result, "%height%", height.c_str());
        } else {
           find_and_replace(result, "%height%", "3");
        }
   } else {
     // a graphic
     result = "<msiframe frametype=\"image\" \
 units=\"in\" \
 sidemargin=\"0.3\" topmargin=\"0.15\" overhang=\"0.3\" \
 borderw=\"0.03\" \
 padding=\"0.2\" \
 captionloc=\"\" \
 pos=\"%pos%\" \
 border-color=\"#000000\" \
 background-color=\"#ffffff\" \
 textalignment=\"left\" \
 width=\"%width%\" \
 height=\"%height%\" \
 style=\"border-color: rgb(0, 0, 0); border-width: 2.88px; \
 margin: 14.4px 0px 14.4px 28.8px; padding: 19.2px; \
 background-color: rgb(255, 255, 255); text-align: left;\" \
 aspect=\"false\">";

      result += "<object alt=\"\" \
 src=\"\" \
 data=\"\" \
 req=\"graphics\" \
 naturalWidth=\"%naturalWidth%\" \
 naturalHeight=\"%naturalHeight%\" \
 ltx_width=\"%width%\" \
 ltx_height=\"%height%\" \
 originalSrcUrl=\"%ImageFileFull%\" \
 copiedSrcUrl=\"%ImageFile%\" \
 msi_resize=\"true\" \
 style=\"height: %height%%units%; width: %width%%units%;\" \
 aspect=\"false\" />";
      result += "</msiframe>";

      if (strTemppos[0] == 'd'){
        find_and_replace(result, "%pos%", "center");
      } else if (strTemppos[0] == 'i'){
        find_and_replace(result, "%pos%", "inline");
      } else {
        find_and_replace(result, "%pos%", "floating");
      }

      std::string name = kvmap["filename"];
      if (name == ""){
        name = kvmap["tempfilename"];
      }

      strip_quotes(name);
      std::string newname = MaybeCopyGraphicFile(name.c_str());
      find_and_replace(result, "%ImageFile%", NormalizeSlashes(makexml(newname).c_str()).c_str());
    
      std::string fullname = std::string("file://") + s_docdir + SEP + name;
      find_and_replace(result, "%ImageFileFull%", NormalizeSlashes(makexml(fullname).c_str()).c_str());

      if (kvmap.find("original-width") != kvmap.end()){
         find_and_replace(result, "%naturalWidth%",
                    get_number(kvmap["original-width"]).c_str());
         find_and_replace(result, "%units%",
                    get_units(kvmap["original-width"]).c_str());
      } else {  
         find_and_replace(result, "%naturalWidth%",
                    get_number(kvmap["width"]).c_str());
         find_and_replace(result, "%units%",
                    get_units(kvmap["width"]).c_str());

      }
      
      find_and_replace(result, "%naturalHeight%",
               get_number(kvmap["original-height"]).c_str());
      find_and_replace(result, "%width%",
               get_number(kvmap["width"]).c_str());
      find_and_replace(result, "%height%",
               get_number(kvmap["height"]).c_str());
   }
   Typesetter::AppendTag(result.c_str()) ;
  
  break;
}

@}






@B@<Commands to insert nodes into the current list@>

@C@<Character node creation@>


\noseealso
@$@<Command Codes@>+=@{@-
CMD_LETTER,
CMD_OTHER,
CMD_CHAR,
CMD_CHAR_GIVEN,
CMD_MATH_GIVEN,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("char", CMD_CHAR);
@}

If we encounter one of these commands in either horizontal mode
or mathmode we call the typesetter's SetChar routine. Otherwise, if we
are in vertical mode, we switch to @{HMODE@} first: when a token
causes the switch to horizontal mode we first put the token back
into the input stream. It has to be interpreted
in the correct mode. Then we tell the typesetter to switch modes.
This will cause a new paragraph to start, so we also have to push the
the everypar tokens into the input stream.

@$@<Node creation commands@>+=@{@-
case CMD_LETTER :
   if (Typesetter::GetMode() == MODE_VERTICAL){
      // Goto HMODE, rescan token
      inp.Putback(CurTok());
      Typesetter::GotoHMode();
      Typesetter::SetInner(false);
      s_groupStack[s_groupStackTop].m_mode = MODE_HORIZONTAL;
      inp.Putback(Global::msieverypar);
      inp.Putback(Global::everypar);
   } else if (Typesetter::GetMode() == MODE_HORIZONTAL){
      Typesetter::SetChar(CurTok().ChrCode());
      LOG("\n----Character " << CurTok().ChrCode());
   } else if (Typesetter::GetMode() == MODE_MATH){
      if (CurTok().ChrCode() < 128){
         Typesetter::SetMathChar(CurTok().ChrCode());
      } else {
         Typesetter::SetMathChar(CurTok().ChrCode());
      }
      LOG("\n----Character " << CurTok().ChrCode());
   }
   break;
@}

@$@<Node creation commands@>+=@{@-
case CMD_OTHER :
   if (Typesetter::GetMode() == MODE_VERTICAL){
      // Goto HMODE, rescan token
      inp.Putback(CurTok());
      Typesetter::GotoHMode();
      Typesetter::SetInner(false);
      s_groupStack[s_groupStackTop].m_mode = MODE_HORIZONTAL;
      inp.Putback(Global::msieverypar);
      inp.Putback(Global::everypar);
   } else if (Typesetter::GetMode() == MODE_HORIZONTAL){
      Typesetter::SetChar(CurTok().ChrCode());
      LOG("\n----Character " << CurTok().ChrCode());
   }  else if (Typesetter::GetMode() == MODE_MATH){
      if (CurTok().ChrCode() < 128){
         Typesetter::SetMathChar(CurTok().ChrCode());
      } else {
         Typesetter::SetMathChar(CurTok().ChrCode());
      }
      LOG("\n----Character " << CurTok().ChrCode());
   }
   break;
@}

@$@<Node creation commands@>+=@{@-
case CMD_CHAR:{
   if (Typesetter::GetMode() == MODE_VERTICAL){
      // Goto HMODE, rescan token
      inp.Putback(CurTok());
      Typesetter::GotoHMode();
      s_groupStack[s_groupStackTop].m_mode = MODE_HORIZONTAL;
      Typesetter::SetInner(false);
      inp.Putback(Global::msieverypar);
      inp.Putback(Global::everypar);
   } else {
      int n;
      ScanInt(&n);
      if (Typesetter::GetMode() == MODE_HORIZONTAL){
         Typesetter::SetChar(n);
      } else if (Typesetter::GetMode() == MODE_MATH){
         if (CurTok().ChrCode() < 128){
            Typesetter::SetMathChar(n);
         } else {
            Typesetter::SetMathChar(n);
         }
      }
      LOG("\n----Character " << (TeXChar)n);
   }
   break;
}
@}


@$@<Node creation commands@>+=@{@-
case CMD_CHAR_GIVEN : {
   LOG("\n----CMD_CHAR_GIVEN");
   ASSERT(CurData());
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   Typesetter::SetChar((TeXChar) (prim -> Data()));
   break;
}
@}

@$@<Node creation commands@>+=@{@-
case CMD_MATH_GIVEN : {
   LOG("\n----CMD_MATH_GIVEN");
   ASSERT(CurData());
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   Typesetter::SetChar((TeXChar) (prim -> Data()));
   break;
}
@}


@C@<Glue creation commands@>


This is generated by a catcode 10 character. See TTP 1041-1045

\noseealso
@$@<Command Codes@>+=@{@-
CMD_SPACER,
@}


@$@<Node creation commands@>+=@{@-
case CMD_SPACER :
   if (Typesetter::GetMode() == MODE_HORIZONTAL){
      LOG("\n----Space " << CurTok().ChrCode());
      Typesetter::SetSpace();
   }
   break;
@}


The explicit space command.

\noseealso
@$@<Command Codes@>+=@{@-
CMD_EX_SPACE,
@}


\noseealso
@$@<Node creation commands@>+=@{@-
case CMD_EX_SPACE:{
   LOG("\n---- explicit space");
   ASSERT(false);
   break;
}
@}



\noseealso
@$@<Command Codes@>+=@{@-
CMD_HSKIP,
CMD_VSKIP,
CMD_MSKIP,
CMD_HFIL,
CMD_HFILL,
CMD_HFILNEG,
CMD_HSS,
CMD_VFIL,
CMD_VFILL,
CMD_VFILNEG,
CMD_VSS,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("hskip", CMD_HSKIP);
NewPrimitive("vskip", CMD_VSKIP);
NewPrimitive("mskip", CMD_MSKIP);

NewPrimitive("hfil",    CMD_HFIL);
NewPrimitive("hfill",   CMD_HFILL);
NewPrimitive("hfilneg", CMD_HFILNEG);
NewPrimitive("hss",     CMD_HSS);
NewPrimitive("vfil",    CMD_VFIL);
NewPrimitive("vfill",   CMD_VFILL);
NewPrimitive("vfilneg", CMD_VFILNEG);
NewPrimitive("vss",     CMD_VSS);

@}

@$@<Node creation commands@>+=@{@-
case CMD_VSKIP: {
   ScanGlue();
   LOG("\n----CMD_VSKIP");
   Typesetter::AppendTag("\n\n");
   break;
}

case CMD_HSKIP: {
   ScanGlue();
   LOG("\n----CMD_HSKIP");
   break;
}

case CMD_MSKIP: {
   ScanGlue();
   LOG("\n----CMD_MSKIP");
   break;
}


case CMD_HFIL:{
   LOG("\n----\\hfil");
   hookA("hfil");
   break;
}

case CMD_HFILL:{
   LOG("\n----\\hfill");
   hookA("hfill");
   break;
}
case CMD_HFILNEG:{
   LOG("\n----\\hfilneg");
   hookA("hfilneg");
   break;
}
case CMD_HSS:{
   LOG("\n----\\hss");
   hookA("hss");
   break;
}
case CMD_VFIL:{
   LOG("\n----\\vfil");
   hookA("vfil");
   break;
}
case CMD_VFILL:{
   LOG("\n----\\vfill");
   hookA("vfill");
   break;
}
case CMD_VFILNEG:{
   LOG("\n----\\vfilneg");
   hookA("vfilneg");
   break;
}
case CMD_VSS:{
   LOG("\n----\\vss");
   hookA("vss");
   break;
}


@}



@C@<Kern node creation@>


Insert a @{KernNode@} into the current list.  TTP 1057

\noseealso
@$@<Command Codes@>+=@{@-
CMD_KERN,
CMD_MKERN,
@}


\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("kern", CMD_KERN);
NewPrimitive("mkern", CMD_MKERN);
@}


@$@<Node creation commands@>+=@{@-
case CMD_KERN:{
   Scaled dim;
   ScanDim(false, false, false, &dim);
   LOG("\n----\\kern " << dim);
   break;
}
@}

@$@<Node creation commands@>+=@{@-
case CMD_MKERN:{
   Scaled dim;
   ScanDim(false, false, false, &dim);
   LOG("\n----\\mkern " << dim);
   break;
}
@}


@C@<Insert node creation@>

Insert an @{InsertNode@} into the current list.

\noseealso
@$@<Command Codes@>+=@{@-
CMD_INSERT,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("insert", CMD_INSERT);
@}

@$@<Node creation commands@>+=@{@-
case CMD_INSERT:{
   int n;
   ScanInt(&n);
   TokenList* pTL = new TokenList;
   ScanTokenList(pTL, false);
   LOG("\n---- insert " << n << " : " << *pTL);
   break;
}
@};



@C@<Create mark node@>
Insert a @{MarkNode@} into the current list.

\noseealso
@$@<Command Codes@>+=@{@-
CMD_MARK,
@}


\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("mark", CMD_MARK);
@}


@$@<Node creation commands@>+=@{@-
case CMD_MARK:{
   TokenList* pTL = new TokenList;
   ScanTokenList(pTL, false);
   LOG("\n---- mark: " << * pTL);
   break;
}
@};



@!-----------------------------------------
@! \vadjust
@!-----------------------------------------


This inserts an @{AdjustNode@} into the current list.

\noseealso
@$@<Command Codes@>+=@{@-
CMD_VADJUST,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("vadjust", CMD_VADJUST);
@}

@$@<Node creation commands@>+=@{@-
case CMD_VADJUST:{
   TokenList* pTL = new TokenList;
   ScanTokenList(pTL, false);
   LOG("\n---- vadjust: " << *pTL);
   break;
}
@};


@C@<Create penalty nodes@>

This command causes a penalty node to be inserted.

\noseealso
@$@<Command Codes@>+=@{CMD_PENALTY,@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("penalty", CMD_PENALTY);
@}

@$@<Node creation commands@>+=@{@-
case CMD_PENALTY:{
   int p;
   ScanInt(&p);
   LOG("\n---- penalty " << p);
   break;
}
@};

@C@<Create rule nodes@>

See TTP 1056

\noseealso
@$@<Command Codes@>+=@{@-
CMD_HRULE,
CMD_VRULE,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("hrule", CMD_HRULE);
NewPrimitive("vrule", CMD_VRULE);
@}

@$@<Node creation commands@>+=@{@-
case CMD_VRULE: {
   RuleSpec* rs = ScanRuleSpec();
   LOG("\n----CMD_VRULE");
   break;
}

case CMD_HRULE: {
   RuleSpec* rs = ScanRuleSpec();
   LOG("\n----CMD_HRULE");
   break;
}
@}





@!----------------------------------
@!  \end and \dump
@!----------------------------------

\noseealso
@$@<Command Codes@>+=@{@-
CMD_END,
CMD_DUMP,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("end", CMD_END);
NewPrimitive("dump", CMD_DUMP);
@}

@$@<Stop commands@>==@{@-

case CMD_DUMP: {
   LOG("\n----CMD_DUMP");
   running = false;
   break;
}

case CMD_END: {
   LOG("\n----\\end");
   running = false;
   break;
}
@}


@!-----------------------------------------
@! \/ Italic correction
@!-----------------------------------------

\cmda{\char92/ (Italic correction)}


@!-----------------------------------------
@! \- Discretionary
@!-----------------------------------------

\cmda{\char92- (Discretionary)}


\cmda{\char92discretionary (Discretionary)}

@!-----------------------------------------
@! \accent
@!-----------------------------------------

\cmd{accent}

\noseealso
@$@<Command Codes@>+=@{CMD_ACCENT,@}


@!-----------------------------------------
@! \hbox
@!-----------------------------------------

\cmd{hbox}


@!-----------------------------------------
@! \vbox
@!-----------------------------------------

\cmd{vbox}



@B@<More commands@>

@C@<Tag creating commands@>
@$@<Command Codes@>+=@{@-
CMD_TAG,
CMD_MSIHMODE,
CMD_MSIVMODE,
CMD_OPENTAG,
CMD_REQUIRETAG,
CMD_CLOSETAG,
CMD_KILLLASTTAG,
@}

@$@<Create symbols@>+=@{@-
NewPrimitive("msitag", CMD_TAG);
NewPrimitive("msihmode", CMD_MSIHMODE);
NewPrimitive("msivmode", CMD_MSIVMODE);
NewPrimitive("msiopentag", CMD_OPENTAG);
NewPrimitive("msirequiretag", CMD_REQUIRETAG);
NewPrimitive("msiclosetag", CMD_CLOSETAG);
NewPrimitive("msikilllasttag", CMD_KILLLASTTAG);
@}



@$@<TagStack@>+=@{@-
std::list<std::string> s_tagStack;
@}


@$@<Misc commands@>+=@{@-
case CMD_TAG : {
   TokenList* pTL = new TokenList;
   ScanTokenList(pTL, false);
   LOG("\n----Create tag " << *pTL);
   Typesetter::AppendTag(pTL);
   delete pTL;
   break;
}
@}

@$@<Misc commands@>+=@{@-
case CMD_MSIHMODE : {
   LOG("\n----\\msihmode ");
   if (Typesetter::GetMode() == MODE_VERTICAL){
     Typesetter::GotoHMode();
     s_groupStack[s_groupStackTop].m_mode = MODE_HORIZONTAL;
     inp.Putback(Global::msieverypar);
     inp.Putback(Global::everypar);
   } else if (Typesetter::GetMode() == MODE_MATH){
     Typesetter::GotoHMode();
     s_groupStack[s_groupStackTop].m_mode = MODE_HORIZONTAL;
     //inp.Putback(Global::msieverypar);
     //inp.Putback(Global::everypar);
   }

   break;
}
@}

@$@<Misc commands@>+=@{@-
case CMD_MSIVMODE : {
   LOG("\n----\\msivmode ");
   Typesetter::GotoVMode();
   break;
}
@}




@$@<Command Codes@>+=@{@-
CMD_ENDINPUT,
@}

@$@<Create symbols@>+=@{@-
NewPrimitive("endinput",  CMD_ENDINPUT, 0, 1);
@}

@$@<Misc commands@>+=@{@-
case CMD_ENDINPUT : {
   LOG("\n--- \\endinput");
   InputStack::EndInput();
   ClearLevels();
   break;
}
@}

@$@<Misc commands@>+=@{@-
case CMD_KILLLASTTAG : {
  TokenList* pTL = new TokenList;
  ScanTokenList(pTL, false);
  TokenList* pTLnew = new TokenList;
  ScanTokenList(pTLnew, false);

  StringUtils::AppendToks(*pTL);
  String str = StringBuilder::Create();
  std::string strTemp;
  int i = 0;
  while (i < str.Size()){
      strTemp += (char) str[i];
      ++i;
  }
  StringBuilder::Discard(str);


  StringUtils::AppendToks(*pTLnew);
  str = StringBuilder::Create();
  std::string strNew;
  i = 0;
  while (i < str.Size()){
      strNew += (char) str[i];
      ++i;
  }
  StringBuilder::Discard(str);

  Typesetter::AdjustAttributes(strTemp, strNew);

  break;
}
@}


@$@<Misc commands@>+=@{@-
case CMD_OPENTAG : {
   TokenList* pTL = new TokenList;
   TokenList* pTLoutput = new TokenList;
   ScanTokenList(pTL, false);
   ScanTokenList(pTLoutput, false);
   LOG("\n----Create open tag " << *pTL << ", " << *pTLoutput);
   Typesetter::AppendTag(pTLoutput);

   StringUtils::AppendToks(*pTL);
   String str = StringBuilder::Create();
   std::string strTemp;
   int i = 0;
   while (i < str.Size()){
      strTemp += (char) str[i];
      ++i;
   }
   StringBuilder::Discard(str);
   s_tagStack.push_back(strTemp);
   delete pTL;
   delete pTLoutput;
   break;
}
@}


@$@<Misc commands@>+=@{@-
case CMD_REQUIRETAG : {
   TokenList* pTL = new TokenList;
   TokenList* pTLoutput = new TokenList;
   ScanTokenList(pTL, false);
   ScanTokenList(pTLoutput, false);
   LOG("\n----Require open tag " << *pTL << ", " << *pTLoutput);

   StringUtils::AppendToks(*pTL);
   String str = StringBuilder::Create();
   std::string strTemp;
   int i = 0;
   while (i < str.Size()){
      strTemp += (char) str[i];
      ++i;
   }
   StringBuilder::Discard(str);

   // see if already there
   std::list<std::string>::reverse_iterator it = s_tagStack.rbegin();
   if (*it == strTemp){
     LOG("\n----Required tag already there");
   } else {
     LOG("\n----Inserting required tag");
     s_tagStack.push_back(strTemp);
     Typesetter::AppendTag(pTLoutput);
   }

   delete pTL;
   delete pTLoutput;
   break;
}
@}




@$@<Misc commands@>+=@{@-
case CMD_CLOSETAG : {
   TokenList* pTL = new TokenList;
   TokenList* pTLoutput = new TokenList;

   ScanTokenList(pTL, false);
   ScanTokenList(pTLoutput, false);
   LOG("\n----Create close tag " << *pTL << ", " << *pTLoutput);

   StringUtils::AppendToks(*pTL);
   String str = StringBuilder::Create();
   std::string strTemp;
   int i = 0;
   while (i < str.Size()){
       strTemp += (char) str[i];
       ++i;
   }
   StringBuilder::Discard(str);
   // look for the matching open tag
   std::list<std::string>::reverse_iterator it = s_tagStack.rbegin();
   bool found = false;
   while (it != s_tagStack.rend()){
      if (*it == strTemp){
         found = true;
         break;
      } else {
         ++it;
      }
   }
   // don't let a </para> close anything except
   // an immediately surrounding <para>
   if (found && strTemp == "bodyText"){
      if (it != s_tagStack.rbegin()){
         found = false;
      }
   }
   if (!found){
      LOG("\n----DISCARD Tag " << *pTL);
   } else {
      do {
        if (s_tagStack.back() == strTemp){
          Typesetter::AppendTag(pTLoutput);
          s_tagStack.pop_back();
          break;
        } else {
          LOG("\n----IMPLICIT CLOSING " << s_tagStack.back().c_str());
          std::string closetag ="</";
          closetag += s_tagStack.back();
          closetag += ">";
          Typesetter::AppendTag(closetag.c_str());
          s_tagStack.pop_back();
        }
      } while (true);
   }
   delete pTL;
   delete pTLoutput;
   break;
}
@}


@C@<Paragraph starting and ending@>


@$@<Command Codes@>+=@{@-
CMD_END_PAR,
@}


@$@<Create symbols@>+=@{@-
NewPrimitive("par", CMD_END_PAR);
@}

@$@<Misc commands@>+=@{@-
case CMD_END_PAR : {
   LOG("\n----End Paragraph");
   Typesetter::GotoVMode();
   Typesetter::SetInner(false);
   break;
}
@}

\cmda{Left brace}

This is generated by a catcode 1 character.
@$@<Command Codes@>+=@{@-
CMD_LEFT_BRACE,
CMD_RIGHT_BRACE,
@}

@$@<Grouping commands@>+=@{@-
case CMD_LEFT_BRACE : {
   if (Typesetter::GetMode() == MODE_MATH){
      LOG("\n----Begin math group " << CurTok());
      InputStack::Putback(CurTok());
      Typesetter::StartNucleus();
      ScanMath();
      break;
      //Typesetter::StartSubformula();
      //NewLevel(MATH_GROUP);
   } else {
      LOG("\n----Begin simple group " << CurTok());
      NewLevel(SIMPLE_GROUP);
   }
   if (Global::msidobraces == 1){
      if (Typesetter::GetMode() == MODE_VERTICAL){
        // Goto HMODE, rescan token
        inp.Putback(CurTok());
        Typesetter::GotoHMode();
        s_groupStack[s_groupStackTop].m_mode = MODE_HORIZONTAL;
        Typesetter::SetInner(false);
        inp.Putback(Global::msieverypar);
        inp.Putback(Global::everypar);
      } else {
        TeXToken lbrace(TT_LETTER, '{', 0);
        TokenList* pTL = new TokenList;
        pTL->push_back(lbrace);
        Typesetter::AppendTag(pTL);
        delete pTL;
      }
   }
   break;
}
@}

@$@<Grouping commands@>+=@{@-
case CMD_RIGHT_BRACE : {
   if (Global::msidobraces == 1 || bCurrentLevelType(MATH_GROUP)){
      TeXToken rbrace(TT_LETTER, '}', 0);
      TokenList* pTL = new TokenList;
      pTL->push_back(rbrace);
      Typesetter::AppendTag(pTL);
      delete pTL;
   }
   EndLevel();
   break;
}
@}



@C@<Show@>


@$@<Command Codes@>+=@{@-
CMD_SHOW,
@}


@$@<Create symbols@>+=@{@-
NewPrimitive("show", CMD_SHOW);
@}

@$@<Misc commands@>+=@{@-
case CMD_SHOW : {
   GetRawToken();
   LOG("\nShow " << CurTok() << " ");
   if (CurTok().Type() == TT_SYMBOL){
      SymbolData* pData = CurData();
      const MacroDef* pMacDef = dynamic_cast<const MacroDef*>(pData);
      if (pMacDef != 0){
         LOG("macro " << pMacDef -> Toks());
      }
   }

   break;
}
@}



@!-----------------------------------------
@! Superscript
@!-----------------------------------------
\cmda{Superscript}

@!-----------------------------------------
@! \unpenalty
@!-----------------------------------------

\cmd{unpenalty}

\noseealso
@$@<Command Codes@>+=@{@-
UNPENALTY,
@}


@!-----------------------------------------
@! \moveleft
@!-----------------------------------------

\cmd{moveleft etc}

See TTP 1071...

@$@<Command Codes@>+=@{@-
CMD_MOVELEFT, CMD_MOVERIGHT, CMD_RAISE, CMD_LOWER,
@}




@!--------------------------------
@! Indent
@!--------------------------------
\cmda{\char92indent and \char92noindent}

See TTP 1090.


@$@<Command Codes@>+=@{@-
CMD_START_PAR,
@}

@$@<Misc commands@>+=@{@-
case CMD_START_PAR:{
   LOG("\n---Start paragraph");
   break;
}
@}






@B@<Message and errmessage@>
@$@<Command Codes@>+=@{@-
CMD_MESSAGE,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("message",  CMD_MESSAGE, 0, 1);
NewPrimitive("errmessage", CMD_MESSAGE, 0, 2);
@}

@$@<Message commands@>==@{@-
case CMD_MESSAGE: {
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   int type = prim -> Data();
   TokenList* pTL = new TokenList;
   ScanTokenList(pTL, false);
   if (type == 1) {
       LOG("\n\\message: ");
   } else {
       LOG("\n\\errmessage: ");
   }
   LOG(*pTL);
   delete pTL;
   break;
}
@}



@B@<Logging modes@>

\cmd{batchmode}

\cmd{nonstopmode}

\cmd{scrollmode}

\cmd{errorstopmode}



@B@<Reading files@>
\noseealso
@$@<Command Codes@>+=@{@-
CMD_OPENIN,
CMD_READ,
CMD_CLOSEIN,
@}


\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("read", CMD_READ);
NewPrimitive("openin", CMD_OPENIN);
NewPrimitive("closein", CMD_CLOSEIN);
@}


@$@<Misc commands@>+=@{@-
case CMD_READ: {
   DoAssignment(0);
   break;
}
@}

@$@<Assignments@>+=@{@-
   case CMD_READ : {
      int m;
      ScanInt(&m);
      ScanKeyword(Keywords::KW_TO);
      //ScanOptionalSpaces();
      TeXToken defining;
      @<Scan definable symbol@>
      LOG("\n----Read from " << m << " to " << defining);
      break;
   }
@}


@$@<Misc commands@>+=@{@-
case CMD_OPENIN: {
   int m;
   ScanInt(&m);
   ScanOptionalEquals();

   Filename fn;
   @<Scan filename@>
   LOG("\n----Opening input "
          << m << " as " << fn.GetNameString());
   if (Global::g_readFile[m] != 0){
      LOG("\nDeleting already open read file");
      delete Global::g_readFile[m];
   }

   Global::g_readFile[m] = new InputByteFile;

   if (!Global::g_readFile[m] -> Open(fn)){
      LOG("\nFailed to open read file " << fn.GetNameString());
   }
   break;
}
@}

@$@<Misc commands@>+=@{@-
case CMD_CLOSEIN: {
   int m;
   ScanInt(&m);
   LOG("\n----Closing input " << m);
   delete Global::g_readFile[m];
   Global::g_readFile[m] = 0;
   break;
}
@}





@B@<Writing files@>
These are implemented as extensions.

\noseealso
@$@<Command Codes@>+=@{@-
CMD_EXTENSION,
@}


@$@<Command subcodes@>+=@{@-
enum ExtCode{
   EXT_IMMED,
   EXT_WRITE,
   EXT_OPENOUT,
   EXT_CLOSEOUT,
   EXT_EXTPROC,
   EXT_GRAPHIC_NAME};
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("immediate",CMD_EXTENSION, false, EXT_IMMED);
NewPrimitive("write", CMD_EXTENSION, false, EXT_WRITE);
NewPrimitive("openout", CMD_EXTENSION, false, EXT_OPENOUT);
NewPrimitive("closeout", CMD_EXTENSION, false, EXT_CLOSEOUT);
NewPrimitive("msiextproc", CMD_EXTENSION, false, EXT_EXTPROC);
NewPrimitive("msigraphicname", CMD_EXTENSION, false, EXT_GRAPHIC_NAME);
@}


@$@<Extensions@>+=@{@-
case CMD_EXTENSION: {
   Primitive* prim = dynamic_cast<Primitive*>(CurData());
   ExtCode subtype = (ExtCode) prim -> Data();
   switch(subtype){
      case EXT_IMMED : {
         LOG("\n----Immediate");
         break;
      }
      case EXT_WRITE : {
         int m;
         TokenList* pTL = new TokenList;
         ScanInt(&m);
         ScanTokenList(pTL, true);
         LOG("\n----Write to " << m << " the tokens " << *pTL);

         StringUtils::AppendToks(*pTL);
         delete pTL;

         String str = StringBuilder::Create();
         if (m >= 0 && m <= 15){
            if (Global::g_writeFile[m] == 0){
               LOG("\nOutput file " << m << " is not open. ");
               LOG("Writing to log.");
               LOG("\n*** " << str);
            } else {
               Global::g_writeFile[m] -> Write(str);
            }
         } else {
            LOG("\n*** " << str);
         }
         StringBuilder::Discard(str);

         break;
      }
      case EXT_OPENOUT : {
         int m;
         ScanInt(&m);
         ScanOptionalEquals();

         Filename fn;
         @<Scan filename@>
         LOG("\n----Opening output "
                     << m << " as "
                     << fn.GetNameString());
         if (Global::g_writeFile[m] != 0){
            LOG("\nDeleting already open write file");
            delete Global::g_writeFile[m];
         }

         Global::g_writeFile[m] = new OutputByteFile;

         if (!Global::g_writeFile[m] -> Open(fn)){
            LOG("\nFailed to open write file " << fn.GetNameString());
         }

         break;
      }
      case EXT_CLOSEOUT : {
         int m;
         ScanInt(&m);
         LOG("\n----Closing output " << m);
         if (m >= 0 && m <= 15){
            delete Global::g_writeFile[m];
            Global::g_writeFile[m] = 0;
         }
         break;
      }
      case EXT_EXTPROC : {
         Filename fn;
         @<Scan filename@>
         LOG("\n----Starting processor " << fn.GetNameString());
         //ScanLeftBrace();
         Typesetter::StartProcess(fn.GetNameString());
         //NewLevel(PROCESS_GROUP);
         TokenList* tl = new TokenList;
         ScanTokenList(tl, false);
         Typesetter::AppendTag(tl);
         delete tl;
         //EndLevel();
         Typesetter::EndProcess();
         break;
      };

      case EXT_GRAPHIC_NAME: {

         std::string graphic;
         LOG("\n----Graphic name");
         Filename fn;
         @<Scan filename@>
         const char* fullname = fn.GetFullName();
         LOG("\n---- the graphic name is: " << fullname);

         // Try to locate graphic ...

         // 1. Get the search paths
         StringUtils::AppendToks(Global::msigraphicspath);
         String str = StringBuilder::Create();
         std::string paths;
         int i = 0;
         while (i < str.Size()){
             paths += (char) str[i];
             ++i;
         }
         StringBuilder::Discard(str);

         std::string extn = fn.GetExtString();
         if (extn != "") {
              // assume everything relative for now
              //if (fullname[0] == '.'){
                // relative path?
                graphic = s_docdir;
                graphic += SEP;
                graphic += fullname;
              //} else {
              //  // Absolute path
              //  graphic = fullname;
              //}

         } else {
             // No extension.
             const char* exts[] = {".png", ".jpg", ".pdf", NULL};
             int i = 0;

             while (exts[i] != NULL){
               std::string name = fullname;
               name += exts[i];

               char buf[_MAX_PATH];

               SearchEnv(name.c_str(), paths.c_str(), false, buf);
               if (strlen(buf) != 0) {
                  // found it
                  graphic = buf;
                  break;
               }
               ++i;
             }

         }

         // Copy the graphic to <docdir>/graphics
         LOG("\n---- Copy " << graphic.c_str());

         std::string targetdir;
         if (s_outputdir != 0)
           targetdir = s_outputdir;

         if (extn == "xvz") {
            targetdir += SEP;
            targetdir += "plots";
            targetdir += SEP;
         } else {
            targetdir += SEP;
            targetdir += "graphics";
            targetdir += SEP;
         }

         std::string target = targetdir;
         target += fn.GetNameString();
         target += ".";
         target += fn.GetExtString();

         LOG("\n---- To " << target.c_str());

         // Copy the file

         FILE* graphfile = fopen(graphic.c_str(), "rb");
         FILE* targetfile = fopen(target.c_str(), "wb");

         if (graphfile && targetfile){
             LOG("\n---- Files Open");
             int ch = fgetc(graphfile);
             while (ch != EOF){
                fputc(ch, targetfile);
                ch = fgetc(graphfile);
             }
         }

         if (graphfile) fclose(graphfile);
         if (targetfile) fclose(targetfile);


         std::string reltarget;
         if (extn == "xvz") {
            reltarget += "plots";
            reltarget += SEP;
         } else {
            reltarget += "graphics";
            reltarget += SEP;
         }

         reltarget += fn.GetNameString();
         reltarget += ".";
         reltarget += fn.GetExtString();

         for (int k = 0; k < reltarget.size(); ++k){
           if (reltarget[k] == '\\'){
             reltarget[k]='/';
           }
         }
         

         if (extn != "") {
            Typesetter::AppendTag(reltarget.c_str());
         }

         break;
      };

      default: {
         LOG("ERROR --- unknown extension");
         ASSERT(false);
         break;
      }

   }
   break;
}
@}





@B@<\char92font@>

\noseealso
@$@<Command Codes@>+=@{@-
CMD_SET_FONT,
CMD_FONT_SWITCH,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("font", CMD_SET_FONT);
@}

@$@<Font commands@>+=@{@-
case CMD_SET_FONT:{
   TeXToken defining;
   @<Scan definable symbol@>
   ScanOptionalEquals();
   Filename fn;
   @<Scan filename@>
   if (ScanKeyword(Keywords::KW_SCALED)){
      int n;
      ScanInt(&n);
   } else if (ScanKeyword(Keywords::KW_AT)){
      int dim;
      ScanDim(false, false, false, &dim);
   }
   Primitive* cmd = new Primitive(CMD_FONT_SWITCH, false, 0);
   Symbols::SetDef(defining.Symbol(), cmd, false);
   LOG("\n----Set " << defining <<
      " = a font (todo: should this check global setting?)");
   break;
}
@}


@$@<Font commands@>+=@{@-
case CMD_FONT_SWITCH : {
   LOG("----switch to font " << CurTok());
   break;
}
@}

\noseealso
@$@<Command Codes@>+=@{@-
CMD_SET_SKEWCHAR,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("skewchar", CMD_SET_SKEWCHAR);
@}


@$@<Font commands@>+=@{@-
case CMD_SET_SKEWCHAR:{
   GetRawToken();
   TeXToken font = CurTok();
   ScanOptionalEquals();
   int n;
   ScanInt(&n);
   LOG("\nSet skewchar of " << font << " = " << n);
   break;
}
@}

\noseealso
@$@<Command Codes@>+=@{@-
CMD_SET_TEXTFONT,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("textfont", CMD_SET_TEXTFONT);
@}


@$@<Font commands@>+=@{@-
case CMD_SET_TEXTFONT:{
   int n;
   ScanInt(&n);
   ScanOptionalEquals();
   GetRawToken();
   TeXToken font = CurTok();
   LOG("\nSet textfont of " << n << " = " << font);
   break;
}
@}

\noseealso
@$@<Command Codes@>+=@{@-
CMD_SET_SCRIPTFONT,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("scriptfont", CMD_SET_SCRIPTFONT);
@}


@$@<Font commands@>+=@{@-
case CMD_SET_SCRIPTFONT:{
   int n;
   ScanInt(&n);
   ScanOptionalEquals();
   GetRawToken();
   TeXToken font = CurTok();
   LOG("\nSet scriptfont of " << n << " = " << font);
   break;
}
@}

\noseealso
@$@<Command Codes@>+=@{@-
CMD_SET_SCRIPTSCRIPTFONT,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("scriptscriptfont", CMD_SET_SCRIPTFONT);
@}


@$@<Font commands@>+=@{@-
case CMD_SET_SCRIPTSCRIPTFONT:{
   int n;
   ScanInt(&n);
   ScanOptionalEquals();
   GetRawToken();
   TeXToken font = CurTok();
   LOG("\nSet scriptscriptfont of " << n << " = " << font);
   break;
}
@}


@B@<\begingroup and \endgroup@>

\noseealso
@$@<Command Codes@>+=@{@-
CMD_BEGINGROUP,
CMD_ENDGROUP,
@}

\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("begingroup", CMD_BEGINGROUP);
NewPrimitive("endgroup", CMD_ENDGROUP);
@}


@$@<Grouping commands@>+=@{@-
case CMD_BEGINGROUP:{
   NewLevel(SEMISIMPLE_GROUP);
   LOG("\n----\\begingroup");
   break;
}

case CMD_ENDGROUP:{
   EndLevel();
   LOG("\n----\\endgroup");
   break;
}

@}




@!-------------------------------
@! \relax
@!-------------------------------

\cmd{relax}

See TTP 1045.

\noseealso
@$@<Command Codes@>+=@{@-
CMD_RELAX,
@}



\noseealso
@$@<Create symbols@>+=@{@-
NewPrimitive("relax", CMD_RELAX);
@}

@$@<Misc commands@>+=@{@-
case CMD_RELAX: {
   LOG("\n----\\relax");
   break;
};
@}



@B@<\ignorespaces@>
\noseealso
@$@<Command Codes@>+=@{@-
CMD_IGNORESPACES,
@}

@$@<Create symbols@>+=@{@-
NewPrimitive("ignorespaces", CMD_IGNORESPACES);
@}

@$@<Misc commands@>+=@{@-
case CMD_IGNORESPACES: {
   GetNext_NonBlank_NonCall();
   InputStack::Putback(CurTok());
   break;
}
@}


@B@<\aftergroup and \afterassignment@>

\noseealso
@$@<Command Codes@>+=@{@-
CMD_AFTERGROUP,
CMD_AFTERASSIGNMENT,
@}


@$@<Create symbols@>+=@{@-
NewPrimitive("aftergroup", CMD_AFTERGROUP);
NewPrimitive("afterassignment", CMD_AFTERASSIGNMENT);
@}


@$@<Misc commands@>+=@{@-
case CMD_AFTERGROUP: {
   DoAssignment(0);
   break;
}
@}


@$@<Misc commands@>+=@{@-
case CMD_AFTERASSIGNMENT: {
   GetRawToken();
   s_afterAssignment = CurTok();
   LOG("\n----afterassignment insert " << CurTok());
   break;
}
@}


@$@<Assignments@>+=@{@-
case CMD_AFTERGROUP:{
   ASSERT(s_groupStackTop >= 0);
   TokenList* afterGroup = s_groupStack[s_groupStackTop].m_afterGroup;
   if (afterGroup == 0){
      afterGroup = new TokenList;
      s_groupStack[s_groupStackTop].m_afterGroup = afterGroup;
   }
   GetRawToken();
   afterGroup -> push_back(CurTok());
   LOG("\n----aftergroup insert " << CurTok());
   break;
}
@}



@B@<Physical layout@>

@o@<interpretter.h@>==@{@-
#ifndef INTERPRETTER_H
#define INTERPRETTER_H
@<class Interpreter@>
#endif
@}

@o@<interpretter.cpp@>==@{@-
#include "interpretter.h"
#include "platform.h"
#include "symbols.h"
#include "restore.h"
#include "typesetter.h"
#include "scanutils.h"
#include "expandables.h"
#include "macros.h"
#include "mml.h"
#include "scanutils.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <list>
#include <map>
#include <iostream>


static InputStack inp;
static TeXToken s_illegal(TT_PARAM, 11, 0); // an illegal token
static TeXToken s_afterAssignment(s_illegal);
void SearchEnv(const char *file, const char *env, bool isEnvVar, char *buf);
Typesetter ts;
SymbolData* frozen_relax = new Primitive(CMD_RELAX);

@<GroupStack@>
@<TagStack@>
@<Interpreter forward declarations@>
@<Functions for inserting primitive hooks@>
@<A string function that should go elsewhere@>
@<Some box scanning@>
@<ScanMath@>
@<Alignment implementation@>
@<Declare MakeIntegerParameter@>
@<Declare MakeDimenParam@>
@<Declare MakeGlueParam@>
@<Declare MakeToksParameter@>
@<Declare interpreter global variables@>
@<Graphic file utility@>
@<InitializeSymbolTable@>

@<DoAssignments@>
@<DoPrefixedCommand@>
@<Main Loop@>
@}


@o@<interprt.t.cpp@>==@{@-
#include <string>
#include "platform.h"
#include "textio.h"
#include "tokens.h"
#include "symbols.h"
#include "scanutils.h"
#include "interpretter.h"

@<CompareLog utility@>
@<Input file utility@>

@<Test jig@>@(@<Interprt tests@>@,@<Interprt TestTable@>@)
@}


