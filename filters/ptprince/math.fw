@A@<Mathematics@>

This is part of the interpreter that builds math lists.

@B@<Getting into and leaving math mode@>

First, here's how we get into math mode ...

This is generated by a catcode 3 character, usually a `\$'.

@$@<Command Codes@>+=@{@-
CMD_MATH_SHIFT,
@}

@$@<Misc commands@>+=@{@-
case CMD_MATH_SHIFT : {
   if (Typesetter::GetMode() == MODE_VERTICAL){
      LOG("\n---- math shift in vertical mode.");
      LOG("\n     Leave vmode and rescan $.");
      // Goto HMODE, rescan token
      inp.Putback(CurTok());
      Typesetter::GotoHMode();
      Typesetter::SetInner(false);
      s_groupStack[s_groupStackTop].m_mode = MODE_HORIZONTAL;
      inp.Putback(Global::msieverypar);
      inp.Putback(Global::everypar);
      break;
   } else if ( (Typesetter::GetMode() == MODE_MATH)  &&
                bCurrentLevelType(INLINE_GROUP) ) {
      LOG("\n---- ending math shift");
      EndLevel();
      break;
   }
   LOG("\n---- math shift");
   GetRawToken();
   DetermineCommandCode();
   bool bInline = false;
   if (CurCmdCode() == CMD_MATH_SHIFT){
      LOG("\n---- double $");
   } else {
      LOG("\n---- single $, put back token");
      InputStack::Putback(CurTok());
      bInline = true;
   }
   if (Typesetter::GetMode() == MODE_MATH){
      EndLevel();
      //Typesetter::PopMode();
   } else {
      //Typesetter::GotoMMode();
      if (bInline){
         Typesetter::StartInline();
         Typesetter::SetInner(true);
         NewLevel(INLINE_GROUP);
         s_groupStack[s_groupStackTop].m_mode = MODE_MATH;
         inp.Putback(Global::everymath);
      } else {
         Typesetter::StartDisplay();
         Typesetter::SetInner(false);
         NewLevel(DISPLAY_GROUP);
         s_groupStack[s_groupStackTop].m_mode = MODE_MATH;
         inp.Putback(Global::everydisplay);
      }
   }
   break;
}
@}

@B@<Equation numbers@>

@$@<Command Codes@>+=@{@-
CMD_EQNO,
@}

@$@<Create symbols@>+=@{@-
NewPrimitive("eqno",  CMD_EQNO, 0, 0);
NewPrimitive("leqno", CMD_EQNO, 0, 1);
@}

@$@<Math commands@>+=@{@-
case CMD_EQNO:
   if (Typesetter::GetMode() == MODE_MATH){
      if (Typesetter::Priveledged()){
         Typesetter::SetPriveledged(false);
      }
   } else {
      LOG("\nERROR -- eqno");
   }
   break;
@}

@B@<ScanMath@>

This function is called after \_ or {\tt \char`\^}. ScanMath
may also be used to scan the nucleus of a noad. We expect either
a single math character, or a left brace. If we see a single
character that character is `attached' to the last noad of the
current list. The last noad has one of its fields set to the mathchardata.
Otherwise we wait until the right brace is found and attach the
resulting list as a SubMList.

@$@<ScanMath@>==@{@-
void ScanMath()
{
 bool running = true;
 while (running && !inp.bEmpty()) {
   LOG("\n----ScanMath cycle");
   GetToken();
   DetermineCommandCode();
   switch (CurCmdCode()) {
      case CMD_LETTER:
      case CMD_OTHER:
         if (CurTok().ChrCode() < 128){
            Typesetter::AttachMathChar(CurTok().ChrCode());
         } else {
            Typesetter::AttachMathChar(CurTok().ChrCode());
         }
         LOG("\n----Character " << CurTok().ChrCode());

         return;
         break;

      // Need cases for \mathchar, etc

      case CMD_NONE:{
        LOG("\n----" << CurTok()
                     << " ERROR -- no command code.");

        std::cout << "\n-- Passing through: " ;
        String s = Symbols::GetName(CurTok().Symbol());
        std::cout << "\\";
        for (int i = 0; i < s.Size(); ++i){
          if (s[i] >= 32 && s[i] <= 126){
             std::cout << (char) s[i];
          } else {
             std::cout << "[chr " << (int) s[i] << "]";
          }
        }

        // Give it a default definition and put back the token
        TokenList* pTokenList = new TokenList;
        pTokenList -> push_back(TeXToken(TT_END_MATCH,0,0));

        pTokenList -> AppendSymbol("msidefault");
        pTokenList -> push_back(TeXToken(TT_LEFT_BRACE,'{',0));
        pTokenList -> push_back(TeXToken(CurTok()));
        pTokenList -> push_back(TeXToken(TT_RIGHT_BRACE,'}',0));
        MacroDef* pMacroDef = new MacroDef(pTokenList);

        Symbols::SetDef(CurTok().Symbol(), pMacroDef, false);
        inp.Putback(CurTok());

        //  // Let's just append the token to the
        //  // output stream
        //  TokenList* pTL = new TokenList;
        //  pTL->push_back(CurTok());
        //  Typesetter::AppendTag(pTL);

        break;
      }

      case CMD_LEFT_BRACE : {
         LOG("\n----Begin math group " << CurTok());
         Typesetter::StartSubformula();
         NewLevel(MATH_GROUP);
         TeXToken lbrace(TT_LETTER, '{', 0);
         TokenList* pTL = new TokenList;
         pTL->push_back(lbrace);
         Typesetter::AppendTag(pTL);
         delete pTL;
         return;
         break;
      }
   }
 }
}
@}

@B@<Subscripts and superscripts@>

@$@<Command Codes@>+=@{@-
CMD_SUBSCRIPT,
CMD_SUPERSCRIPT,
@}

@$@<Math commands@>+=@{@-
case CMD_SUBSCRIPT:
   if (Typesetter::StartScript(true)){
     ScanMath();
   }
   break;

case CMD_SUPERSCRIPT:
   if (Typesetter::StartScript(false)){
     ScanMath();
   }
   break;
@}








