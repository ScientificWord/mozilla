<! $Source$ >
<! $Revision$ >
<! To generate oemapi.txt, load this document into Netscape and Save As text. >
<html>
<head>
<title>
Maple V Release 4 OEM Application Programming Interface</title>
<h1>
Maple V Release 4 OEM<br>
Application Programming Interface</h1>
<h2>
Stefan Vorkoetter<br>
Waterloo Maple Technologies</h2>
<h4>
Last Modified May 28, 1996</h4>
</head>
<hr>
<body bgcolor="#ffffff">
<h1>
0. Overview</h1>
<p>
The Maple V Release 3 and earlier OEM versions were based on a modified standard kernel, wherein the input and output routines were tapped into to provide characters to the kernel, collect output characters from the kernel, and return these to the calling application. From the kernel's point of view, it was business as usual. With Maple V Release 4, the kernel has been entirely rearchitected, having become a callable entity. With this new architecture, implementation of an OEM version has become much more straightforward.</p>
<p>
The design of the new OEM version was driven by the conflicting requirements of a cleaner implementation, satisfying the demands of OEM customers, and compatibility with the old OEM version.</p>
<p>
This document consists of the following sections:</p>
<ul>
<li>
Section 1, <a href="#general"><cite>The Interface in General</cite></a>, describes the three main entry points to the Maple OEM API.<li>
Section 2, <a href="#callbacks"><cite>Call Back Functions</cite></a>, describes how results are returned from Maple, and how to implement a call back function to process these results.<li>
Section 3, <a href="#plotting"><cite>Plotting</cite></a>, describes how Maple generated plots are returned from Maple, and how to implement a call back function and plot driver to process these plots.<li>
Section 4, <a href="#realmath"><cite>Real Math Output</cite></a>, describes how to make use of 2-dimensional mathematical notation.<li>
Section 5, <a href="#help"><cite>Maple's On-line Help Database</cite></a>, describes how to access Maple's on-line help information directly (instead of through Maple commands).<li>
Section 6, <a href="#packaging"><cite>Packaging</cite></a> describes how the OEM interface is delivered for different platforms.</ul>
<h1>
<a name="general">1. The Interface in General</a></h1>
<p>
The OEM version consists of a collection of data types, constants, and functions, along with several OEM-supplied call back functions. A minimal OEM application can be written by using just two of the functions and providing only one call back function. Additional functions and call backs can be used to increase functionality and versatility.</p>
<h2>
<a name="datatypes">1.1 Data Types</a></h2>
<p>
Maple defines a few low-level data types to improve portability between machines. Some of these types are used for parameters or return values for OEM API functions. These types are:</p>
<dl>
<dt>
<code>M_INT</code><dd>
An integer that is the same size as a pointer on the architecture.<p>
</p>
<dt>
<code>M_BOOL</code><dd>
An integer that can take on one of two values: TRUE or FALSE.<p>
</p>
<dt>
<code>M_EXPR</code><dd>
A Maple expression in native internal format. The actual format is not documented, but some call backs (such as the real math call back) is passed such an expression for further processing by other API functions.</dl>
<p>
The data type definitions are found in "<code>moemtype.h</code>".</p>
<h2>
<a name="functions">1.2 API Functions</a></h2>
<p>
The OEM version general API consists of three basic functions: <code>MapleInitialize</code>, <code>MapleEvaluate</code>, and <code>MapleRestart</code>.</p>
<p>
<code>MapleInitialize</code> is used to create a Maple kernel, pass command line parameters to this kernel (equivalent to those passed to the stand-alone version of Maple), and to prepare the kernel for computation. The calling sequence is:</p>
<dl>
<dt>
<pre>
int MapleInitialize( int argc, char **argv, char *error )</pre>
<dd>
<p>
The <code>argc</code> parameter indicates the number of command line arguments passed in <code>argv</code>. Although it is not strictly necessary, <code>argc</code> should be at least 1.</p>
<p>
The <code>argv</code> parameter is an array of string pointers giving the command line parameters. This array should have at least <code>argc</code> + 1 elements, the first of which (<code>argv[0]</code>) is ignored, but is usually passed the name of the application or just the string "<code>maple</code>".</p>
<p>
The command line options supported are a subset of those supported by stand-alone versions of Maple. Options that take arguments (such as "<code>-b</code>") may be passed as either a single parameter wherein the argument immediately follows the option with no intervening space (eg. "<code>-b/usr/maple/lib</code>"), or as a pair of parameters (eg. "<code>-b</code>" and "<code>/usr/maple/lib</code>"). The following options are supported:</p>
<dl>
<dt>
<code>-a</code><dd>
<dt>
<code>-b</code> <var>libraryPath</var> {, <var>libraryPath</var>}<dd>
<dt>
<code>-e</code> <var>errorBreakLevel</var><dd>
<dt>
<code>-g</code> <var>gcIncrement</var><dd>
<dt>
<code>-q</code><dd>
<dt>
<code>-s</code><dd>
<dt>
<code>-t</code><dd>
<dt>
<code>-T</code> <var>cpuLimit</var> [, <var>dataLimit</var> [, <var>stackLimit</var> [, <var>coreDumpLimit</var> ]]]<dd>
<dt>
<code>-w</code> <var>warnLevel</var><dd>
</dl>
<p>
The error parameter points to a memory area into which an error message can be written if initialization should fail. This error message is guaranteed not to exceed 256 characters in length (including the NUL terminator).</p>
<p>
<code>MapleInitialize</code> will return a Maple kernel identifier (a small positive integer) if successful, or a zero if it fails (if, for example, incorrect arguments were passed). In the latter case, an error message will be written into the memory pointed to by the <code>error</code> parameter. Currently, multiple kernels are not supported.</p>
</dl>
<p>
The <code>MapleEvaluate</code> function is used to actually perform a computation. In the OEM version of Maple V Release 3 and earlier, the <code>MapleEvaluate</code> function (<code>MAPLE</code> actually) returned a complex structure giving the results (including any intermediate output) of the computation. In Release 4, results are returned via OEM supplied call back functions. Intermediate output is returned as it is generated instead of being returned at the end with the final results. This allows OEM applications to monitor the progress of a computation. The <code>MapleEvaluate</code> function is defined as follows:</p>
<dl>
<dt>
<pre>
void MapleEvaluate( int mapleID,
		    char *expr,
		    MCallBack cb,
		    void *data )</pre>
<dd>
<p>
The <code>mapleID</code> parameter specifies the kernel to be used.</p>
<p>
The <code>expr</code> parameter gives the statement to be evaluated, expressed in Maple syntax. If the expression contains a syntax error, <code>MapleEvaluate</code> will call the <code>errorCallBack</code> with a syntax error message and the offset into <code>expr</code> of the error. Like in stand-alone Maple, statements ending in a colon ("<code>:</code>") will not return any results (in this case, to the <code>textCallBack</code> function). Output caused by <code>print</code> or <code>lprint</code> commands, errors, or help requests will still be produced.</p>
<p>
The <code>cb</code> parameter specifies a collection of functions that Maple will use to return results to the OEM application. Details of the call back functions are described in section 2, <a href="#callbacks"><cite>Call Back Functions</cite></a>.</p>
<p>
The <code>data</code> parameter is an arbitrary OEM supplied value. It is passed on as the first argument to the call back functions. One use for the <code>data</code> parameter is to pass a C++ object of which the call backs are member functions. The <code>data</code> parameter then becomes <code>this</code> in the member functions.</p>
<p>
If an error is encountered while parsing the supplied expression, <code>MapleEvaluate</code> will call the <code>errorCallBack</code> given in the <code>cb</code> vector.</p>
</dl>
<p>
The <code>MapleRestart</code> function can be called at any time to re-initialize the state of a Maple kernel. This is nearly equivalent to starting over from scratch (ie. starting the application over), except that any memory that has been allocated will be allocated to the kernel's internal free-lists; it will not be returned to the operating system. If <code>MapleRestart</code> is called when no computation is active, it is equivalent to sending the statement "<code>restart;</code>" to the <code>MapleEvaluate</code> function. If <code>MapleRestart</code> is called when a computation is active (ie. <code>MapleRestart</code> is called from one of the call back functions), then the current computation is aborted, the active call to <code>MapleEvaluate</code> returns, and the call to <code>MapleRestart</code> does not return. The <code>MapleRestart</code> function is defined as follows:</p>
<dl>
<dt>
<pre>
M_BOOL MapleRestart( int mapleID, char *error )</pre>
<dd>
<p>
The <code>mapleID</code> parameter specifies the kernel to be restarted.</p>
<p>
The <code>error</code> parameter points to a memory area into which an error message can be written if reinitialization should fail. This error message is guaranteed not to exceed 256 characters in length (including the NUL terminator).</p>
<p>
If an error occurs when <code>MapleRestart</code> is called when no computation is active, <code>MapleRestart</code> returns <code>FALSE</code>, and an error message is written into the memory pointed to by the error parameter. If no error occurs, <code>TRUE</code> is returned.</p>
<p>
If <code>MapleRestart</code> is called when a computation is active, <code>MapleRestart</code> does not return. Instead, the currently active call to <code>MapleEvaluate</code> will return. No error can occur in this situation.</p>
</dl>
<p>
The <code>MapleError</code> function can be called at any time from any OEM supplied call back function to cause a Maple error (ie. as if Maple's <code>ERROR</code> function had been called). If a Maple <code>traperror</code> is in effect, it will catch the error, and execution of Maple code will continue after the <code>traperror</code> call. Otherwise, computation will stop, and a Maple error message will be generated (which will be sent to the <code>errorCallBack</code>, as defined in section 2, <a href="#callbacks"><cite>Call Back Functions</cite></a>). <code>MapleError</code> is defined as follows:</p>
<dl>
<dt>
<pre>
void MapleError( char *message )</pre>
<dd>
<p>
The <code>message</code> parameter is the text of the error message to produce (unless trapped).</p>
</dl>
<p>
The general OEM API is defined in "<code>moemapi.h</code>".</p>
<h1>
<a name="callbacks">2. Call Back Functions</a></h1>
<p>
Results are returned from a Maple computation via a group of OEM supplied call back functions. Each piece of output is passed to one of the call back functions. The call back functions are passed to the <code>MapleEvaluate</code> function in a structure of type <code>MCallBackVec</code>, defined as follows:</p>
<pre>
typedef struct {
    void (*textCallBack)( void *data, int tag, char *output );
    
    void (*errorCallBack)( void *data, M_INT offset, char *msg );
    
    void (*statusCallBack)( void *data, long bytesUsed,
			    long bytesAlloc, double cpuTime );
			    
    void (*plotCallBack)( void *data, MPlot plot );
    
    void (*realMathCallBack)( void *data, M_EXPR expr );
    
    char *(*readLineCallBack)( void *data );
    
    M_BOOL (*redirectCallBack)( void *data, char *name,
    				char *mode );
    				
    char *(*callBackCallBack)( void *data, char *output );
    
    M_BOOL (*queryInterrupt)( void *data );
} MCallBackVec, *MCallBack;</pre>
<p>
Each of these functions takes one or more parameters, but all take a generic <code>data</code> parameter. The <code>data</code> parameter is passed the value that was passed as the <code>data</code> parameter of the <code>MapleEvaluate</code> function. If the call back functions are to be C++ member functions, the <code>data</code> parameter is not declared, and becomes the value of <code>this</code> instead.</p>
<p>
If it is required for the call backs to know the ID of the kernel from which they were called, it is the responsibility of the OEM application to make this information available via the <code>data</code> parameter. This could be done, for example, by passing a pointer to an object or structure containing the ID (among other things) as the <code>data</code> parameter.</p>
<p>
The functions in the call back vector are defined as follows:</p>
<dl>
<dt>
<pre>
void (*textCallBack)( void *data, int tag, char *output )</pre>
<dd>
<p>
The <code>textCallBack</code> is called with typical (ie. non-exceptional) Maple output. Each piece of output that Maple generates (an intermediate result, output from a <code>printf</code> statement, etc.) is passed to the <code>textCallBack</code> function.</p>
<p>
The <code>tag</code> parameter indicates the type of output being passed. The <code>tag</code> parameter can take on one of the following values (as defined in "<code>moemapi.h</code>"):</p>
<dl>
<dt>
<code>M_OUTPUT</code><dd>
A line-printed (1-D) Maple expression or statement.<p>
</p>
<dt>
<code>M_DIAG</code><dd>
Diagnostic output (high <code>printlevel</code> or <code>trace</code> output).<p>
</p>
<dt>
<code>M_MISC</code><dd>
Miscellaneous output, such as from the Maple <code>printf</code> function or the debugger.<p>
</p>
<dt>
<code>M_HELP</code><dd>
Textual help output. This is generated when a help request comes from the kernel. For a more comprehensive help facility, refer to section 5, <a href="#help"><cite>Maple's On-line Help Database</cite></a>.<p>
</p>
<dt>
<code>M_QUIT</code><dd>
Response to a Maple <code>quit</code>, <code>done</code>, or <code>stop</code> command.<p>
</p>
<dt>
<code>M_WARNING</code><dd>
A warning message generated during a computation.<p>
</p>
<dt>
<code>M_ERROR</code><dd>
An error message generated during parsing or processing. This is only generated if no <code>errorCallBack</code> is specified (see below).<p>
</p>
<dt>
<code>M_STATUS</code><dd>
Kernel resource usage status (a "<code>bytes used</code>" message). This is only generated if no <code>statusCallBack</code> is specified (see below).<p>
</p>
<dt>
<code>M_PRETTY</code><dd>
One line of a possibly multi-lined pretty-printed expression. This is only generated if no <code>realMathCallBack</code> is specified (see below).</dl>
<p>
The <code>output </code>parameter contains the actual output of the type indicated by the <code>tag</code> parameter. Unlike in earlier versions of the Maple OEM version, each output string can be arbitrarily long.</p>
<p>
The <code>textCallBack</code> is the one call back function that <strong>must</strong> be supplied.</p>
<dt>
<pre>
void (*errorCallBack)( void *data, M_INT offset, char *msg )</pre>
<dd>
<p>
The <code>errorCallBack</code> is called whenever an error occurs during parsing or processing.</p>
<p>
The <code>offset</code> parameter is used to indicate the location of a parsing error. If <code>offset</code> &gt;= 0, the error was detected at the specified offset in the string passed to <code>MapleEvaluate</code>. If <code>offset</code> &lt; 0, the error is not a parsing error; it is a computation error.</p>
<p>
The <code>msg</code> parameter contains the actual text of the error message.</p>
<p>
If no <code>errorCallBack</code> is specified, error messages are sent to the <code>textCallBack</code>, with tag <code>M_ERROR</code>.</p>
<dt>
<pre>
void (*statusCallBack)( void *data, long bytesUsed,
			long bytesAlloc, double cpuTime )</pre>
<dd>
<p>
The <code>statusCallBack</code> is called whenever Maple reports resource usage information (equivalent to the "<code>bytes used</code>" messages in stand-alone Maple).</p>
<p>
The <code>cpuTime</code> parameter is the number of seconds of CPU time that has been consumed since the Maple kernel was started. This includes time spent in any call back functions.</p>
<p>
The <code>bytesUsed</code> parameter indicates how many bytes of storage have been allocated from Maple's internal storage manager.</p>
<p>
The <code>bytesAlloc</code> parameter indicates how many bytes of storage have been allocated from the operating system by Maple's internal storage manager.</p>
<p>
If no <code>statusCallBack</code> is specified, status information is sent to the <code>textCallBack</code> in the form "<code>bytes used=%ld, alloc=%ld, time=%1.2f</code>", with tag <code>M_STATUS</code>.</p>
<dt>
<pre>
void (*plotCallBack)( void *data, MPlot plot )</pre>
<dd>
<p>
The <code>plotCallBack</code> is called when a plot is generated by Maple. Details on the implementation of such a function are described in section 3, <a href="#plotting"><cite>Plotting</cite></a>.</p>
<p>
If no <code>plotCallBack</code> is specified, any attempt to produce a plot results in an error (reported via the <code>errorCallBack</code> or <code>textCallBack</code>).</p>
<dt>
<pre>
void (*realMathCallBack)( void *data, M_EXPR expr )</pre>
<dd>
<p>
The <code>realMathCallBack</code> is called to provide 2-dimensional pretty printed output. By default, the OEM version produces 1-dimensional output via the <code>textCallBack</code> function, but if the command "<code>interface(prettyprint=true);</code>" is sent to Maple, 2-dimensional output is produced instead, via the <code>realMathCallBack</code>.</p>
<p>
The <code>expr</code> parameter is the expression to be formatted This expression must then be passed to a 2-dimensional renderer to produce a form suitable for the OEM application. Several renderers are provided. Refer to section 4, <a href="#realmath"><cite>Real Math Output</cite></a>, for more information.</p>
<p>
If no <code>realMathCallBack</code> is provided, any 2-dimensional math output is formatted as text and sent to the <code>textCallBack</code> as one or more lines with tag <code>M_PRETTY</code>.</p>
<dt>
<pre>
char *(*readLineCallBack)( void *data )</pre>
<dd>
<p>
The <code>readLineCallBack</code> is called when the kernel executes the Maple <code>readline</code> function (which is also used by <code>readstat</code>, <code>history</code>, etc.). The intent is to obtain a line of input from the user. In most OEM applications, this will probably not be used.</p>
<p>
If no <code>readLineCallBack</code> is provided, any attempts to execute the Maple <code>readline</code> function will produce an error (reported via the <code>errorCallBack</code> or <code>textCallBack</code>).</p>
<dt>
<pre>
M_BOOL (*redirectCallBack)( void *data, char *name, char *mode )</pre>
<dd>
<p>
The <code>redirectCallBack</code> is called when the kernel executes the Maple <code>writeto</code> or <code>appendto</code> function. The intent is to redirect subsequent output. What this means in the context of an OEM application is obviously OEM specific.</p>
<p>
The <code>name</code> parameter gives the name of the file to which output should be appended, and the <code>mode</code> parameter specifies the file access mode to use: "<code>wt</code>" for write or "<code>at</code>" for append. The <code>name</code> and <code>mode</code> parameters are compatible with the C library function <code>fopen</code>.</p>
<p>
If the <code>name</code> parameter is <code>NULL</code> (in which case the parameters will not be compatible with <code>fopen</code>), Maple is signalling that redirection is to be terminated (ie. subsequent output is to go back to the main output stream). Again, what this means is OEM specific.</p>
<p>
If no <code>redirectCallBack</code> is provided, any attempts to execute the Maple <code>writeto</code> or <code>appendto</code> functions will produce an error (reported via the <code>errorCallBack</code> or <code>textCallBack</code>).</p>
<dt>
<pre>
char *(*callBackCallBack)( void *data, char *output )</pre>
<dd>
<p>
The <code>callBackCallBack</code> is called when the Maple function <code>callback</code> is called by OEM supplied Maple code. The <code>output</code> parameter contains the textual version of the parameters passed to the <code>callback</code> function.</p>
<p>
On return, the <code>callBackCallBack</code> function should pass either a <code>NULL</code> pointer, or a pointer to a string containing a valid Maple expression. If <code>NULL</code> is passed, the Maple <code>callback</code> function returns nothing. If a Maple expression is passed, it is parsed, and the Maple <code>callback</code> function returns the expression (unevaluated).</p>
<p>
This facility can be used to explicitly pass intermediate values of a computation to OEM supplied code, and to return value to Maple.</p>
<p>
If no <code>callBackCallBack</code> is provided, any attempts to execute the Maple <code>callback</code> function will produce an error (reported via the <code>errorCallBack</code> or <code>textCallBack</code>).</p>
<dt>
<pre>
M_BOOL (*queryInterrupt)( void *data )</pre>
<dd>
<p>
The <code>queryInterrupt</code> call back is called periodically to allow the computation to be halted. This function is called before each Maple statement is executed. In general, this will be hundreds of times per second, but some operations (notably large integer manipulations) may cause this to be called only once every few seconds. If the computation is to be halted, this function should return <code>TRUE</code>. If the computation is to continue, this function should return <code>FALSE</code>.</p>
<p>
If no <code>queryInterrupt</code> is provided, computations will not be interruptable.</p>
</dl>
<p>
The call back functions are defined in "<code>moemapi.h</code>".</p>
<h1>
<a name="plotting">3. Plotting</a></h1>
<p>
The only plotting facility available in the Maple V Release 3 OEM version was character plotting, wherein the stream of characters making up a plot were provided as part of the output.</p>
<p>
<p>
With Release 4, plotting has been made more flexible, with the ability to use OEM supplied plot drivers. Instead of returning the plot as a sequence of characters, or as a printed Maple <code>PLOT</code> data structure, Release 4 lets the OEM install a plot call back to which the plots are sent as a C <code>plot</code> data structure.</p>
<p>
The plot call back must be passed to the <code>MapleEvaluate</code> function, and must be defined as follows (the name need not be "<code>plotCallBack</code>" of course):</p>
<dl>
<dt>
<pre>
void plotCallBack( void *data, MPlot plot )</pre>
<dd>
<p>
The <code>data</code> parameter is passed the value that was passed as the <code>data</code> parameter of the <code>MapleEvaluate</code> function. If <code>plotCallBack</code> is to be a C++ member function, the <code>data</code> parameter is not declared, and becomes the value of <code>this</code> instead.</p>
<p>
The <code>plot</code> parameter is a pointer to a <code>plot</code> data structure (a C <code>struct</code>). The format of this structure is not documented for the OEM, and is subject to change without notice.</p>
</dl>
<p>
Once a plot has been received by the plot call back, it can be manipulated and rendered using tools provided in the OEM API.</p>
<p>
Several functions are provided to manipulate plots and to render them. The manipulation functions are:</p>
<dl>
<dt>
<pre>
void PlotSetAttribute( MPlot plot,
		       MPlotAttrib attr,
		       int value )</pre>
<dd>
<p>
This function is used to change the attributes (eg. color, style) of a plot. A plot initially has attributes that were either specified in the <code>plot</code> command sent to Maple, or are Maple's defaults.</p>
<p>
The <code>plot</code> parameter indicates the plot whose attributes are to be changed. This would be a plot that was sent to the OEM-supplied <code>plotCallBack</code> function.</p>
<p>
The <code>attr</code> parameter indicates which attribute to change. See section 3.5, <a href="#plotattrib"><cite>Plot Attributes</cite></a> for details.</p>
<p>
The <code>value</code> parameter indicates the new value the attribute is to receive. See section 3.5, <a href="#plotattrib"><cite>Plot Attributes</cite></a> for details.</p>
<dt>
<pre>
int PlotGetAttribute( MPlot plot,
		      MPlotAttrib attr )</pre>
<dd>
<p>
This function is used to query the attributes of a plot. The parameters are the same as for <code>PlotSetAttribute</code>. See section 3.5, <a href="#plotattrib"><cite>Plot Attributes</cite></a> for details. The return value is that of the desired attribute.</p>
<dt>
<pre>
M_INT PlotGetDimensions( MPlot plot )</pre>
<dd>
<p>
This function returns the number of dimensions (2 or 3) of a plot.</p>
<dt>
<pre>
void PlotDispose( MPlot plot )</pre>
<dd>
<p>
Discards a <code>plot</code> data structure that is no longer needed.</p>
</dl>
<p>
Rendering of plots is accomplished by Maple's universal plot driver. This driver is passed a plot and a device vector. The renderer is responsible for 3D to 2D transformation and hidden line removal in the case of 3D plots. The renderer will call the functions defined in the device vector to perform 2D rendering of the plot. The attributes of the plot (shading, color model, etc.) will have been previously defined, either in the <code>plot</code> or <code>plot3d</code> command passed to Maple, or via the <code>PlotSetAttribute</code> function. The renderer is defined as:</p>
<dl>
<dt>
<pre>
char *PlotRender( MPlot plot, MPlotDevice dev, void *data )</pre>
<dd>
<p>
The <code>plot</code> parameter specifies the plot to be rendered. This will be a plot that was passed to the plot call back.</p>
<p>
The <code>dev</code> parameter specifies a structure containing various data needed to render the plot, and functions for various rendering operations. These are described in more detail below.</p>
<p>
The <code>data</code> parameter is an OEM-specific parameter that is passed to all the rendering call backs. This can be used to pass a plot identifier, a C++ object, or any other desired value. The <code>data</code> parameter is passed to the rendering call backs as the first parameter. This way, if the <code>data</code> parameter is a C++ object, the rendering call backs can be member functions of that object.</p>
<p>
<code>PlotRender</code> will return <code>NULL</code> if successful, or a pointer to an error message if unsuccessful (note that it may return the same pointer in all cases of failure; if you need to save the message, make a copy of it immediately).</p>
</dl>
<p>
The actual graphics operations required to render a plot must be implemented by the OEM. The individual rendering functions are collected in a device vector, which is passed to the universal plot driver. A device vector has the following structure:</p>
<pre>
typedef struct {
    void (*drawPoint)( void *data, MPlotDevice dev, MPlot plot,
		       M_INT x, M_INT y,
		       M_INT attrib );
		       
    void (*drawLine)( void *data, MPlotDevice dev, MPlot plot,
		      M_INT x1, M_INT y1, M_INT x2, M_INT y2,
		      M_INT attrib );
		      
    void (*drawPolygon)( void *data, MPlotDevice dev, MPlot plot,
			 M_INT numPoints, M_INT *x, M_INT *y,
			 M_INT attrib );
			 
    void (*drawText)( void *data, MPlotDevice dev, MPlot plot,
		      M_INT x, M_INT y, char *text,
		      M_INT alignment, M_INT attrib, M_INT font );
		      
    void (*drawAxisLine)( void *data, MPlotDevice dev, MPlot plot,
			  M_INT x1, M_INT y1, M_INT x2, M_INT y2,
			  M_INT attrib );
			  
    void (*drawAxisText)( void *data, MPlotDevice dev, MPlot plot,
			  M_INT x, M_INT y, char *text,
			  M_INT alignment, M_INT attrib, M_INT font );
			  
    void (*drawTitleText)( void *data, MPlotDevice dev, MPlot plot,
			   char *text );
			  
    void (*startImage)( void *data, MPlotDevice dev, MPlot plot );
    
    void (*setColorMap)( void *data, MPlotDevice dev, MPlot plot,
			 M_INT numColors, M_INT *rgb );
			 
    void (*endImage)( void *data, MPlotDevice dev, MPlot plot );
    
    M_INT (*queryDevice)( void *data, MPlotDevice dev, MPlot plot,
			  M_INT parameter );
			  
    M_BOOL (*queryInterrupt)( void *data, MPlotDevice dev,
    			      MPlot plot );
    			      
    void (*outChar)( void *data, int c );
} MPlotDeviceVec, *MPlotDevice;</pre>
<p>
This structure is subject to change with new releases of Maple.</p>
<p>
The functions in the <code>MPlotDeviceVec</code> are used to perform different rendering operations. The parameters to these functions depend on the function, but some parameters are common to several of the functions. These are described below:</p>
<dl>
<dt>
<code>void *data</code><dd>
<p>
The <code>data</code> parameter is passed the value that was passed as the data parameter of the <code>PlotRender</code> function. If the call back functions are to be C++ member functions, the data parameter is not declared, and becomes the value of <code>this</code> instead.</p>
<dt>
<code>MPlotDevice dev</code><dd>
<p>
The actual device vector from which the called function was called. In other words, the device vector that was passed to <code>PlotRender</code>. This is passed to the individual call backs in case a call back wishes to call another call back without naming the other call back explicitly. </p>
<dt>
<code>MPlot plot</code><dd>
<p>
The plot being rendered (which was passed to <code>PlotRender</code>). This is passed to the call backs in case they want to refer to the plot in some way (most notably to look up font information or query an attribute).</p>
<dt>
<code>M_INT x, M_INT y</code><dd>
<p>
Coordinates for points, lines, text, etc. The coordinates will be in the ranges specified by <code>queryDevice</code>'s response to the <code>Q_WIDTH</code> and <code>Q_HEIGHT</code> queries. If the width was specified as <var>width</var>, and the height as <var>height</var>, then 0 &lt;= <var>x</var> &lt; <var>width</var> and 0 &lt;= <var>y</var> &lt; <var>height</var>.</p>
<dt>
<code>M_INT attrib</code><dd>
<p>
This specifies the attributes of the object to be rendered. Several macros are provided to extract various aspects of the attributes from such a parameter. These support macros are:</p>
<dl>
<dt>
<code>DECODE_COLOR</code><dd>
<p>
Extracts the RGB value or color map entry index from the attribute. See section 3.1, <a href="#plotcolors"><cite>Color Handling in Plots</cite></a> for more information.</p>
<dt>
<code>DECODE_LINESTYLE</code><dd>
<p>
Extracts style information from the attribute. The style is generally used to select dash patterns. The predefined line styles are:</p>
<p>
<code>MPA_LINE_STYLE_SOLID<br>
MPA_LINE_STYLE_DOTTED<br>
MPA_LINE_STYLE_DASHED<br>
MPA_LINE_STYLE_DASHDOT</code></p>
<p>
User defined line styles can also appear in a plot (having been put there by <code>PlotSetAttribute</code>). Internally, line styles are stored in three bits, so the maximum ordinal value of a line style is 7.</p>
<dt>
<code>DECODE_THICKNESS</code><dd>
<p>
Extracts line thickness information from the attribute. This is usually the thickness in pixels, but can be in other units (eg. for PostScript). A thickness of 1 is considered normal. The predefined thicknesses are:</p>
<p>
<code>MPA_THICKNESS_THIN<br>
MPA_THICKNESS_MEDIUM<br>
MPA_THICKNESS_THICK</code></p>
<p>
Used defined thicknesses (up to a value of 15) can also appear in a plot.</p>
<dt>
<code>DECODE_SYMBOL</code><dd>
<p>
Extracts symbol information from an attribute of a point. This is used to draw symbols such as diamonds, circles, squares, etc. at points. The predefined symbols are:</p>
<p>
<code>MPA_SYMBOL_CROSS<br>
MPA_SYMBOL_DIAMOND<br>
MPA_SYMBOL_BOX<br>
MPA_SYMBOL_CIRCLE<br>
MPA_SYMBOL_POINT</code></p>
<p>
User defined symbols can also appear in a plot (having been put there by <code>PlotSetAttribute</code>). Internally, symbols are stored in four bits, so the maximum ordinal value of a symbol is 15.</p>
<dt>
<code>M_INT alignment</code><dd>
<p>
This specifies the alignment (to left, centered, to right and above, centered, below) of text relative to the specified point. The alignment is specified using four bits in the parameter:</p>
<dl>
<dt>
<code>ALIGN_TO_LEFT</code><dd>
<p>
The text is to be aligned to the left of the specified point (ie. the right side of the text touches the point).</p>
<dt>
<code>ALIGN_TO_RIGHT</code><dd>
<p>
The text is to be aligned to the right of the specified point (ie. the left side of the text touches the point).</p>
<dt>
<code>ALIGN_ABOVE</code><dd>
<p>
The text is to be aligned above the specified point (ie. the bottom of the text touches the point).</p>
<dt>
<code>ALIGN_BELOW</code><dd>
<p>
The text is to be aligned below the specified point (ie. the top of the text touches the point).</p>
</dl>
<p>
If neither <code>ALIGN_TO_LEFT</code> nor <code>ALIGN_TO_RIGHT</code> are specified, the text is centered horizontally about the point. Likewise, if neither <code>ALIGN_ABOVE</code> nor <code>ALIGN_BELOW</code> are specified, the text is centered vertically about the point.</p>
<dt>
<code>M_INT font</code><dd>
<p>
This specifies the font to be used to display text. A value of -1 indicates the default title font, a value of 0 indicates the default font, and other values indicate an entry in the font table for the plot. Information about the specified font can be obtained by passing the Plot parameter and the font to PlotGetFont. See section 3.2, <a href="#plotfonts"><cite>Font Handling in Plots</cite></a> for more information.</p>
</dl>
</dl>
<p>
The functions in the device vector are:</p>
<dl>
<dt>
<pre>
void (*drawPoint)( void *data, MPlotDevice dev, MPlot plot,
		   M_INT x, M_INT y,
		   M_INT attrib )</pre>
<dd>
<p>
Draw a point at (<code>x</code>,<code>y</code>) with the specified attributes (color, thickness, and symbol).</p>
<dt>
<pre>
void (*drawLine)( void *data, MPlotDevice dev, MPlot plot,
		  M_INT x1, M_INT y1, M_INT x2, M_INT y2,
		  M_INT attrib )</pre>
<dd>
<p>
Draw a line from (<code>x1</code>,<code>y1</code>) to (<code>x2</code>,<code>y2</code>) with the specified attributes (color, thickness, and style).</p>
<dt>
<pre>
void (*drawPolygon)( void *data, MPlotDevice dev, MPlot plot,
		     M_INT numPoints, M_INT *x, M_INT *y,
		     M_INT attrib )</pre>
<dd>
<p>
Draw a closed filled polygon with <code>numPoints</code> vertices. The vertices are numbered from 0 to <code>numPoints</code> - 1, and are given by the arrays <code>x</code> and <code>y</code>. Use the specified attributes (color).</p>
<dt>
<pre>
void (*drawText)( void *data, MPlotDevice dev, MPlot plot,
		  M_INT x, M_INT y, char *text,
		  M_INT alignment, M_INT attrib, M_INT font )</pre>
<dd>
<p>
Draw text at (<code>x</code>,<code>y</code>) with the specified alignment, attributes (color), and font.</p>
<dt>
<pre>
void (*drawAxisLine)( void *data, MPlotDevice dev, MPlot plot,
		      M_INT x1, M_INT y1, M_INT x2, M_INT y2,
		      M_INT attrib )</pre>
<dd>
<p>
Draw an axis line from (<code>x1</code>,<code>y1</code>) to (<code>x2</code>,<code>y2</code>) with the specified attributes (color, thickness, and style).</p>
<dt>
<pre>
void (*drawAxisText)( void *data, MPlotDevice dev, MPlot plot,
		      M_INT x, M_INT y, char *text,
		      M_INT alignment, M_INT attrib, M_INT font )</pre>
<dd>
<p>
Draw an axis label at (<code>x,y</code>) with the specified alignment, attributes (color), and font.</p>
<dt>
<pre>
void (*drawTitleText)( void *data, MPlotDevice dev, MPlot plot,
		       char *text )</pre>
<dd>
<p>
Draw the title of the plot. Style and placement of the title is entirely up to the OEM application.</p>
<dt>
<pre>
void (*startImage)( void *data, MPlotDevice dev, MPlot plot )</pre>
<dd>
<p>
Initialize the OEM supplied rendering functions. For example, if recording the plot in a file, this would be the place to open the file.</p>
<dt>
<pre>
void (*setColorMap)( void *data, MPlotDevice dev, MPlot plot,
		     M_INT numColors, M_INT *rgb )</pre>
<dd>
<p>
Register the set of colors that will be used for this plot. There will be <code>numColors</code> colors, numbered from 0 to <code>numColors</code> - 1, given by the array rgb. Each color value will be passed as a 24-bit value where the most significant 8 bits represent red the next most significant 8 bits represent green, and the 8 least significant bits represent blue.</p>
<dt>
<pre>
void (*endImage)( void *data, MPlotDevice dev, MPlot plot )</pre>
<dd>
<p>
Do whatever is necessary to complete the rendering. For example, if recording the plot in a file, this would be where the file is closed.</p>
<dt>
<pre>
M_INT (*queryDevice)( void *data, MPlotDevice dev, MPlot plot,
		      M_INT devQuery )</pre>
<dd>
<p>
Used by the Maple renderer to query attributes of the device. The <code>devQuery</code> parameter specifies the feature being queried, and the function must return a result appropriate to the query. The queries supported are:</p>
<dl>
<dt>
<code>Q_WIDTH</code><dd>
<p>
What is the width of the device, in device dependent units.</p>
<dt>
<code>Q_HEIGHT</code><dd>
<p>
What is the height of the device, in device dependent units.</p>
<dt>
<code>Q_COLORMAP</code><dd>
<p>
Do the OEM supplied rendering commands want to use a color map? See section 3.1, <a href="#plotcolors"><cite>Color Handling in Plots</cite></a> for more information.</p>
<dt>
<code>Q_BACKGROUND</code><dd>
<p>
What is the background color (eg. white for a plotter)? This is specified as a 24-bit RGB value, independent of the color model used by the device. The Maple renderer uses this to avoid using that color in the plot.</p>
</dl>
<dt>
<pre>M_BOOL (*queryInterrupt)( void *data, MPlotDevice dev,
			  MPlot plot )</pre>
<dd>
<p>
This function is called periodically by the renderer to allow the OEM application to perform background tasks such as mouse tracking, and to interrupt the rendering operation if desired. The function is expected to return <code>TRUE</code>. If it returns <code>FALSE</code>, rendering stops.</p>
<dt>
<pre>void (*outChar)( void *data, int c )</pre>
<dd>
<p>
This one is a bit unusual. The plot renderer (<code>PlotRender</code>) will never call this function itself. However, OEM supplied call back functions can (and are encouraged to) call this function when plotting involves writing to an output device or stream (as a PostScript driver would do, for example). That way, copying the device vector and changing the <code>outChar</code> member is an easy way to redirect the plotting output.</p>
<p>
All the sample drivers supplied by Waterloo Maple make use of this function to perform output (where appropriate).</p>
</dl>
<p>
The sequence of operations required to create a plot using OEM Maple is as follows:</p>
<ol>
<li>
<p>
A command such as "<code>plot(sin(x),x=-5..5);</code>" is sent to Maple for evaluation.</p>
<li>
<p>
Maple produces a <code>PLOT</code> data structure which is sent to the API, where it is translated to a data structure private to Maple's plotting system, and then passed on to the OEM's plot call back.</p>
<li>
<p>
The OEM's plot call back function creates a device vector containing all the rendering tools to be used, and then calls <code>PlotRender</code>, pasing it the plot data structure and the device vector.</p>
<li>
<p>
The rendering engine makes several queries via the <code>queryDevice</code> function in the device vector.</p>
<li>
<p>
The rendering image calls the <code>startImage</code> function in the device vector.</p>
<li>
<p>
Depending on the result of the <code>Q_COLORMAP</code> query, the rendering engine passes a color map to the <code>setColorMap </code>function in the device vector.</p>
<li>
<p>
The rendering engine calls the various rendering functions in the device vector. These functions may call various support functions such as <code>PlotGetFont</code>. They may also call other rendering functions, such as <code>outChar</code>.</p>
</ol>
<p>
During the execution of the step 1, Maple will periodically call the <code>queryInterrupt</code> call back that was passed to the <code>MapleEvaluate</code> function.</p>
<p>
During the execution of steps 3 through 7, Maple will periodically call the <code>queryInterrupt</code> call back that was passed to <code>PlotRender</code> in the device vector.</p>
<p>
The OEM plotting interface is defined in "<code>moemplot.h</code>".</p>
<h2>
<a name="plotcolors">3.1 Color Handling in Plots</a></h2>
<p>
The OEM Maple rendering engine supports two color models: full color and mapped color. Before beginning a plot, the renderer queries the OEM supplied device (via the the <code>Q_COLORMAP</code> parameter to the <code>queryDevice</code> call back) which model is desired.</p>
<p>
If the device returns a non-zero integer <var>N</var>, the rendering engine will make a pre-pass over the plot to compute all the colors (at most <var>N</var>) that will be required. It will then inform the device of the required colors via the <code>setColorMap</code> call back. Any subsequent references to color will be indices into this color map.</p>
<p>
If the device returns 0 in response to <code>Q_COLORMAP</code>, the rendering engine will not make a pre-pass. Instead, it will use each 24-bit color as it needs it, and will pass color as 24-bit values.</p>
<p>
This approach allows for maximum flexibility. When working with 24-bit color devices, the full capabilities of the device are utilized. When working with any other device, the OEM application has control over how many colors are used, and how the colors are rendered. When it is given the color map (via <code>setColorMap</code>), it can do whatever processing is necessary to map this to the device's capabilities, and generate a table of the actual colors, grey scales, or dither patterns to be used. Further references to color by Maple's rendering engine can then be used as an index into this table.</p>
<h2>
<a name="plotfonts">3.2 Font Handling in Plots</a></h2>
<p>
Text in plots is generated by calls to the <code>drawText</code> and <code>drawAxisText</code> call backs. The <code>font</code> parameter indicates the font to be used to render the text. The values -1 and 0 refer to the default title and default axis fonts respectively. All other values refer to entries in a table of fonts that is specified as part of the plot.</p>
<p>
The font table contains information about each of the fonts within it. This information is generated by the Maple plotting library functions based on options specified by the user. For each font, the table contains the font's name, a style, and a point size.</p>
<p>
Given a font number, the definition of the font can be retrieved using the <code>PlotGetFont</code> function. This function is defined as:</p>
<dl>
<dt>
<pre>
M_BOOL PlotGetFont( MPlot plot, M_INT font,
		    char *name, int nameSize,
		    char *style, int styleSize,
		    M_INT *size )</pre>
<dd>
<p>
The <code>plot</code> parameter specifies the plot for which a font is to be looked up.</p>
<p>
The <code>font</code> parameter is the font number of the font to look up. The values -1 and 0 can be passed, in which case information about Maple's idea of suitable default fonts is returned.</p>
<p>
The <code>name</code> parameter specifies a buffer of <code>nameSize</code> characters into which the font name is to be copied. No more than <code>nameSize</code> - 1 characters, plus a NUL byte, will be copied into this buffer. Currently, Maple can generate the following values for the name parameter: "<code>times</code>", "<code>courier</code>", "<code>helvetica</code>", and "<code>symbol</code>".</p>
<p>
The style parameter specifies a buffer of <code>styleSize</code> characters into which the font style is to be copied. No more than <code>styleSize</code> - 1 characters, plus a NUL byte, will be copied into this buffer. Currently, when the font name is "<code>times</code>", Maple can generate the following values for the style parameter: "<code>roman</code>", "<code>bold</code>", "<code>italic</code>", and "<code>bolditalic</code>". When the font name is "<code>courier</code>" or "<code>helvetica"</code>, Maple can generate the styles "", "<code>bold</code>", "<code>oblique</code>", and "<code>boldoblique</code>". For the "<code>symbol</code>" font, the style is always "".</p>
<p>
The <code>size</code> parameter is a pointer to an integer into which the font size, in points, will be stored.</p>
<p>
<code>PlotGetFont</code> returns <code>TRUE</code> if successful and <code>FALSE</code> if the specified font index is not valid for the plot.</p>
</dl>
<p>
Once information about a font has been retrieved, the OEM rendering system should select an available font that most closely matches the description of the font.</p>
<h2>
<a name="plotanimate">3.3 Animation</a></h2>
<p>
Animation is done through the same interface as static plotting. The <code>startImage</code> and <code>endImage</code> call backs are called once for each frame of the animation.</p>
<p>
The OEM application can determine in advance whether a plot is static or an animation using the <code>PlotGetFrameCount</code> function:</p>
<dl>
<dt>
<code>M_INT PlotGetFrameCount( MPlot plot )</code><dd>
<p>
This function returns a count of the number of frames. A count of 0 indicates a static plot. A count of <var>N</var> &gt; 1 indicates an animation with <var>N</var> frames.</p>
</dl>
<h2>
<a name="plotinteract">3.4 Writing Interactive Plot Drivers</a></h2>
<p>
Since the actual <code>MPlot</code> data structure remains in existence until explicitly disposed of by <code>PlotDispose</code>, writing an interactive plot driver is just a matter of writing an interface, changing the attributes of the plot using <code>PlotSetAttribute</code> in response to interface actions, and then re-rendering the plot.</p>
<p>
The stand-alone Maple interactive plot drivers have a useful bounding box feature, whereby rotation of the plot is performed by rotating the bounding box (since very few devices can rotate a complex plot in real-time). To facilitate implementation of something like this, a predefined <code>MPlot</code> structure is provided by the OEM API:</p>
<p>
<code>MPlot boundingBox3D</code></p>
<p>
When passed to <code>PlotRender</code>, they will cause a 3D bounding box to be rendered. The orientation of the bounding box can be set by calling <code>PlotSetAttribute</code> with <code>BoundingBox3D</code> as the first parameter.</p>
<h2>
<a name="plotattrib">3.5 Plot Attributes</a></h2>
<p>
Attributes are passed to <code>PlotSetAttribute</code> using an attribute specifier (of type <code>MPlotAttribute</code>) and a value (of type <code>int)</code>. Attributes are retrieved by <code>PlotGetAttribute</code> using an attribute specifier; a value of type <code>int</code> is returned.</p>
<p>
The available attributes for plots are:</p>
<dl>
<dt>
<code>MPA_AXES</code> (2D and 3D)<dd>
<p>
Controls the selection of the lines drawn for the axes on the plot. It can take the five values <code>MPA_BOX</code>, <code>MPA_FRAME</code>, <code>MPA_NORMAL</code>, <code>MPA_NONE</code>, or <code>MPA_DEFAULT</code>. <code>MPA_BOX</code> axes consist of a rectangular box surrounding the plot with labels and tick marks on the left and lower lines. The <code>MPA_FRAME</code> axes style only draws the left and lower axes of the box with their associated tick marks and labels. <code>MPA_NORMAL</code> style draws two axes lines and attempts to have them intersect at the zero position on the axes. If 0 is not in the axes range, the axes intersect at the lower bound of the range. Style <code>MPA_NONE</code> results in no lines or labels.</p>
<dt>
<code>MPA_COLOR</code> (3D)<dd>
<p>
Several different color schemes can be specified for 3D plots. <code>MPA_COLOR_XYZ</code> varies the color along all three axes. <code>MPA_COLOR_XY</code> varies color as a function of <var>x</var> and <var>y</var>. <code>MPA_COLOR_Z</code> varies color from blue to red as a function of <var>z</var>. <code>MPA_COLOR_Z_HUE</code> is similar to <code>MPA_COLOR_Z</code>, but passes through the entire spectrum (giving a rainbow effect). <code>MPA_COLOR_Z_GRAY</code> plots in gray scale, varying intensity as a function of <var>z</var>. <code>MPA_COLOR_NONE</code> produces a monochrome plot. <code>MPA_COLOR_DEFAULT</code> uses device specific colors.</p>
<dt>
<code>MPA_GRID</code> (3D)<dd>
<p>
Specifies the type of grid to be superimposed on the plot (subject to the <code>MPA_STYLE</code> attribute; see below). <code>MPA_GRID_TRIANGULAR</code> superimposes a grid of right triangles. <code>MPA_GRID_RECTANGULAR</code> superimposes a grid of rectangles (an equal number in each direction).</p>
<dt>
<code>MPA_LIGHTING</code> (3D)<dd>
<p>
Controls the lighting model used. The lighting interacts with the colors of the plot itself. <code>MPA_LIGHTING_NONE</code> specifies no special lighting (ie. uniform ambient white light). <code>MPA_LIGHTING_USER</code> specifies the lighting that was given in the <code>plot3d</code> command within Maple. <code>MPA_LIGHTING_1</code> through <code>MPA_LIGHTING_4</code> specify one of four predefined sets of colored or white lights.</p>
<dt>
<code>MPA_LINESTYLE</code> (2D and 3D)<dd>
<p>
Specifies the type of line to be used in drawing the plot (not the axes). The meanings of the line styles will vary from device to device, but if possible, the different styles should be rendered distinctly. The predefined line style values are <code>MPA_LINESTYLE_SOLID</code>, <code>MPA_LINESTYLE_DOTTED</code>, <code>MPA_LINESTYLE_DASHED</code>, and <code>MPA_LINESTYLE_DASH_DOT</code>. Application-defined line styles are also permitted, but the line style must be represented by an integer value between 1 and 7 (1 through 4 correspond to the predefined styles). The rendering functions can deterime the desired line style using the <code>DECODE_LINESTYLE</code> macro.</p>
<dt>
<code>MPA_ORIENTATION_PHI</code> and <code>MPA_ORIENTATION_THETA</code> (3D)<dd>
<p>
Sets the orientation of the plot. Values can range from -180 to 180 degrees. <code>MPA_ORIENTATION_THETA</code> controls rotation around the <var>z</var>-axis. <code>MPA_ORIENTATION_PHI</code> controls rotation around the horizontal axis.</p>
<dt>
<code>MPA_PROJECTION</code> (3D)<dd>
<p>
Controls the projection used in the 3D to 2D transformation. <code>MPA_PROJECTION_ORTHOGONAL</code> specifies an orthogonal projection (ie. the viewer is infinitely far away). <code>MPA_PROJECTION_FAR_PERSPECTIVE</code>, <code>MPA_PROJECTION_MEDIUM_PERSPECTIVE</code>, and <code>MPA_PROJECTION_NEAR_PERSPECTIVE</code>, specify perspective projections, wherein <code>FAR</code>, <code>MEDIUM</code>, and <code>NEAR</code> refer to the viewer's distance from the object. <code>NEAR</code> creates a sense of being extremely close to the object.</p>
<dt>
<code>MPA_SCALING</code> (2D and 3D)<dd>
<p>
Specifies if scaling of the axes is to be equal for all axes (<code>MPA_SCALING_CONSTRAINED</code>, the object being scaled such that the largest axis fits), or indepdentent for each axis (<code>MPA_SCALING_UNCONSTRAINED</code>, the object being scaled so as to fill the display area in all dimensions).</p>
<dt>
<code>MPA_STYLE</code> (2D and 3D)<dd>
<p>
Controls the rendering style of the plot. Not all options apply to both 2D and 3D plots. <code>MPA_STYLE_HIDDEN</code> indicates that 3D plots are to be plotted as a wire frame, with hidden lines removed. <code>MPA_STYLE_PATCH</code>, <code>MPA_STYLE_PATCH_NO_GRID</code>, and <code>MPA_STYLE_PATCH_CONTOUR</code> indicate 3D plots with surface patches with a grid, without a grid, and with contour lines respectively. <code>MPA_STYLE_POINT</code> specifies that only vertices should be rendered (for 2D and 3D plots). <code>MPA_STYLE_LINE</code> indicates that consecutive points are joined by lines (a transparent wire frame for 3D plots). <code>MPA_STYLE_CONTOUR</code> indicates that 3D plots should be drawn only as contour lines, each contour line appearing at the level it represents. <code>MPA_STYLE_FLAT</code> contour produces a plot where all the contours are rendered in two dimensions.</p>
<dt>
<code>MPA_SYMBOL</code> (2D and 3D)<dd>
<p>
Specifies the symbol to be used to draw points (vertices). The predefined choices are <code>MPA_SYMBOL_DEFAULT</code>, <code>MPA_SYMBOL_CROSS</code>, <code>MPA_SYMBOL_DIAMOND</code>, <code>MPA_SYMBOL_BOX</code>, <code>MPA_SYMBOL_CIRCLE</code>, and <code>MPA_SYMBOL_POINT</code>. The rendering of these symbols is up to the rendering functions, which can determine the desired symbol using the <code>DECODE_SYMBOL</code> macro. Application specific symbols can be specified as well, as an integer between 1 and 15 (1 through 6 correspond to the predefined symbols).</p>
<dt>
<code>MPA_THICKNESS</code> (2D and 3D)<dd>
<p>
Controls the thickness of line to use for rendering. The predefined symbols <code>MPA_THICKNESS_THIN</code>, <code>MPA_THICKNESS_MEDIUM</code>, and <code>MPA_THICKNESS_THICK</code> correspond to the thicknesses (1 through 3) usually generated by Maple. Thicknesses of up to 15 can be specified. The rendering functions can determine the desired thickness of a line using the <code>DECODE_THICKNESS</code> macro.</p>
</dl>
<h1>
<a name="realmath">4. Real Math Output</a></h1>
<p>
Output using real math notation is accomplished when the Maple kernel sends an expression to the <code>realMathCallBack</code>, which in turn passes the expression to the desired real math renderer. The form in which the output is produced depends on the renderer selected, and the formatting options passed to the renderer.</p>
<p>
The real math rendering interface is defined in "<code>moem2d.h</code>".</p>
<h2>
<a name="realmathrender">4.1 Real Math Renderers</a></h2>
<p>
Several real math renderers are provided. Not all renderers are available on all platforms. The calling sequence for the renderers vary for each renderer. However, several parameters are common to several of them:</p>
<dl>
<dt>
<code>M_EXPR expr</code><dd>
<p>
This specifies the expression to be formatted, and will have been obtained as the <code>expr</code> parameter to the <code>realMathCallBack</code>.</p>
<dt>
<code>RealMathOptions fmtOpts</code><dd>
<p>
This specifies various aspects of the formatting to be carried out. See section 4.2, <a href="#realmathoptions"><cite>Real Math Formatting Options</cite></a>, for further details.</p>
<dt>
<code>void *data</code><dd>
<p>
The <code>data</code> parameter is an arbitrary OEM supplied value. It is passed on as the first argument to any call back functions. One use for the <code>data</code> parameter is to pass a C++ object of which the call backs are member functions. The data parameter then becomes <code>this</code> in the member functions.</p>
</dl>
<p>
The remaining parameters to the renderers are described with the renderers. The available renderers are:</p>
<dl>
<dt>
<pre>
char *RealMathText( M_EXPR expr,
		    RealMathOptions fmtOpts,
		    M_BOOL (*writeChar)( void *data, int c ),
		    M_BOOL (*writeAttrib)( void *data, int a ),
		    void *data )</pre>
<dd>
<p>
This renderer formats expressions using printable characters in the same way that TTY versions of Maple do. It is assumed that the resulting character stream will be printed using a fixed pitch font (such as Courier).</p>
<p>
The <code>writeChar</code> parameter defines a call back function to which the characters will be passed in turn. The characters will all be printable characters. Leading spaces are added to achieve the appropriate alignment. No trailing spaces are ever generated. A newline ('<code>\n</code>') character is sent at the end of each line. The <code>writeChar</code> function can terminate rendering by returning <code>TRUE</code>.</p>
<p>
The <code>writeAttrib</code> parameter defines a call back function to which attribute information will be passed (if enabled, see section 4.2, <a href="#realmathoptions"><cite>Real Math Formatting Options</cite></a>). The attribute passed to <code>writeAttrib</code> applies to all subsequent characters passed to <code>writeChar</code> until another attribute is passed to <code>writeAttrib</code>. The possible values for the attribute are:</p>
<dl>
<dt>
<code>FN_NORMAL</code><dd>
<p>
Normal text mode.</p>
<dt>
<code>FN_BOLD</code><dd>
<p>
<b>Boldfaced text mode.</b> This is used for key words in Maple procedures.</p>
<dt>
<code>FN_ITAL</code><dd>
<p>
<i>Italic text mode.</i> This is used for variable names.</p>
</dl>
<p>
The <code>writeAttrib</code> function can terminate rendering by returning <code>TRUE</code>. The <code>writeAttrib</code> function can be omitted by passing <code>NULL</code> for the <code>writeAttrib</code> parameter.</p>
<p>
<code>RealMathText</code> will return <code>NULL</code> if successful, or a pointer to an error message if unsuccessful (note that it may return the same pointer in all cases of failure; if you need to save the message, make a copy of it immediately).</p>
<dt>
<pre>
char *RealMathLaTeX( M_EXPR expr,
		     RealMathOptions fmtOpts,
		     M_BOOL (*writeChar)( void *data, int c ),
		     M_BOOL inLine,
		     void *data )</pre>
<dd>
<p>
This renderer formats expressions using LaTeX.</p>
<p>
The <code>writeChar</code> parameter defines a call back function to which the resulting stream of LaTeX output will be passed. The <code>writeChar</code> function can terminate rendering by returning <code>TRUE</code>.</p>
<p>
The <code>inLine</code> parameter specifies whether the generated LaTeX code is intended for in-line math mode (when <code>inLine</code> is <code>TRUE</code>) or display math mode (when <code>inLine</code> is <code>FALSE</code>).</p>
<p>
<code>RealMathLaTeX</code> will return <code>NULL</code> if successful, or a pointer to an error message if unsuccessful (note that it may return the same pointer in all cases of failure; if you need to save the message, make a copy of it immediately).</p>
<dt>
<pre>
char *RealMathMetaFile( M_EXPR expr,
			RealMathOptions fmtOpts,
			M_BOOL (*writeMetaFile)( void *data,
						 RealMathMF mf )
			int metaFileType,
			char *fileName,
			HDC deviceContext,
			M_BOOL multiPage,
			void *data )</pre>
<dd>
<p>
This renderer formats expressions into a Windows MetaFile.</p>
<p>
The <code>fmtOpts</code> parameter is as described in section 4.2, <a href="#realmathoptions"><cite>Real Math Formatting Options</cite></a>. Any measurements (eg. <code>fontSize</code>, <code>deviceWidth</code>) are specified in points. The default <code>fontName</code> (if <code>NULL</code> is specified) is "<code>Times New Roman</code>". The default <code>fontSize</code> (if 0 is specified) is 12 points.</p>
<p>
The <code>writeMetaFile</code> parameter defines a call back function to which the resulting metafile(s) will be passed. The <code>writeMetaFile</code> function can terminate rendering by returning <code>TRUE</code>.</p>
<p>
The <code>metaFileType</code> parameter specifies the type of metafile to generate:</p>
<dl>
<dt>
<code>MF_STANDARD</code><dd>
<p>
Standard 16-bit Windows metafile.</p>
<dt>
<code>MF_ALDUS</code><dd>
<p>
Aldus Corporation placeable metafile.</p>
<dt>
<code>MF_ENHANCED</code><dd>
<p>
Win32 enhanced metafile.</p>
</dl>
<p>
The <code>fileName</code> parameter indicates the name of the file(s) into which the metafile should be written. If <code>NULL</code> is specified, the metafile is not written to a file, and a handle is returned.</p>
<p>
The <code>deviceContext</code> parameter indicates the device context that the <code>metafile</code> is intended to be used with. If <code>NULL</code> is specified, the display device context will be used. Generally, specifying <code>NULL</code> provides the best results for most uses, although it may be necessary to specify an appropriate printer device context when a printer font has been specified.</p>
<p>
The <code>multiPage</code> parameter indicates whether or not multiple-page output is to be allowed. If set to <code>FALSE</code> and an expression will not fit on a page, an error will be returned.</p>
<p>
<code>RealMathMetaFile</code> will return <code>NULL</code> if successful, or a pointer to an error message if unsuccessful (note that it may return the same pointer in all cases of failure; if you need to save the message, make a copy of it immediately).</p>
<dt>
<pre>
HANDLE RealMathPict( M_EXPR expr,
		     RealMathOptions fmtOpts )</pre>
<dd>
<p>
This renderer formats expressions into a Macintosh PICT. On success, it returns a handle to the PICT. If it fails, zero is returned instead.</p>
</dl>
<h3>
<a name="writemetafile">4.1.1 The <code>writeMetaFile</code> Call Back</a></h3>
<p>
The <code>writeMetaFile</code> call back function passed to <code>RealMathMetaFile</code> is defined as follows (but obviously need not be named "<code>writeMetaFile</code>"):</p>
<dl>
<dt>
<pre>
M_BOOL writeMetaFile( void *data, RealMathMF mf )</pre>
<dd>
<p>
The <code>data</code> parameter is passed the value that was passed as the <code>data</code> parameter of the <code>RealMathMetaFile</code> function. If <code>writeMetaFile</code> is to be a C++ member function, the data parameter is not declared, and becomes the value of <code>this</code> instead.</p>
<p>
The <code>mf</code> parameter is a pointer to a structure giving and describing the metafile being written. This structure is defined as follows:</p>
<pre>
typedef struct {
	int metaFileType;
	int currentNumber, maximumNumber;
	int resolution;
	M_INT width, height;
	union {
		char *fileName;
		HMETAFILE standard;
		HENHMETAFILE enhanced;
	} metaFile;
} RealMathMFVec, *RealMathMF;</pre>
<p>
These fields give detailed information about the metafile. The fields are defined as follows:</p>
<dl>
<dt>
<code>int metaFileType;</code><dd>
<p>
The type of metafile, as originally passed to the <code>RealMathMetaFile</code> function. This is used to indicate which member of the <code>metaFile</code> union (described below) is the appropriate one.</p>
<dt>
<code>int currentNumber, maximumNumber;</code><dd>
<p>
The page number of a multi-page metafile, and the number of pages that will be generated (the latter will never change in a sequence of calls to <code>writeMetaFile</code>).</p>
<dt>
<code>int resolution;</code><dd>
<p>
The number of metafile units per inch. This is generally 1440 (corresponding to the MS-Windows TWIPS mapping mode).</p>
<dt>
<code>M_INT width, height;</code><dd>
<p>
The width and height of the metafile, in metafile units.</p>
<dt>
<code>char *fileName;</code><dd>
<p>
If you specified a file name in the call to <code>RealMathMetaFile</code>, this will be the actual file name that was used (including page number and extension as appropriate). If you did not specify a file name, this will be <code>NULL</code>.</p>
<dt>
<code>HMETAFILE standard;<br>
MENHMETAFILE enhanced;</code><dd>
<p>
If you did not specify a file name in the call to <code>RealMathMetaFile</code>, this will be the handle to the generated metafile. The ownership of this handle is considered to have been passed to the OEM application, so you are responsible for freeing it when you no longer need it. If you did specify a file name, the handle will be <code>NULL</code>.</p>
</dl>
<p>
Note that only one of <code>metaFile.fileName</code>, <code>metaFile.standard</code>, or <code>metaFile.enhanced</code> is valid, based on the value of the <code>metaFileType</code> field.</p>
</dl>
<p>
Note that although ownership of the metafile handle is considered to be with the OEM application, ownership of the memory occupied by the <code>RealMathMF</code> structure stays with Maple. Therefore, if you need to retain any information from this structure after the call to your <code>writeMetaFile</code> call back returns, you must make a copy of this information first. As a matter of fact, subsequent calls to your <code>writeMetaFile</code> call back could very well be passed a pointer to the same <code>RealMathMFVec</code> structure, with new values filled in.</p>
<p>
The <code>writeMetaFile</code> call back function can terminate rendering (of a multiple page output) by returning <code>TRUE</code>.</p>
<h2>
<a name="realmathoptions">4.2 Real Math Formatting Options</a></h2>
<p>
Some aspects of formatting expressions using real math notation are controlled by a formatting control structure, defined as follows:</p>
<pre>
typedef struct {
	char *fontName;
	int fontSize;
	int numFontSizes;
	int deviceWidth;
	int deviceHeight;
	int tabWidth;
	int firstIndent;
	int subsequentIndent;
	int lineSpace;
	M_BOOL labelling;
	int minLabelWidth;
	int verboseProc;
} RealMathOptionsVec, *RealMathOptions;</pre>
<p>
Not all of these fields are honoured by all of the renderers. For example, the <code>fontName</code> field is ignored by the <code>RealMathText</code> renderer. The fields of the structure are defined as follows:</p>
<dl>
<dt>
<code>char *fontName</code><dd>
<p>
The name of the font to use in rendering. The format of the font name is device dependent. Not all renderers respect the <code>fontName</code>. Passing <code>NULL</code> for the <code>fontName</code> will use an appropriate default.</p>
<dt>
<code>int fontSize</code><dd>
<p>
The size, in points, of the largest font to be used in formatting. As smaller sizes are required (eg. for exponents), they are selected relative to this size automatically. Not all renderers respect the <code>fontSize</code>. Passing 0 for the <code>fontSize</code> will use an appropriate default.</p>
<dt>
<code>int numFontSizes</code><dd>
<p>
The maximum number of distinct font sizes to be used in formatting expressions.</p>
<dt>
<code>int deviceWidth<br>
int deviceHeight</code><dd>
<p>
The dimensions, in device dependent units, of the output device. Expressions will be formatted to fit within the specified width. No single "line" of an expression ("line" in the mathematical formatting sense, not in the text file sense) will be higher than the specified height.</p>
<dt>
<code>int tabWidth</code><dd>
<p>
The number of character widths (of the character "x" when a proportionally spaced font is used) used to make up one level of indendation when formatting procedures.</p>
<dt>
<code>int firstIndent</code><dd>
<p>
The amount of leading indentation, in device dependent units, for the first line of a multi-line expression.</p>
<dt>
<code>int subsequentIndent</code><dd>
<p>
The amount of leading indentation, in device dependent units, for the subsequent lines of a multi-line expression.</p>
<dt>
<code>int lineSpace</code><dd>
<p>
The spacing between lines of output, in device dependent units.</p>
<dt>
<code>M_BOOL labelling</code><dd>
<p>
Whether or not sub-expression labelling is to be used in the output. If <code>TRUE</code>, labels of the form <code>%<var>n</var></code> will be used for common sub-expressions, with definitions for each label given at the end of the output.</p>
<dt>
<code>int minLabelWidth</code><dd>
<p>
The approximate minimum width, in device dependent units, for a common sub-expression to be a candidate for sub-expression labelling.</p>
<dt>
<code>int verboseProc</code><dd>
<p>
The extent to which procedure bodies are printed. With a setting of 1, only non-copyrighted procedures have their bodies printed. With a setting of 2, all procedures have their bodies printed. With a setting of 3, all procedures have their bodies printed, and the contents of a procedure's remember table (if any) are printed after the procedure in the form of Maple comments.</p>
<dt>
<code>int showAssumed</code><dd>
<p>
Controls how variables with assumptions should be printed. With a setting of 0, assumed variables are printed the same way as plain variables. With a setting of 1, assumed variables are printed with a trailing tilde ("<code>~</code>"). With a setting of 2, they are printed as normal variables, but a list of assumed variables is printed at the end of the expression.</p>
</dl>
<p>
Stand-alone Maple keeps track of formatting options using interface variables. These variables are examined and manipulated using the Maple <code>interface</code> function. There is one set of interface variables for each kernel that has been created (by <code>MapleInitialize</code>). The OEM interface does not use these settings for real math formatting; it uses the specified <code>RealMathOptions</code> instead. The <code>DefaultRealMathOptions</code> function can be used to obtain a set of <code>RealMathOptions</code> that is based on the interface variables corresponding to a specified kernel.</p>
<dl>
<dt>
<pre>
RealMathOptions DefaultRealMathOptions( int mapleID )</pre>
<dd>
<p>
This returns a pointer to a <code>RealMathOptions</code> structure containing default settings based on the Maple interface variables corresponding to the kernel specified by <code>mapleID</code>.</p>
<p>
Note that <code>RealMathOptions</code> may return the same pointer to the same static structure each time it is called. If you need to save the returned formatting options, make a copy of the structure. For example:</p>
<pre>
RealMathOptionsVec saveOpts;
saveOpts = *DefaultRealMathOptions(1);</pre>
</dl>
<h1>
<a name="parse and render">4.3 Rendering an Unevaluated Expression</a></h1>
<p>
In some applications, it may be desirable to render a mathematical expression that has not been processed (eg. simplified or evaluated) by Maple. This can be done by calling the <code>MapleParse</code> function, and passing the returned result to one of the real math renderers.</p>
<p>
The <code>MapleParse</code> function is defined as follows:</p>
<dl>
<dt>
<pre>
M_EXPR MapleParse( char *expr,
		   void (*errorCallBack)( void *data, M_INT offset,
		   			  char *msg ),
		   void *data )</pre>
<dd>
<p>
The <code>expr</code> parameter gives the statement to be parsed, expressed in Maple syntax. If the expression contains a syntax error, <code>MapleParse</code> will call the <code>errorCallBack</code> with a syntax error message and the offset into <code>expr</code> of the error, and <code>MapleParse</code> will return <code>NULL</code>.</p>
<p>
The <code>data</code> parameter is an arbitrary OEM supplied value. It is passed on as the first argument to the <code>errorCallBack</code> function.</p>
</dl>
<p>
<code>ParseMaple</code> will only parse the expression and convert it into Maple's internal form, suitable for passing to a real math renderer. It will not perform any evaluation or simplification on such an expression. For example, passing the expression <code>1/x*2+1/2*1/4</code> will result in a rendering like this:</p>
<pre>
                           1       1   1
                          --- 2 + --- ---
                           x       2   4  
</pre>
<p>
The lifetime of the returned expression is only until the next call to <code>MapleParse</code>. After that, the expression returned from the previous call is subject to garbage collection, and should no longer be referenced.</p>
<h1>
<a name="help">5. Maple's On-line Help Database</a></h1>
<p>
Maple's on-line help system is also available to the OEM application. In earlier releases of Maple, the on-line help pages were stored in the Maple library in Maple's ".m" format. Requests for help were made by passing a statement of the form "<code>help(topic)</code>" to the kernel. The kernel would then return the help page to the OEM application as a sequence of output lines.</p>
<p>
During the development of Maple V Release 4, the help system has been entirely rewritten, and is now completely independent of the kernel. Therefore, the help system is available to OEM applications directly; the kernel is not involved.</p>
<p>
The help system is accessed through a pair of functions:</p>
<dl>
<dt>
<pre>
char *HelpSetPath( char *path )</pre>
<dd>
<p>
Sets the search path for help databases.</p>
<p>
The <code>path</code> parameter is a string of directory names, separated by commas. When <code>HelpLookup</code> is called, the help system will look for a "<code>maple.hdb</code>" file in each directory in turn, until it finds one that contains the topic of interest.</p>
<p>
<code>HelpSetPath</code> will return <code>NULL</code> if successful, or a pointer to an error message if unsuccessful (note that it may return the same pointer in all cases of failure; if you need to save the message, make a copy of it immediately).</p>
<dt>
<pre>
char *HelpLookup( char *topic,
		  char *section,
		  M_BOOL (*writeChar)( void *data, int c ),
		  M_BOOL (*writeAttrib)( void *data, int a ),
		  int width,
		  void *data )</pre>
<dd>
<p>
This function is used to look up an actual topic. The results are passed as a stream of characters and attributes to the specified call back functions.</p>
<p>
The <code>topic</code> parameter specifies the help page to be looked at. The topic is generally a Maple keyword, function name, or symbol, or a pair of such, separated by a comma (to refer to topics in sub-packages).</p>
<p>
The section parameter indicates which section of the page to display. If this is passed as "" or <code>NULL</code>, the entire page is displayed. To restrict display to a particular section of the page, one of the following values can be passed:</p>
<dl>
<dt>
<code>"<code>usage</code>"</code><dd>
<p>
Shows just the function name (one line description) and calling sequence information.</p>
<dt>
<code>"<code>description</code>"</code><dd>
<p>
Shows the detailed description of the function.</p>
<dt>
<code>"<code>examples</code>"</code><dd>
<p>
Shows examples of the function's usage.</p>
<dt>
<code>"<code>seealso</code>"</code><dd>
<p>
Shows a list of alternate topics that may be related to this function.</p>
</dl>
<p>
The <code>writeChar</code> parameter defines a call back function to which the characters will be passed in turn. The characters will all be printable characters. Leading spaces are added to achieve the appropriate alignment. No trailing spaces are ever generated. A newline ('<code>\n</code>') character is sent at the end of each line. The <code>writeChar</code> function can terminate rendering by returning <code>TRUE</code>.</p>
<p>
The <code>writeAttrib</code> parameter defines a call back function to which attribute information will be passed. The attribute passed to <code>writeAttrib</code> applies to all characters passed to <code>writeChar</code> until another attribute is passed to <code>writeAttrib</code>. The possible values for the attribute are:</p>
<dl>
<dt>
<code>FN_NORMAL</code><dd>
<p>
Normal text mode.</p>
<dt>
<code>FN_BOLD</code><dd>
<p>
<b>Boldfaced text mode.</b> This is used for key words in Maple procedures in Maple example output, and for section headings.</p>
<dt>
<code>FN_ITAL</code><dd>
<p>
<i>Italic text mode.</i> This is used for variable names in Maple example output.</p>
<dt>
<code>FN_REV</code><dd>
<p>
Reversed video text. This is used for links to other topics.</p>
</dl>
<p>
The <code>writeAttrib</code> function can terminate rendering by returning <code>TRUE</code>. The <code>writeAttrib</code> function can be omitted by passing <code>NULL</code> for the <code>writeAttrib</code> parameter.</p>
<p>
The <code>width</code> parameter indicates the width, in characters, to which the help information should be formatted.</p>
<p>
The <code>data</code> parameter is an arbitrary OEM supplied value. It is passed on as the first argument to the call back functions. One use for the <code>data</code> parameter is to pass a C++ object of which the call backs are member functions. The <code>data</code> parameter then becomes <code>this</code> in the member functions.</p>
<p>
<code>HelpLookup</code> will return <code>NULL</code> if successful, or a pointer to an error message if unsuccessful (note that it may return the same pointer in all cases of failure; if you need to save the message, make a copy of it immediately).</p>
</dl>
<p>
The on-line help interface is defined in "<code>moemhelp.h</code>".</p>
<h1>
<a name="packaging">6. Packaging</a></h1>
<p>
This section describes the form in which the OEM version is distributed on different platforms.</p>
<p>
The OEM version is shipped as five additional subdirectories to the main Maple directory: <code>bin</code>, <code>example</code>, <code>inc</code>, <code>lib</code>, and <code>txt</code>. The <code>bin</code> directory contains an example program. The <code>example</code> directory contains sample source, and a platform dependant <code>makefile</code>. The <code>include</code> directory will contain all the <code>#include</code> files described in this document. The <code>lib</code>directory contains the necessary object library archive files. Note: this<code>lib</code> directory should not be confused with the Maple archive library directory; the latter contains the <code>maple.ind</code>, <code>maple.lib</code>, and <code>maple.hdb</code>files used by Maple at run-time. The <code>txt</code> directory contains this document.</p>
<p>
Sample plot drivers are included in the form of C source files. Each source file implements a single plot driver, and contains a plot device vector, a function to initialize it, and the actual functions implementing the components of the device vector. The sample drivers provided are for character plots and a simple platform specific interactive driver.</p>
<p>
The OEM API is not fully re-entrant. Although an OEM supplied call back function <strong>can</strong> recursively call MapleEvaluate, in implementations supporting multiple kernels, it must call the same kernel that called the call back.</p>
<h2>
<a name="unix">6.1 UNIX</a></h2>
<p>
On UNIX platforms, the OEM version consists of a single object library (liboem.a) containing an OEM specific component, and all the components required to to support it and to communicate with a Maple kernel (the contents of our libxpp, libiplot, libplot, libhelp, libkapi, and libsupport). All these additional components are exactly the same as the ones we use; they are merely packaged into a single library for the convenience of the OEM user.</p>
<p>
A Motif-specific interactive UNIX plot driver is supplied, based on the hints given in section 3.4, <a href="#plotinteract"><cite>Writing Interactive Plot Drivers</cite></a>.</p>
<p>
The UNIX version will support multiple kernels (currently not supported).</p>
<h2>
<a name="windows">6.2 Microsoft Windows</a></h2>
<p>
Under Microsoft Windows, the OEM version consists of a DLL (liboem.dll) which exports the functions described in this document. The other components required to support the OEM interface are already shipped as DLLs as part of the stand-alone Maple product.</p>
<p>
A Windows-specific interactive plot driver is supplied, based on the hints given in section 3.4, <a href="#plotinteract"><cite>Writing Interactive Plot Drivers</cite></a>.</p>
<p>
The Windows OEM version will support multiple kernels under Windows 95 (currently not supported) and Windows NT (currently not supported), but not under Windows 3.1.</p>
<h2>
<a name="mac">6.3 Apple Macintosh</a></h2>
<p>
On the Apple Macintosh and Power Macintosh, the OEM version will consist of of a single object library (liboem.lib) containing an OEM specific component, a Maple kernel, and all the required supporting components (the contents of our libxpp, libiplot, libplot, libhelp, libkapi, and libsupport). All these additional components are exactly the same as the ones we use; they are merely packaged into a single library for the convenience of the OEM user.</p>
<p>
A Macintosh-specific interactive plot driver is supplied, based on the hints given in section 3.4, <a href="#plotinteract"><cite>Writing Interactive Plot Drivers</cite></a>.</p>
<p>
The Macintosh OEM version will <strong>not</strong> support multiple kernels.</p>
</body>
</html>
