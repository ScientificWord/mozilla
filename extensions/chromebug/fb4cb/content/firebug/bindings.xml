<?xml version="1.0"?>

<!DOCTYPE window [
<!ENTITY % firebugDTD SYSTEM "chrome://firebug/locale/firebug.dtd">
%firebugDTD;
]>

<bindings xmlns="http://www.mozilla.org/xbl"
    xmlns:xbl="http://www.mozilla.org/xbl"
    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

<binding id="initializer">
    <implementation>
        <destructor><![CDATA[
           FirebugChrome.shutdown();
        ]]></destructor>
    </implementation>
</binding>

<binding id="panelBar">

    <!-- The XUL structure for the panel bar is specified in the XUL source
         inside each "panelBar" element.  This allows us to have panel bars
         with substantially different layous, including the ability to embed
         one panel bar within another - albeit at some cost in maintainability.
    -->
    <content>
        <children/>
    </content>

    <implementation>
        <constructor><![CDATA[
            this.tabBox = this.getChildElement("tabBox");
            this.deck = this.getChildElement("deck");
            this.browser = this.getChildElement("browser");
            this.panelTabs = this.getChildElement("panelTabs");
            this.tabMap = {};

            // We initialize Firebug from here instead of from the onload event because
            // we need to make sure it is initialized before the browser starts loading
            // the home page
            try
            {
                if(FirebugChrome.panelBarReady(this))
                {
                }
            }
            catch (e)
            {
                dump("bindings panelBar ctor FAILs: "+ e+"\n");
                dump("window.top "+window.top.location+" window.opener: "+window.opener+"\n");
            }
        ]]></constructor>

        <method name="getChildElement">
            <parameter name="id"/>
            <body><![CDATA[
                // Construct a unique ID from the panel bar ID and the child element ID,
                // for example: "panelBar1-panelTabs".  This allows us to define children
                // in the XUL source, which in turn allows us to have panel bars with
                // substantially different layouts.
                return document.getElementById(this.id + "-" + id);
            ]]></body>
        </method>

        <method name="createTab">
            <parameter name="panelType"/>
            <body><![CDATA[
            var tab = document.createElement("panelTab");
            tab.panelType = panelType;

            var title = Firebug.getPanelTitle(panelType);
            tab.setAttribute("label", title);
            tab.setAttribute("tooltiptext", title);

            return this.tabMap[panelType.prototype.name] = tab;
            ]]></body>
        </method>

        <method name="addTab">
            <parameter name="panelType"/>
            <body><![CDATA[
            var tab = this.createTab(panelType);
            this.panelTabs.appendChild(tab);
            ]]></body>
        </method>

        <method name="updatePanels">
            <parameter name="panelTypes"/>
            <body><![CDATA[
                this.tabMap = {};

                // Replace tabs at the same position if type has changed
                var i = 0;
                var tab = this.panelTabs.firstChild;
                for (; i < panelTypes.length && tab; tab = tab.nextSibling)
                {
                    var panelType = panelTypes[i++];
                    if (tab.panelType.prototype.name != panelType.prototype.name)
                    {
                        var newTab = this.createTab(panelType);
                        this.panelTabs.replaceChild(newTab, tab);
                        tab = newTab;
                    }
                    else
                        this.tabMap[panelType.prototype.name] = tab;
                }

                // Remove old tabs after the last panel
                while (tab)
                {
                    var nextTab = tab.nextSibling;
                    this.panelTabs.removeChild(tab);
                    tab = nextTab;
                }

                // Insert new tabs after the last old tab
                for (; i < panelTypes.length; ++i)
                {
                    var panelType = panelTypes[i];
                    var newTab = this.createTab(panelType);
                    this.panelTabs.appendChild(newTab);
                }

                // Make sure hidden panels are collapsed.
                var prefValue = Firebug.getPref(Firebug.prefDomain, "hiddenPanels");
                if (!prefValue || !prefValue.length)
                    return;

                var closedPanels = prefValue.split(" ");
                for (i=0; i<closedPanels.length; i++)
                {
                    var tab = this.tabMap[closedPanels[i]];
                    if (tab)
                        FBL.collapse(tab, true);
                }
            ]]></body>
        </method>

        <method name="selectTab">
            <parameter name="tab"/>
            <body><![CDATA[
                var panelName = tab ? tab.panelType.prototype.name : null;
                if (panelName && !tab.panelType.prototype.parentPanel)
                    Firebug.setPref(Firebug.prefDomain, "defaultPanelName", panelName);

                this.selectPanel(panelName);

                var scrollBox = this.getElementsByClassName("tabbrowser-arrowscrollbox").item(0);
                scrollBox.ensureVisibleTab(tab);
            ]]></body>
        </method>

        <method name="selectPanel">
            <parameter name="panelName"/>
            <parameter name="forceUpdate"/>
            <parameter name="noRefresh"/>
            <body><![CDATA[
                var tab = panelName ? this.tabMap[panelName] : null;
                var panelType = tab ? tab.panelType : null;
                var panel = FirebugContext ? FirebugContext.getPanel(panelName) : null;

                // Make sure the panel is visible.
                this.togglePanel(panelName, true);

                if (panel && (panel == this.selectedPanel) && !forceUpdate)
                    return panel;

                this.hideSelectedPanel();

                if (!panel)
                    this.tabBox.setAttribute("collapsed", "true");
                else
                    this.tabBox.removeAttribute("collapsed");

                if (this.selectedTab)
                    this.selectedTab.selected = false;

                this.selectedTab = tab;
                this.selectedPanel = panel;

                if (tab)
                {
                    tab.selected = true;
                    if (Firebug.A11yModel && Firebug.A11yModel.isEnabled() && Firebug.A11yModel.tabFocused &&!forceUpdate)
                        tab.focus();
                }

                if (panel)
                {
                    panel.panelBrowser = panel.browser ? panel.browser : this.browser;
                    panel.panelBrowser.currentPanel = panel;
                }

                if (!panel || panel.panelBrowser != this.browser)
                    this.browser.currentPanel = null;

                var ev = document.createEvent("Events");
                ev.initEvent("selectingPanel", true, false);
                this.dispatchEvent(ev);

                if (panel)
                {
                    var sel = this.browser.contentWindow.getSelection();
                    if (sel)
                        sel.removeAllRanges();

                    this.showSelectedPanel();  // sets active attribute true

                    if (!noRefresh && panel.needsRefresh)
                    {
                        delete panel.needsRefresh;
                        panel.refresh();
                    }

                    if (panel.browser)
                    {
                        if (panel.browser.parentNode != this.deck)
                            this.deck.appendChild(panel.browser);

                        this.deck.selectedPanel = panel.browser;
                    }
                    else
                        this.deck.selectedPanel = this.browser;
                }

                var ev = document.createEvent("Events");
                ev.initEvent("selectPanel", true, false);
                this.dispatchEvent(ev);

                return panel;
            ]]></body>
        </method>

        <method name="showSelectedPanel">
            <body><![CDATA[
                var panel = this.selectedPanel;
                if (panel)
                {
                    panel.visible = true;
                    panel.panelNode.setAttribute("active", true);

                    var state = Firebug.getPanelState(panel);
                    panel.show(state);

                    this.updateToolbarVisibility();
                }
            ]]></body>
        </method>

        <method name="updateToolbarVisibility">
            <body><![CDATA[
                var noButtons = true;
                var toolbarInner = FBL.$("fbToolbarInner");
                var box = toolbarInner.firstChild;
                while (box)
                {
                    var tagName = box.tagName.toLowerCase();
                    var collapsed = box.getAttribute("collapsed");
                    if (collapsed != "true")
                    {
                        if (tagName == "panelstatus" && !box.firstChild)
                        {
                            box = box.nextSibling;
                            continue;
                        }

                        noButtons = false;
                        break;
                    }

                    box = box.nextSibling;
                }

                var toolbar = FBL.$("fbToolbox");
                FBL.collapse(toolbar, noButtons);
            ]]></body>
        </method>

        <method name="hideSelectedPanel">
            <body><![CDATA[
                var oldPanel = this.selectedPanel;
                if (oldPanel)
                {
                    var state = FBL.getPersistedState(FirebugContext, oldPanel.name);
                    oldPanel.hide(state);

                    oldPanel.visible = false;  // xxxjjb Why three ways to un-show the panel?
                    oldPanel.panelNode.removeAttribute("active");
                }
            ]]></body>
        </method>

        <method name="getTab">
            <parameter name="panelName"/>
            <body><![CDATA[
                return this.tabMap[panelName];
            ]]></body>
        </method>

        <method name="closePanel">
            <parameter name="panelName"/>
            <body><![CDATA[
                var tab = this.getTab(panelName);
                FBL.collapse(tab, true);
                this.storeHiddenPanels();

                if (this.selectedTab != tab)
                    return;

                // If the selected panel has been closed, select the first one that is visible.
                tab = this.panelTabs.firstChild;
                while (tab)
                {
                    if (FBL.isVisible(tab))
                    {
                        this.selectTab(tab);
                        break;
                    }
                    tab = tab.nextSibling;
                }
            ]]></body>
        </method>

        <method name="openPanel">
            <parameter name="panelName"/>
            <body><![CDATA[
                var tab = this.getTab(panelName);
                FBL.collapse(tab, false);
                this.storeHiddenPanels();
            ]]></body>
        </method>

        <method name="togglePanel">
            <parameter name="panelName"/>
            <parameter name="forceOpen"/>
            <body><![CDATA[
                var tab = this.getTab(panelName);
                if (!tab)
                    return;

                var open = FBL.isVisible(tab);
                if (open && forceOpen)
                    return;

                if (open)
                    this.closePanel(panelName);
                else
                    this.openPanel(panelName);
            ]]></body>
        </method>

        <method name="storeHiddenPanels">
            <body><![CDATA[
                var closedPanels = [];
                var tab = this.panelTabs.firstChild;
                while (tab)
                {
                    if (!FBL.isVisible(tab))
                        closedPanels.push(tab.panelType.prototype.name);
                    tab = tab.nextSibling;
                }
                Firebug.setPref(Firebug.prefDomain, "hiddenPanels", closedPanels.join(" "));
            ]]></body>
        </method>

        <method name="openAllPanels">
            <parameter name="event"/>
            <body><![CDATA[
                var tab = this.panelTabs.firstChild;
                while (tab)
                {
                    if (!FBL.isVisible(tab))
                        FBL.collapse(tab, false);
                    tab = tab.nextSibling;
                }
                Firebug.setPref(Firebug.prefDomain, "hiddenPanels", "");
                FBL.cancelEvent(event);
            ]]></body>
        </method>
    </implementation>

    <handlers>
        <handler event="mousedown" button="0"><![CDATA[
            event.stopPropagation();
            var tab = event.target;
            for (; tab && !tab.panelType; tab = tab.parentNode);

            if (tab)
            {
                // Select after a timeout to increase teh snappy
                setTimeout(FBL.bindFixed(function()
                {
                    this.selectTab(tab);
                }, this));
            }
        ]]></handler>
    </handlers>
</binding>

<binding id="panelBarArrowscrollbox"
    extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll">
    <implementation>
        <constructor><![CDATA[
            this.panelBar = FBL.getAncestorByClass(this, "panelBar");
            this.panelTabs = FBL.getElementByClass(this, "panelTabs");
            this.scrollbox = document.getAnonymousElementByAttribute(this, "anonid", "scrollbox");
            window.addEventListener("resize", this, false);
        ]]></constructor>
        <method name="_getScrollableElements">
            <body><![CDATA[
                return this.panelTabs.childNodes;
            ]]></body>
        </method>
        <method name="handleEvent">
            <parameter name="event"/>
            <body><![CDATA[
                switch (event.type) {
                case "resize":
                    this.adjustTabSize(event);
                break;
            }
            ]]></body>
        </method>
        <method name="adjustTabSize">
            <parameter name="event"/>
            <body><![CDATA[
            if (!this.initialized)
                return;

            // Don't shrink at all if the pref is set to zero or less.
            if (Firebug.panelTabMinWidth <= 0)
                return;

            var totalWidth = parseInt(this.scrollbox.boxObject.width, 10);
            if (!totalWidth)
                return;

            var tabs = FBL.cloneArray(this.panelTabs.children);
            if (!tabs.length)
                return;

            var availableSpace = totalWidth;
            while (tabs.length && availableSpace > 0)
            {
                var noSpace = true;
                var tabWidth = Math.max(Firebug.panelTabMinWidth, availableSpace / tabs.length);
                for (var i=0; i<tabs.length; i++)
                {
                    var tab = tabs[i];
                    tab.style.maxWidth = tab.selected == "true" ? "none" : tabWidth + "px";
                    if (tab.originalWidth <= tabWidth)
                    {
                        noSpace = false;
                        tabs.splice(i, 1);
                        availableSpace = availableSpace - tab.originalWidth;
                        break;
                    }
                }
                if (noSpace)
                    break;
            }
            ]]></body>
        </method>
        <method name="updateOriginalSize">
            <body><![CDATA[
            if (this.initialized)
                return;
            var tab = this.panelTabs.firstChild;
            while (tab)
            {
                tab.originalWidth = tab.boxObject.width;
                tab = tab.nextSibling;
            }
            this.initialized = true;
            ]]></body>
        </method>
        <method name="ensureVisibleTab">
            <parameter name="tab"/>
            <body><![CDATA[
            if (tab)
                this.scrollBoxObject.ensureElementIsVisible(tab);
            ]]></body>
        </method>
    </implementation>
    <handlers>
        <handler event="underflow"><![CDATA[
            if (event.detail == 0)
                return; // Ignore vertical events
            this.updateOriginalSize();
        ]]></handler>
        <handler event="overflow"><![CDATA[
            if (event.detail == 0)
                return; // Ignore vertical events

            this.updateOriginalSize();

            this.ensureVisibleTab(this.panelBar.selectedTab);
        ]]></handler>
    </handlers>
</binding>

<binding id="panelBarTabList" display="xul:box">
    <content>
        <xul:toolbarbutton class="tabs-alltabs-button noTabStop" type="menu" xbl:inherits="tooltiptext">
            <xul:menupopup anonid="popup" />
        </xul:toolbarbutton>
    </content>
    <implementation>
        <constructor>
        <![CDATA[
            this.popup = document.getAnonymousElementByAttribute(this, "anonid", "popup");
            this.panelBar = document.getElementById("fbPanelBar1");
        ]]>
        </constructor>
        <method name="updateMenuItems">
            <body><![CDATA[
            var visibleTabs = [];
            var menuItem = this.popup.firstChild;
            while (menuItem)
            {
                var checked = menuItem.getAttribute("checked") == "true";
                if (checked)
                    visibleTabs.push(menuItem);

                menuItem.removeAttribute("disabled");
                menuItem = menuItem.nextSibling;
            }

            // If there is only one panel visible don't allow to close it.
            if (visibleTabs.length == 1)
                visibleTabs[0].setAttribute("disabled", true);
            ]]></body>
        </method>
    </implementation>
    <handlers>
        <handler event="popupshowing"><![CDATA[
            var tab = this.panelBar.panelTabs.firstChild;
            while (tab)
            {
                var menuItem = document.createElement("menuitem");
                menuItem.setAttribute("class", "panelBarTabListMenuItem");
                menuItem.setAttribute("type", "checkbox");
                menuItem.setAttribute("checked", FBL.isVisible(tab));
                menuItem.setAttribute("label", tab.label);
                menuItem.panelType = tab.panelType;
                this.popup.appendChild(menuItem);
                tab = tab.nextSibling;
            }

            // Create separator
            this.popup.appendChild(document.createElement("menuseparator"));

            this.updateMenuItems();

            // The last menu item is for opening all panels.
            var menuItem = document.createElement("menuitem");
            menuItem.setAttribute("label", FBL.$STR("firebug.Show_All_Panels"));
            var listener = FBL.bind(this.panelBar.openAllPanels, this.panelBar);
            menuItem.addEventListener("command", listener, false);
            this.popup.appendChild(menuItem);

            return true;
        ]]></handler>
        <handler event="popuphidden"><![CDATA[
            FBL.eraseNode(this.popup);
        ]]></handler>
        <handler event="command"><![CDATA[
            var menuItem = event.originalTarget;
            var panelName = menuItem.panelType.prototype.name;
            this.panelBar.selectPanel(panelName);
        ]]></handler>
    </handlers>
</binding>

<binding id="panelBarTabListMenuItem" extends="chrome://global/content/bindings/menu.xml#menuitem-iconic">
    <implementation>
        <constructor>
        <![CDATA[
            var iconNode = document.getAnonymousElementByAttribute(this, "class", "menu-iconic-left");
            iconNode.allowEvents = true;
            iconNode.addEventListener("click", FBL.bind(this.onTogglePanel, this), true);
            this.panelBar = FBL.getAncestorByClass(this, "panelBar");
        ]]>
        </constructor>
        <method name="onTogglePanel">
            <parameter name="event"/>
            <body><![CDATA[
            if (this.getAttribute("disabled") == "true")
                return;

            var panelName = this.panelType.prototype.name;
            var checked = this.getAttribute("checked") == "true";
            this.setAttribute("checked", checked ? "false" : "true");
            this.panelBar.togglePanel(panelName, !checked);

            FBL.$("panelBarTabList").updateMenuItems();
            ]]></body>
        </method>
    </implementation>
</binding>

<binding id="panelTab" display="xul:button">
    <content>
        <xul:image class="panelTab-left"/>
        <xul:label class="panelTab-text" crop="right" flex="1"
                   xbl:inherits="value=label,accesskey,crop,toolbarmode,buttonstyle,disabled"/>
        <children includes="panelTabMenu"/>
        <xul:image class="panelTab-right"/>
    </content>
    <implementation>
        <constructor>
        <![CDATA[
            this.labelNode = document.getAnonymousElementByAttribute(this, "class", "panelTab-text"),
            this.setAttribute('role', 'tab');
            this.setAttribute('aria-haspopup', 'true');
            if (!this.tabMenu)
            {
                this.tabMenu = document.createElement("panelTabMenu");
                this.appendChild(this.tabMenu);
            }
            return this.tabMenu;
        ]]>
        </constructor>
        <method name="setModule">
            <parameter name="module"/>
            <body><![CDATA[
            // Make sure the property exists.
            this.tabMenu.module = module ? module : null;
            ]]></body>
        </method>
        <property name="selected">
            <getter><![CDATA[
                return this.getAttribute("selected");
            ]]></getter>
            <setter><![CDATA[
                this.setAttribute("selected", val);
                this.tabMenu.updateVisibility();
            ]]></setter>
        </property>
        <property name="label">
            <getter><![CDATA[
                return this.labelNode.getAttribute("value");
            ]]></getter>
            <setter><![CDATA[
                this.labelNode.setAttribute(val);
            ]]></setter>
        </property>
    </implementation>
</binding>

<binding id="panelTabMenu" display="xul:button" extends="chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton">
    <content>
        <xul:menupopup anonid="popup" />
        <xul:image anonid="menuTarget" class="menuTarget"/>
    </content>
    <implementation>
        <constructor>
        <![CDATA[
            this.setAttribute('role', 'menu');
            this.popup = document.getAnonymousElementByAttribute(this, "anonid", "popup");
        ]]>
        </constructor>
        <field name="value"/>
        <field name="module"/>
        <property name="selectedPanel">
            <getter><![CDATA[
                var parentNode = this.parentNode;
                while (parentNode)
                {
                    if (parentNode.hasOwnProperty("selectedPanel"))
                        return parentNode.selectedPanel;
                    parentNode = parentNode.parentNode;
                }
                return null;
            ]]></getter>
        </property>
        <method name="onEnable">
            <body><![CDATA[
            if (this.module)
                this.module.setDefaultState(true);
            ]]></body>
        </method>
        <method name="onDisable">
            <body><![CDATA[
            if (this.module)
                this.module.setDefaultState(false);
            ]]></body>
        </method>
        <method name="optionMenu">
            <parameter name="label"/>
            <parameter name="checked"/>
            <parameter name="command"/>
            <body><![CDATA[
            return {label: label, type: "radio", checked: checked,
                command: FBL.bindFixed(command, this)};
            ]]></body>
        </method>
        <method name="updateVisibility">
            <body><![CDATA[
            // Hide the mini-menu (displaying panel's option) if following is true:
            // 1) The panel isn't activable (this.module == null) and so there are
            //    no enable/disable options.
            // 2) The panel doesn't provide any additional options.
            var panel = this.selectedPanel;
            var panelItems = panel ? panel.getOptionsMenuItems(FirebugContext) : null;
            if (!this.module && !(panelItems && panelItems.length))
                this.setAttribute("collapsed", "true");
            ]]></body>
        </method>
    </implementation>
    <handlers>
        <handler event="mousedown" button="0"><![CDATA[
            this.popup.showPopup(this, -1, -1, "popup", "bottomleft", "topleft");
        ]]></handler>
        <handler event="popupshowing"><![CDATA[
            if (!this.selectedPanel)
                return false;

            var items = [];

            // Create menu items for activation. The module is set only for activable modules.
            if (this.module)
            {
                var enabled = this.module.isAlwaysEnabled();
                items.push(this.optionMenu("panel.Enabled", enabled, this.onEnable));
                items.push(this.optionMenu("panel.Disabled", !enabled, this.onDisable));
            }

            // Get panel's option items.
            var panelItems = this.selectedPanel.getOptionsMenuItems(FirebugContext);
            if (!panelItems)
                return false;

            // If the module is disabled, gray out all the options.
            if (!enabled && this.module)
            {
                for (var i = 0; i < panelItems.length; i++)
                    panelItems[i].disabled = true;
            }

            if (panelItems.length > 0)
                items.push("-");

            var menu = FBL.extendArray(items, panelItems);
            for (var i = 0; i < menu.length; ++i)
                FBL.createMenuItem(this.popup, menu[i]);

            return true;
        ]]></handler>
        <handler event="popuphidden"><![CDATA[
            FBL.eraseNode(this.popup);
        ]]></handler>
    </handlers>
</binding>

<binding id="panelStatus">
    <implementation>
        <method name="addItem">
            <parameter name="label"/>
            <parameter name="object"/>
            <parameter name="rep"/>
            <parameter name="separator"/>
            <body><![CDATA[
                if (this.firstChild)
                {
                    var box = document.createElement("hbox");  // extra box needed to fix alignment issue in Vista theme
                    box.setAttribute('role', 'separator');
                    box.setAttribute('align', 'center');
                    var sep = document.createElement("label");
                    sep.setAttribute("class", "panelStatusSeparator");
                    sep.setAttribute("value", separator);
                    sep.setAttribute('role', 'presentation');
                    box.appendChild(sep);
                    this.appendChild(box);
                }

                var item = document.createElement("toolbarbutton");
                item.setAttribute("class", "panelStatusLabel");
                item.setAttribute("label", label);
                item.repObject = object;
                item.rep = rep;
                this.appendChild(item);
                return item;
            ]]></body>
        </method>

        <method name="clear">
            <parameter name="tab"/>
            <body><![CDATA[
                while (this.lastChild)
                    this.removeChild(this.lastChild);
            ]]></body>
        </method>

        <method name="getItemByObject">
            <parameter name="object"/>
            <body><![CDATA[
                for (var item = this.lastChild; item; item = item.previousSibling)
                {
                    if (item.rep)
                    {
                        var itemObject = item.rep.getRealObject(item.repObject, FirebugContext);
                        if (itemObject == object)
                            return item;
                    }
                }
            ]]></body>
        </method>

        <method name="selectObject">
            <parameter name="object"/>
            <body><![CDATA[
                var item = this.getItemByObject(object);
                this.selectItem(item);
            ]]></body>
        </method>

        <method name="selectItem">
            <parameter name="item"/>
            <body><![CDATA[
                if (this.selectedItem)
                    this.selectedItem.removeAttribute("selected");

                this.selectedItem = item;

                if (item)
                {
                    item.setAttribute("selected", "true");

                    var ev = document.createEvent("Events");
                    ev.initEvent("selectItem", true, false);
                    this.dispatchEvent(ev);
                }
            ]]></body>
        </method>
    </implementation>

    <handlers>
        <handler event="command" ><![CDATA[
            var object = Firebug.getRepObject(event.target);
            if (object)
            {
                var rep = Firebug.getRep(object);
                object = rep.getRealObject(object, FirebugContext);
                if (object)
                {
                    this.selectObject(object);
                    Firebug.chrome.select(object, null, null, true);
                }
            }
        ]]></handler>

        <handler event="mouseover"><![CDATA[
            var object = Firebug.getRepObject(event.target);
            if (object)
            {
                var rep = Firebug.getRep(object);
                object = rep.getRealObject(object, FirebugContext);
                if (object)
                    Firebug.Inspector.highlightObject(object, FirebugContext);
            }
        ]]></handler>

        <handler event="mouseout"><![CDATA[
            Firebug.Inspector.highlightObject(null);
        ]]></handler>
    </handlers>
</binding>

<binding id="panelFileList">

    <content popup="_child">
        <xul:label class="toolbarbutton-text title" crop="right" flex="1"
            xbl:inherits="value=title"/>
        <xul:menupopup anonid="popup" position="after_start"/>
        <children includes="observes|template|menupopup|tooltip"/>
        <xul:image class="toolbarbutton-icon"
            xbl:inherits="validate,src=image,toolbarmode,buttonstyle"/>
        <xul:label class="toolbarbutton-text label" crop="right" flex="1"
             xbl:inherits="value=label,accesskey,crop,toolbarmode,buttonstyle"/>
        <xul:dropmarker type="menu" class="toolbarbutton-menu-dropmarker"
            xbl:inherits="disabled,label"/>
    </content>

    <resources>
        <stylesheet src="chrome://global/skin/toolbarbutton.css"/>
    </resources>

    <implementation>
        <constructor><![CDATA[
            this.popup = document.getAnonymousElementByAttribute(this, "anonid", "popup");
            this._closed = true;
        ]]></constructor>

        <property name="location">
            <getter><![CDATA[
                if (FBTrace.DBG_LOCATIONS)
                    FBTrace.sysout("location getter label:"+this.getAttribute('label')+" location: "+this.getAttribute('location'));
                return this.getAttribute("location");
            ]]></getter>

            <setter><![CDATA[
                var locator = this.getLocator();

                var fileName = null;
                if (!locator)
                {
                    fileName = "no locator!";
                }
                else if (val)
                {
                    var description = locator.getObjectDescription(val);
                    fileName = (description.label?description.label:description.name);
                }
                else
                    fileName = "(none)";

                this.repObject = val;
                this.setAttribute("label", FBL.cropString(fileName, 80));
                this.setAttribute("location", val);
                if (FBTrace.DBG_LOCATIONS)
                    FBTrace.sysout("location setter label:"+this.getAttribute('label')+" fileName: "+fileName+ " val: "+val);
            ]]></setter>
        </property>

        <method name="getLocator">
            <body><![CDATA[
                if (!this.locator)  // XXXjjb this is complicated because the location list depends upon the current panel
                {
                    var functionYieldingExpression = this.getAttribute("locationProvider");
                    if (functionYieldingExpression && functionYieldingExpression.length > 0)
                        this.locator = eval(functionYieldingExpression);
                    else
                    {
                        var whichBinding = this.getAttribute("id");
                        var msg = "ERROR: panelFileList "+whichBinding+" requires attribute \'locationProvider\', an expression yielding a function";
                        FBTrace.sysout(msg);
                        return null;
                    }
                }
                // The locator needs
                //     getObjectDescription(object): return {path, name}
                //     getLocationList(), a list of objects that can be fed into getObjectDescription
                //     getObjectLocation(object)
                return this.locator(this);
            ]]></body>
        </method>

        <method name="showPopup">
            <body><![CDATA[
                this.popup.showPopup(this, -1, -1, "popup", "bottomleft", "topleft");
            ]]></body>
        </method>

        <method name="selectObject">
            <parameter name="object"/>
            <body><![CDATA[
                this.repObject = object;

                var ev = document.createEvent("Events");
                ev.initEvent("selectObject", true, false);
                this.dispatchEvent(ev);
            ]]></body>
        </method>

        <method name="enterActiveItem">
            <body><![CDATA[
                for (var child = this.popup.firstChild; child; child = child.nextSibling)
                {
                    if (child.getAttribute("_moz-menuactive") == "true")
                    {
                        this.location = child.repObject;
                        this.selectObject(child.repObject);
                        this.popup.hidePopup();
                    }
                }
            ]]></body>
        </method>

        <method name="filterList">
            <parameter name="substring"/>
            <body><![CDATA[
                var firstMatch = null;
                var groupMatchCount = 0;
                for (var child = this.popup.lastChild; child; child = child.previousSibling)
                {
                    if (child.localName == "menuitem")
                    {
                        var label = child.getAttribute("label").toLowerCase();
                        child._searchMatch = label.indexOf(substring) != -1;
                        if (child._searchMatch)
                        {
                            firstMatch = child;
                            ++groupMatchCount;
                        }
                    }
                    else
                    {
                        child._searchMatch = !!groupMatchCount;
                        groupMatchCount = 0;
                    }
                }

                if (firstMatch)
                {
                    for (var child = this.popup.firstChild; child; child = child.nextSibling)
                    {
                        child.hidden = !child._searchMatch;
                        child.removeAttribute("_moz-menuactive");
                    }

                    firstMatch.setAttribute("_moz-menuactive", "true");
                }
            ]]></body>
        </method>

        <method name="onKeyPress">
            <parameter name="event"/>
            <body><![CDATA[
                if (event.keyCode == 13) // Return
                {
                    this.enterActiveItem();
                    this.searchString = '';
                }
                else if (event.keyCode == 8) // Backspace
                {
                    this.searchString = this.searchString.substr(0, this.searchString.length-1);
                    this.filterList(this.searchString);
                }
                else if (event.charCode)
                {
                    this.searchString += String.fromCharCode(event.charCode).toLowerCase();
                    this.filterList(this.searchString);
                }
                else
                    return;

                Firebug.Search.displayOnly(this.searchString, FirebugContext);
                FBL.cancelEvent(event);
            ]]></body>
        </method>
    </implementation>

    <handlers>
        <handler event="popupshowing"><![CDATA[
            if (this.popup.firstChild)
                return false;
            var locator = this.getLocator();
            var objects = locator.getLocationList();
            if (!objects)
            {
                this.setAttribute("label", "");
                this.setAttribute("location", null);
                return false;
            }

            var groupNames = [];
            var groups = {};

            var currentDescription = null;
            if (this.repObject)
                currentDescription = locator.getObjectDescription(this.repObject);

            for (var i = 0; i < objects.length; ++i)
            {
                var object = objects[i];
                var description = locator.getObjectDescription(object);
                if (!description)
                    FBTrace.sysout("binding.xml popupshowing Fails" , object);
                var entry = {object: object, fileName: description.name};

                if (currentDescription && currentDescription.name == description.name && currentDescription.path == description.path)
                    entry.selected = true;

                if (groups.hasOwnProperty(description.path))
                    groups[description.path].push(entry);
                else
                {
                    groups[description.path] = [entry];
                    groupNames.push(description.path);
                }
            }

            groupNames.sort();

            for (var i = 0; i < groupNames.length; ++i)
            {
                var path = groupNames[i];
                var urls = groups[path];
                urls.sort(function(a, b) { return a.fileName < b.fileName ? -1 : 1; });

                var menuHeader = FBL.createMenuHeader(this.popup, {label: path, nol10n: true});
                FBL.setClass(menuHeader, "fbURLMenuItem");

                for (var j = 0; j < urls.length; ++j)
                {
                    var menuInfo = {label: urls[j].fileName, nol10n: true};

                    if (urls[j].selected)
                    {
                        menuInfo.type = "checkbox";
                        menuInfo.checked = true;
                    }

                    var menuItem = FBL.createMenuItem(this.popup, menuInfo);
                    menuItem.repObject = urls[j].object;
                    FBL.setClass(menuItem, "fbURLMenuItem");
                }
            }

        ]]></handler>

        <handler event="popupshown"><![CDATA[
            // Weird, but this gets fired when the user clicks on a menuitem,
            // which hiding the buttons again and resulting in jitters - let's avoid that.
            if (!this._closed)
                return;

            // XXXjoe There is a bug in the <xul:autoscrollbox> code which,
            // for reasons I don't grasp yet, never hides the scroll buttons
            // after the first them they are shown - so we must do it ourselves
            var scrollbox = document.getAnonymousElementByAttribute(
                this.popup, "class", "popup-internal-box");
            if (scrollbox["_scrollButtonUp"])
                scrollbox["_scrollButtonUp"].collapsed = true;
            if (scrollbox["_scrollButtonDown"])
                scrollbox["_scrollButtonDown"].collapsed = true;

            this._closed = false;

            this.searchString = "";
            this.onkeypress = FBL.bind(this.onKeyPress, this);
            window.addEventListener("keypress", this.onkeypress, true);
        ]]></handler>

        <handler event="popuphidden"><![CDATA[
            window.removeEventListener("keypress", this.onkeypress, true);
            delete this.onkeypress;
            delete this.searchString;

            FBL.eraseNode(this.popup);
            this._closed = true;
        ]]></handler>

        <handler event="command"><![CDATA[
            var object = event.originalTarget.repObject;

            // Select after a timeout to increase teh snappy
            setTimeout(FBL.bindFixed(function()
            {
                this.selectObject(object);
            }, this));
        ]]></handler>

        <handler event="mouseover"><![CDATA[
            var object = Firebug.getRepObject(event.target);
            if (object)
            {
                var locator = this.getLocator();
                if (locator.getObjectLocation)
                    event.target.setAttribute('tooltiptext', locator.getObjectLocation(object));
                else
                {
                    if (FBTrace.DBG_LOCATIONS)
                        FBTrace.sysout("!locator.getObjectLocation for "+ this.getAttribute('label'), locator);
                }
            }

            return;
        ]]></handler>
    </handlers>
</binding>

<binding id="searchBox">
    <content sizetopopup="none">
        <xul:textbox anonid="searchBox"
                rows="1" label="search.Firebug_Search" class="fbsearch-textbox" onkeyup="onSearchBoxKeyUp(event);" aria-describedby="fbSearchBoxDescription" />
                <xul:description anonid="fbSearchBoxDescription"  collapsed="true" tooltiptext="Press up or down arrow key for search options" />
        <xul:panel id="fbSearchOptionsPanel" norestorefocus="true" noautofocus="true" ignorekeys="true" onkeydown="onPopupKeyDown(event)" role="presentation">
            <xul:vbox class="searchOptionsMenu innerToolbar" role="menu" aria-label="search options">
              <xul:box anonid="startPanelFocus" class="panelFocusBound" onfocus="startFocusHandler()"  />
              <xul:vbox anonid="searchOptionsList" role="presentation" />
              <xul:hbox pack="center" align="center" role="presentation">
                  <xul:button anonid="searchPrev" class="fbsearch-options-buttons a11yFocus" label="search.Previous" oncommand="searchPrev()" role="menuitem" />
                  <xul:button anonid="searchNext" class="fbsearch-options-buttons a11yFocus" label="search.Next" oncommand="searchNext()" role="menuitem" />
              </xul:hbox>
              <xul:box anonid="endPanelFocus" class="panelFocusBound" onfocus="endFocusHandler()" />
            </xul:vbox>
        </xul:panel>
        <xul:box anonid="endTextFocus" class="panelFocusBound" onfocus="endTextFocusHandler()" />
    </content>

    <implementation>
        <constructor><![CDATA[
            var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox"),
                searchPrev = document.getAnonymousElementByAttribute(this, "anonid", "searchPrev"),
                searchNext = document.getAnonymousElementByAttribute(this, "anonid", "searchNext"),
                optionsPopup = document.getElementById("fbSearchOptionsPanel");
            FBL.internationalize(searchBox, "label");
            FBL.internationalize(searchPrev, "label");
            FBL.internationalize(searchNext, "label");

            searchBox.addEventListener("focus", FBL.bind(this.focusHandler, this), true);
            optionsPopup.addEventListener("focus", FBL.bind(this.panelFocusHandler, this), true);
        ]]></constructor>
        <property name="value">
            <xbl:getter><![CDATA[
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                return searchBox.value;
            ]]></xbl:getter>
            <xbl:setter><![CDATA[
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                searchBox.value = val;
            ]]></xbl:setter>
        </property>
        <property name="optionsShown">
            <xbl:getter><![CDATA[
                var optionsPopup = document.getElementById("fbSearchOptionsPanel");
                return optionsPopup.state == "open";
            ]]></xbl:getter>
        </property>

        <!-- Flag indicating that the child of the panel has or just had focus -->
        <field name="panelHasFocus" />
        <field name="blurTimeout" />

        <method name="updateOptions">
            <parameter name="menuItems" />
            <body><![CDATA[
                var searchOptions = document.getAnonymousElementByAttribute(this, "anonid", "searchOptionsList");
                FBL.eraseNode(searchOptions);

                if (menuItems)
                {
                    for (var i=0; i<menuItems.length; i++)
                    {
                        var checkbox = document.createElement("checkbox");
                        checkbox.className = "fbsearch-options-label a11yFocus";
                        checkbox.setAttribute("role", "menuitemcheckbox")
                        FBL.setItemIntoElement(checkbox, menuItems[i]);

                        searchOptions.appendChild(checkbox);
                    }
                }
            ]]></body>
        </method>
        <method name="showOptions">
            <body><![CDATA[
                var optionsPopup = document.getElementById("fbSearchOptionsPanel"),
                    searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox"),
                    position = (Firebug.getPlacement() == "detached") ? "after_end" : "before_end";
                optionsPopup.setAttribute("position", position);
                optionsPopup.openPopup(this, position, 0, 0, false, false);

                clearTimeout(this.blurTimeout);
                delete this.blurTimeout;
            ]]></body>
        </method>
        <method name="hideOptions">
            <body><![CDATA[
                var optionsPopup = document.getElementById("fbSearchOptionsPanel");
                optionsPopup.hidePopup();

                clearTimeout(this.blurTimeout);
                delete this.blurTimeout;
            ]]></body>
        </method>
        <method name="searchNext">
            <body><![CDATA[
                Firebug.Search.searchNext(FirebugContext);
            ]]></body>
        </method>
        <method name="searchPrev">
            <body><![CDATA[
                Firebug.Search.searchPrev(FirebugContext);
            ]]></body>
        </method>

        <method name="focus">
            <body><![CDATA[
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                searchBox.focus();
            ]]></body>
        </method>
        <method name="select">
            <body><![CDATA[
                var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                searchBox.select();
            ]]></body>
        </method>

        <!--
        Focus management handlers. These must be defined as methods and registered
        using addEventListener or attribute registration as XBL handlers do not
        appear to allow access to anonymous event targets when capturing.
         -->
        <method name="focusHandler">
            <parameter name="event" />
            <body><![CDATA[
                var target = event.target;
                clearTimeout(this.blurTimeout);
                delete this.blurTimeout;

                if (!FBL.hasClass(target, "panelFocusBound")) {
                    this.showOptions();
                }
            ]]></body>
        </method>
        <method name="panelFocusHandler">
            <parameter name="event" />
            <body><![CDATA[
                this.focusHandler(event);

                if (!FBL.hasClass(event.target, "panelFocusBound")) {
                    this.panelHasFocus = true;
                }
            ]]></body>
        </method>
        <method name="endTextFocusHandler">
            <body><![CDATA[
                clearTimeout(this.blurTimeout);
                delete this.blurTimeout;

                if (this.panelHasFocus) {
                    // The user has just tabbed out of the panel
                    document.commandDispatcher.advanceFocus();
                    this.panelHasFocus = false;
                } else if (this.optionsShown) {
                    // The user has just tabbed out of the search box (and into the panel)
                    var optionsPopup = document.getElementById("fbSearchOptionsPanel");
                    document.commandDispatcher.advanceFocusIntoSubtree(optionsPopup);
                } else {
                    // The user has just reverse tabbed from the next tab target
                    this.showOptions();

                    var searchNext = document.getAnonymousElementByAttribute(this, "anonid", "searchNext");
                    setTimeout(function() { searchNext.focus(); }, 0);
                    this.panelHasFocus = true;
                }
            ]]></body>
        </method>
        <method name="startFocusHandler">
            <body><![CDATA[
                if (this.panelHasFocus) {
                    // The user has shift-tabbed out of the panel
                    var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox")
                    searchBox.focus();
                } else {
                    // The user has just tabbed into the panel
                    document.commandDispatcher.advanceFocus();
                    this.panelHasFocus = true;
                }
            ]]></body>
        </method>
        <method name="endFocusHandler">
            <body><![CDATA[
                // The user has just tabbed out of the panel
                this.hideOptions();

                var endTextFocus = document.getAnonymousElementByAttribute(this, "anonid", "endTextFocus");
                endTextFocus.focus();
            ]]></body>
        </method>
        <method name="onSearchBoxKeyUp">
            <parameter name="event" />
            <body><![CDATA[
                if (!Firebug.A11yModel || !Firebug.A11yModel.isEnabled())
                    return;
                if (event.keyCode ==  KeyEvent.DOM_VK_UP || event.keyCode ==  KeyEvent.DOM_VK_DOWN)
                {
                    var goingDown = event.keyCode ==  KeyEvent.DOM_VK_DOWN;
                    var optionsPopup = document.getElementById("fbSearchOptionsPanel");
                    var items = optionsPopup.getElementsByClassName("a11yFocus");
                    if (!optionsPopup || !items)
                        return;
                    if (optionsPopup.state == "closed")
                        this.showOptions();
                    setTimeout(FBL.bindFixed(function(){items[goingDown ? 0 : items.length -1].focus();}));
                }
                else if (event.keyCode ==  KeyEvent.DOM_VK_ESCAPE)
	                this.hideOptions();
            ]]></body>
        </method>
        <method name="onPopupKeyDown">
            <parameter name="event" />
            <body><![CDATA[
                if (!Firebug.A11yModel || !Firebug.A11yModel.isEnabled())
                    return;
                if (event.keyCode ==  KeyEvent.DOM_VK_ESCAPE)
                {
                    var optionsPopup = document.getElementById("fbSearchOptionsPanel");
                    var items = optionsPopup.getElementsByClassName("a11yFocus");
                    var searchBox = document.getAnonymousElementByAttribute(this, "anonid", "searchBox");
                    if (!optionsPopup || !items || !searchBox)
                        return;
                    searchBox.focus();
                    optionsPopup.hidePopup();
                }
            ]]></body>
        </method>
    </implementation>
    <handlers>
            <handler event="keypress"><![CDATA[
            if (event.keyCode ==  KeyEvent.DOM_VK_RETURN)
            {
                if (FBL.isShift(event))
                    this.searchPrev();
                else if (FBL.isControl(event))
                    FBL.dispatch([Firebug.A11yModel], 'moveToSearchMatch');
                else
                    this.searchNext();
            }
            else
                return;

            FBL.cancelEvent(event);
        ]]></handler>

        <handler event="input"><![CDATA[
            Firebug.Search.update(FirebugContext);
        ]]></handler>

        <handler event="popupshowing"><![CDATA[
            this.panelHasFocus = false;
        ]]></handler>
        <handler event="blur" phase="capturing"><![CDATA[
            this.blurTimeout = this.blurTimeout || setTimeout(function() {
                hideOptions();
            }, 0);
        ]]></handler>
    </handlers>
</binding>

<binding id="commandLine" extends="chrome://global/content/bindings/textbox.xml#textarea">
    <handlers>
        <handler event="input"><![CDATA[
            Firebug.CommandLine.update(FirebugContext);
        ]]></handler>

        <handler event="overflow"><![CDATA[
            if (window.Firebug)
                Firebug.CommandLine.checkOverflow(FirebugContext);
        ]]></handler>

        <handler event="keypress" keycode="VK_TAB"><![CDATA[
            if (this.value == "")
            {
                return;
            }
            Firebug.CommandLine.complete(FirebugContext, FBL.isShift(event));
            event.preventDefault();
        ]]></handler>

        <handler event="keypress" keycode="VK_RETURN" modifiers="" preventdefault="true"><![CDATA[
            Firebug.CommandLine.enter(FirebugContext);
        ]]></handler>

        <handler event="keypress" keycode="VK_RETURN" modifiers="meta" preventdefault="true"><![CDATA[
            Firebug.CommandLine.enterMenu(FirebugContext);
        ]]></handler>

        <handler event="keypress" keycode="VK_RETURN" modifiers="shift" preventdefault="true"><![CDATA[
            Firebug.CommandLine.enterInspect(FirebugContext);
        ]]></handler>

        <handler event="keypress" keycode="VK_UP" preventdefault="true"><![CDATA[
            Firebug.CommandLine.cycleCommandHistory(FirebugContext, -1);
        ]]></handler>

        <handler event="keypress" keycode="VK_DOWN" preventdefault="true"><![CDATA[
            Firebug.CommandLine.cycleCommandHistory(FirebugContext, 1);
        ]]></handler>

        <handler event="keypress" keycode="VK_ESCAPE" preventdefault="true"><![CDATA[
            Firebug.CommandLine.cancel(FirebugContext);
        ]]></handler>
    </handlers>
</binding>

<binding id="largeCommandLine" extends="chrome://global/content/bindings/textbox.xml#textarea">
    <handlers>
        <handler event="input"><![CDATA[
            Firebug.CommandLine.update(FirebugContext);
        ]]></handler>

        <handler event="keypress" keycode="VK_TAB"><![CDATA[
            var input = document.getAnonymousElementByAttribute(this, "anonid", "input");
            FBL.insertTextIntoElement(input, Firebug.Editor.tabCharacter);
            event.preventDefault();
        ]]></handler>

        <handler event="keypress" keycode="VK_RETURN" modifiers="meta" preventdefault="true"><![CDATA[
            Firebug.CommandLine.enter(FirebugContext);
        ]]></handler>

        <handler event="keypress" keycode="VK_RETURN" modifiers="control" preventdefault="true"><![CDATA[
            Firebug.CommandLine.enter(FirebugContext);
        ]]></handler>

        <handler event="keypress" keycode="VK_ESCAPE" preventdefault="true"><![CDATA[
            Firebug.CommandLine.cancel(FirebugContext);
        ]]></handler>
    </handlers>
</binding>

</bindings>
